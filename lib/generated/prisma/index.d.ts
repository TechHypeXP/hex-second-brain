
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * Model for Supabase auth.users table
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserProfile
 * Extends the core User model with application-specific data.
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model Space
 * A user-defined space to organize resources.
 */
export type Space = $Result.DefaultSelection<Prisma.$SpacePayload>
/**
 * Model Resource
 * Represents the resources provided by users.
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model ResourceVersion
 * A version snapshot of a resource's metadata and content.
 */
export type ResourceVersion = $Result.DefaultSelection<Prisma.$ResourceVersionPayload>
/**
 * Model Classification
 * Represents the classification of resources.
 */
export type Classification = $Result.DefaultSelection<Prisma.$ClassificationPayload>
/**
 * Model ContentSummary
 * Summaries generated from the content of a resource.
 */
export type ContentSummary = $Result.DefaultSelection<Prisma.$ContentSummaryPayload>
/**
 * Model VectorChunk
 * Chunks of content vectorized for semantic search.
 */
export type VectorChunk = $Result.DefaultSelection<Prisma.$VectorChunkPayload>
/**
 * Model ContentRelationship
 * Defines a relationship between two pieces of content.
 */
export type ContentRelationship = $Result.DefaultSelection<Prisma.$ContentRelationshipPayload>
/**
 * Model KnowledgeNode
 * Represents an abstract concept or entity within the knowledge graph.
 */
export type KnowledgeNode = $Result.DefaultSelection<Prisma.$KnowledgeNodePayload>
/**
 * Model KnowledgeEdge
 * Defines a relationship between two KnowledgeNodes.
 */
export type KnowledgeEdge = $Result.DefaultSelection<Prisma.$KnowledgeEdgePayload>
/**
 * Model SearchQuery
 * Logs user search queries and their performance.
 */
export type SearchQuery = $Result.DefaultSelection<Prisma.$SearchQueryPayload>
/**
 * Model LearningAnalytic
 * Tracks user interactions with resources for learning analytics.
 */
export type LearningAnalytic = $Result.DefaultSelection<Prisma.$LearningAnalyticPayload>
/**
 * Model BatchJob
 * Tracks the state and progress of background processing jobs.
 */
export type BatchJob = $Result.DefaultSelection<Prisma.$BatchJobPayload>
/**
 * Model PromptLog
 * Logs prompts sent to external AI services for debugging and analysis.
 */
export type PromptLog = $Result.DefaultSelection<Prisma.$PromptLogPayload>
/**
 * Model ChangeLog
 * A generic log for tracking important changes in the system.
 */
export type ChangeLog = $Result.DefaultSelection<Prisma.$ChangeLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ContentDomain: {
  business: 'business',
  technology: 'technology'
};

export type ContentDomain = (typeof ContentDomain)[keyof typeof ContentDomain]


export const ResourceType: {
  video: 'video',
  article: 'article',
  pdf: 'pdf',
  onenote: 'onenote'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const ComplexityLevel: {
  beginner: 'beginner',
  intermediate: 'intermediate',
  advanced: 'advanced'
};

export type ComplexityLevel = (typeof ComplexityLevel)[keyof typeof ComplexityLevel]


export const ProcessingStatus: {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed'
};

export type ProcessingStatus = (typeof ProcessingStatus)[keyof typeof ProcessingStatus]


export const ActionDensity: {
  low: 'low',
  medium: 'medium',
  high: 'high'
};

export type ActionDensity = (typeof ActionDensity)[keyof typeof ActionDensity]


export const ChunkType: {
  text: 'text',
  image: 'image',
  audio: 'audio',
  video: 'video'
};

export type ChunkType = (typeof ChunkType)[keyof typeof ChunkType]


export const PracticalApplicability: {
  immediate: 'immediate',
  short_term: 'short_term',
  long_term: 'long_term'
};

export type PracticalApplicability = (typeof PracticalApplicability)[keyof typeof PracticalApplicability]


export const RelationshipType: {
  RELATED: 'RELATED',
  SEQUEL: 'SEQUEL',
  PREQUEL: 'PREQUEL',
  SUPPORTS: 'SUPPORTS',
  CONTRADICTS: 'CONTRADICTS'
};

export type RelationshipType = (typeof RelationshipType)[keyof typeof RelationshipType]


export const ImplementationStatus: {
  not_started: 'not_started',
  in_progress: 'in_progress',
  completed: 'completed',
  abandoned: 'abandoned'
};

export type ImplementationStatus = (typeof ImplementationStatus)[keyof typeof ImplementationStatus]


export const BatchJobStatus: {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed'
};

export type BatchJobStatus = (typeof BatchJobStatus)[keyof typeof BatchJobStatus]


export const PromptLogTier: {
  extract: 'extract',
  validate: 'validate',
  rag: 'rag'
};

export type PromptLogTier = (typeof PromptLogTier)[keyof typeof PromptLogTier]

}

export type ContentDomain = $Enums.ContentDomain

export const ContentDomain: typeof $Enums.ContentDomain

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type ComplexityLevel = $Enums.ComplexityLevel

export const ComplexityLevel: typeof $Enums.ComplexityLevel

export type ProcessingStatus = $Enums.ProcessingStatus

export const ProcessingStatus: typeof $Enums.ProcessingStatus

export type ActionDensity = $Enums.ActionDensity

export const ActionDensity: typeof $Enums.ActionDensity

export type ChunkType = $Enums.ChunkType

export const ChunkType: typeof $Enums.ChunkType

export type PracticalApplicability = $Enums.PracticalApplicability

export const PracticalApplicability: typeof $Enums.PracticalApplicability

export type RelationshipType = $Enums.RelationshipType

export const RelationshipType: typeof $Enums.RelationshipType

export type ImplementationStatus = $Enums.ImplementationStatus

export const ImplementationStatus: typeof $Enums.ImplementationStatus

export type BatchJobStatus = $Enums.BatchJobStatus

export const BatchJobStatus: typeof $Enums.BatchJobStatus

export type PromptLogTier = $Enums.PromptLogTier

export const PromptLogTier: typeof $Enums.PromptLogTier

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.space`: Exposes CRUD operations for the **Space** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spaces
    * const spaces = await prisma.space.findMany()
    * ```
    */
  get space(): Prisma.SpaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resourceVersion`: Exposes CRUD operations for the **ResourceVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceVersions
    * const resourceVersions = await prisma.resourceVersion.findMany()
    * ```
    */
  get resourceVersion(): Prisma.ResourceVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classification`: Exposes CRUD operations for the **Classification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classifications
    * const classifications = await prisma.classification.findMany()
    * ```
    */
  get classification(): Prisma.ClassificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentSummary`: Exposes CRUD operations for the **ContentSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentSummaries
    * const contentSummaries = await prisma.contentSummary.findMany()
    * ```
    */
  get contentSummary(): Prisma.ContentSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vectorChunk`: Exposes CRUD operations for the **VectorChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VectorChunks
    * const vectorChunks = await prisma.vectorChunk.findMany()
    * ```
    */
  get vectorChunk(): Prisma.VectorChunkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentRelationship`: Exposes CRUD operations for the **ContentRelationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentRelationships
    * const contentRelationships = await prisma.contentRelationship.findMany()
    * ```
    */
  get contentRelationship(): Prisma.ContentRelationshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeNode`: Exposes CRUD operations for the **KnowledgeNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeNodes
    * const knowledgeNodes = await prisma.knowledgeNode.findMany()
    * ```
    */
  get knowledgeNode(): Prisma.KnowledgeNodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeEdge`: Exposes CRUD operations for the **KnowledgeEdge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeEdges
    * const knowledgeEdges = await prisma.knowledgeEdge.findMany()
    * ```
    */
  get knowledgeEdge(): Prisma.KnowledgeEdgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchQuery`: Exposes CRUD operations for the **SearchQuery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchQueries
    * const searchQueries = await prisma.searchQuery.findMany()
    * ```
    */
  get searchQuery(): Prisma.SearchQueryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningAnalytic`: Exposes CRUD operations for the **LearningAnalytic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningAnalytics
    * const learningAnalytics = await prisma.learningAnalytic.findMany()
    * ```
    */
  get learningAnalytic(): Prisma.LearningAnalyticDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batchJob`: Exposes CRUD operations for the **BatchJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchJobs
    * const batchJobs = await prisma.batchJob.findMany()
    * ```
    */
  get batchJob(): Prisma.BatchJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promptLog`: Exposes CRUD operations for the **PromptLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromptLogs
    * const promptLogs = await prisma.promptLog.findMany()
    * ```
    */
  get promptLog(): Prisma.PromptLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.changeLog`: Exposes CRUD operations for the **ChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangeLogs
    * const changeLogs = await prisma.changeLog.findMany()
    * ```
    */
  get changeLog(): Prisma.ChangeLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserProfile: 'UserProfile',
    Space: 'Space',
    Resource: 'Resource',
    ResourceVersion: 'ResourceVersion',
    Classification: 'Classification',
    ContentSummary: 'ContentSummary',
    VectorChunk: 'VectorChunk',
    ContentRelationship: 'ContentRelationship',
    KnowledgeNode: 'KnowledgeNode',
    KnowledgeEdge: 'KnowledgeEdge',
    SearchQuery: 'SearchQuery',
    LearningAnalytic: 'LearningAnalytic',
    BatchJob: 'BatchJob',
    PromptLog: 'PromptLog',
    ChangeLog: 'ChangeLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userProfile" | "space" | "resource" | "resourceVersion" | "classification" | "contentSummary" | "vectorChunk" | "contentRelationship" | "knowledgeNode" | "knowledgeEdge" | "searchQuery" | "learningAnalytic" | "batchJob" | "promptLog" | "changeLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      Space: {
        payload: Prisma.$SpacePayload<ExtArgs>
        fields: Prisma.SpaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          findFirst: {
            args: Prisma.SpaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          findMany: {
            args: Prisma.SpaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          create: {
            args: Prisma.SpaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          createMany: {
            args: Prisma.SpaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          delete: {
            args: Prisma.SpaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          update: {
            args: Prisma.SpaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          deleteMany: {
            args: Prisma.SpaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          upsert: {
            args: Prisma.SpaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          aggregate: {
            args: Prisma.SpaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpace>
          }
          groupBy: {
            args: Prisma.SpaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpaceCountArgs<ExtArgs>
            result: $Utils.Optional<SpaceCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      ResourceVersion: {
        payload: Prisma.$ResourceVersionPayload<ExtArgs>
        fields: Prisma.ResourceVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload>
          }
          findFirst: {
            args: Prisma.ResourceVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload>
          }
          findMany: {
            args: Prisma.ResourceVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload>[]
          }
          create: {
            args: Prisma.ResourceVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload>
          }
          createMany: {
            args: Prisma.ResourceVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload>[]
          }
          delete: {
            args: Prisma.ResourceVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload>
          }
          update: {
            args: Prisma.ResourceVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload>
          }
          deleteMany: {
            args: Prisma.ResourceVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload>[]
          }
          upsert: {
            args: Prisma.ResourceVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceVersionPayload>
          }
          aggregate: {
            args: Prisma.ResourceVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResourceVersion>
          }
          groupBy: {
            args: Prisma.ResourceVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceVersionCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceVersionCountAggregateOutputType> | number
          }
        }
      }
      Classification: {
        payload: Prisma.$ClassificationPayload<ExtArgs>
        fields: Prisma.ClassificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload>
          }
          findFirst: {
            args: Prisma.ClassificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload>
          }
          findMany: {
            args: Prisma.ClassificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload>[]
          }
          create: {
            args: Prisma.ClassificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload>
          }
          createMany: {
            args: Prisma.ClassificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload>[]
          }
          delete: {
            args: Prisma.ClassificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload>
          }
          update: {
            args: Prisma.ClassificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload>
          }
          deleteMany: {
            args: Prisma.ClassificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload>[]
          }
          upsert: {
            args: Prisma.ClassificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificationPayload>
          }
          aggregate: {
            args: Prisma.ClassificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassification>
          }
          groupBy: {
            args: Prisma.ClassificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassificationCountArgs<ExtArgs>
            result: $Utils.Optional<ClassificationCountAggregateOutputType> | number
          }
        }
      }
      ContentSummary: {
        payload: Prisma.$ContentSummaryPayload<ExtArgs>
        fields: Prisma.ContentSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload>
          }
          findFirst: {
            args: Prisma.ContentSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload>
          }
          findMany: {
            args: Prisma.ContentSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload>[]
          }
          create: {
            args: Prisma.ContentSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload>
          }
          createMany: {
            args: Prisma.ContentSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload>[]
          }
          delete: {
            args: Prisma.ContentSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload>
          }
          update: {
            args: Prisma.ContentSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload>
          }
          deleteMany: {
            args: Prisma.ContentSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentSummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload>[]
          }
          upsert: {
            args: Prisma.ContentSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentSummaryPayload>
          }
          aggregate: {
            args: Prisma.ContentSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentSummary>
          }
          groupBy: {
            args: Prisma.ContentSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<ContentSummaryCountAggregateOutputType> | number
          }
        }
      }
      VectorChunk: {
        payload: Prisma.$VectorChunkPayload<ExtArgs>
        fields: Prisma.VectorChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VectorChunkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VectorChunkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload>
          }
          findFirst: {
            args: Prisma.VectorChunkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VectorChunkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload>
          }
          findMany: {
            args: Prisma.VectorChunkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload>[]
          }
          create: {
            args: Prisma.VectorChunkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload>
          }
          createMany: {
            args: Prisma.VectorChunkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VectorChunkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload>[]
          }
          delete: {
            args: Prisma.VectorChunkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload>
          }
          update: {
            args: Prisma.VectorChunkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload>
          }
          deleteMany: {
            args: Prisma.VectorChunkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VectorChunkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VectorChunkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload>[]
          }
          upsert: {
            args: Prisma.VectorChunkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorChunkPayload>
          }
          aggregate: {
            args: Prisma.VectorChunkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVectorChunk>
          }
          groupBy: {
            args: Prisma.VectorChunkGroupByArgs<ExtArgs>
            result: $Utils.Optional<VectorChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.VectorChunkCountArgs<ExtArgs>
            result: $Utils.Optional<VectorChunkCountAggregateOutputType> | number
          }
        }
      }
      ContentRelationship: {
        payload: Prisma.$ContentRelationshipPayload<ExtArgs>
        fields: Prisma.ContentRelationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentRelationshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentRelationshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload>
          }
          findFirst: {
            args: Prisma.ContentRelationshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentRelationshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload>
          }
          findMany: {
            args: Prisma.ContentRelationshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload>[]
          }
          create: {
            args: Prisma.ContentRelationshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload>
          }
          createMany: {
            args: Prisma.ContentRelationshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentRelationshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload>[]
          }
          delete: {
            args: Prisma.ContentRelationshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload>
          }
          update: {
            args: Prisma.ContentRelationshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload>
          }
          deleteMany: {
            args: Prisma.ContentRelationshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentRelationshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentRelationshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload>[]
          }
          upsert: {
            args: Prisma.ContentRelationshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentRelationshipPayload>
          }
          aggregate: {
            args: Prisma.ContentRelationshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentRelationship>
          }
          groupBy: {
            args: Prisma.ContentRelationshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentRelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentRelationshipCountArgs<ExtArgs>
            result: $Utils.Optional<ContentRelationshipCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeNode: {
        payload: Prisma.$KnowledgeNodePayload<ExtArgs>
        fields: Prisma.KnowledgeNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          findMany: {
            args: Prisma.KnowledgeNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>[]
          }
          create: {
            args: Prisma.KnowledgeNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          createMany: {
            args: Prisma.KnowledgeNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>[]
          }
          delete: {
            args: Prisma.KnowledgeNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          update: {
            args: Prisma.KnowledgeNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeNodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeNodePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeNode>
          }
          groupBy: {
            args: Prisma.KnowledgeNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeNodeCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeNodeCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeEdge: {
        payload: Prisma.$KnowledgeEdgePayload<ExtArgs>
        fields: Prisma.KnowledgeEdgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeEdgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeEdgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeEdgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeEdgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload>
          }
          findMany: {
            args: Prisma.KnowledgeEdgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload>[]
          }
          create: {
            args: Prisma.KnowledgeEdgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload>
          }
          createMany: {
            args: Prisma.KnowledgeEdgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeEdgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload>[]
          }
          delete: {
            args: Prisma.KnowledgeEdgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload>
          }
          update: {
            args: Prisma.KnowledgeEdgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeEdgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeEdgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeEdgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeEdgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeEdgePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeEdgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeEdge>
          }
          groupBy: {
            args: Prisma.KnowledgeEdgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeEdgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeEdgeCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeEdgeCountAggregateOutputType> | number
          }
        }
      }
      SearchQuery: {
        payload: Prisma.$SearchQueryPayload<ExtArgs>
        fields: Prisma.SearchQueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchQueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchQueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findFirst: {
            args: Prisma.SearchQueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchQueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findMany: {
            args: Prisma.SearchQueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          create: {
            args: Prisma.SearchQueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          createMany: {
            args: Prisma.SearchQueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchQueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          delete: {
            args: Prisma.SearchQueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          update: {
            args: Prisma.SearchQueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          deleteMany: {
            args: Prisma.SearchQueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchQueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SearchQueryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          upsert: {
            args: Prisma.SearchQueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          aggregate: {
            args: Prisma.SearchQueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchQuery>
          }
          groupBy: {
            args: Prisma.SearchQueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchQueryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryCountAggregateOutputType> | number
          }
        }
      }
      LearningAnalytic: {
        payload: Prisma.$LearningAnalyticPayload<ExtArgs>
        fields: Prisma.LearningAnalyticFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningAnalyticFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningAnalyticFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload>
          }
          findFirst: {
            args: Prisma.LearningAnalyticFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningAnalyticFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload>
          }
          findMany: {
            args: Prisma.LearningAnalyticFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload>[]
          }
          create: {
            args: Prisma.LearningAnalyticCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload>
          }
          createMany: {
            args: Prisma.LearningAnalyticCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningAnalyticCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload>[]
          }
          delete: {
            args: Prisma.LearningAnalyticDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload>
          }
          update: {
            args: Prisma.LearningAnalyticUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload>
          }
          deleteMany: {
            args: Prisma.LearningAnalyticDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningAnalyticUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningAnalyticUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload>[]
          }
          upsert: {
            args: Prisma.LearningAnalyticUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningAnalyticPayload>
          }
          aggregate: {
            args: Prisma.LearningAnalyticAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningAnalytic>
          }
          groupBy: {
            args: Prisma.LearningAnalyticGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningAnalyticGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningAnalyticCountArgs<ExtArgs>
            result: $Utils.Optional<LearningAnalyticCountAggregateOutputType> | number
          }
        }
      }
      BatchJob: {
        payload: Prisma.$BatchJobPayload<ExtArgs>
        fields: Prisma.BatchJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload>
          }
          findFirst: {
            args: Prisma.BatchJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload>
          }
          findMany: {
            args: Prisma.BatchJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload>[]
          }
          create: {
            args: Prisma.BatchJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload>
          }
          createMany: {
            args: Prisma.BatchJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload>[]
          }
          delete: {
            args: Prisma.BatchJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload>
          }
          update: {
            args: Prisma.BatchJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload>
          }
          deleteMany: {
            args: Prisma.BatchJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload>[]
          }
          upsert: {
            args: Prisma.BatchJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchJobPayload>
          }
          aggregate: {
            args: Prisma.BatchJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchJob>
          }
          groupBy: {
            args: Prisma.BatchJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchJobCountArgs<ExtArgs>
            result: $Utils.Optional<BatchJobCountAggregateOutputType> | number
          }
        }
      }
      PromptLog: {
        payload: Prisma.$PromptLogPayload<ExtArgs>
        fields: Prisma.PromptLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload>
          }
          findFirst: {
            args: Prisma.PromptLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload>
          }
          findMany: {
            args: Prisma.PromptLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload>[]
          }
          create: {
            args: Prisma.PromptLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload>
          }
          createMany: {
            args: Prisma.PromptLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromptLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload>[]
          }
          delete: {
            args: Prisma.PromptLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload>
          }
          update: {
            args: Prisma.PromptLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload>
          }
          deleteMany: {
            args: Prisma.PromptLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromptLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromptLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload>[]
          }
          upsert: {
            args: Prisma.PromptLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptLogPayload>
          }
          aggregate: {
            args: Prisma.PromptLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromptLog>
          }
          groupBy: {
            args: Prisma.PromptLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromptLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptLogCountArgs<ExtArgs>
            result: $Utils.Optional<PromptLogCountAggregateOutputType> | number
          }
        }
      }
      ChangeLog: {
        payload: Prisma.$ChangeLogPayload<ExtArgs>
        fields: Prisma.ChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          findFirst: {
            args: Prisma.ChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          findMany: {
            args: Prisma.ChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>[]
          }
          create: {
            args: Prisma.ChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          createMany: {
            args: Prisma.ChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChangeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>[]
          }
          delete: {
            args: Prisma.ChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          update: {
            args: Prisma.ChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.ChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChangeLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>[]
          }
          upsert: {
            args: Prisma.ChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          aggregate: {
            args: Prisma.ChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangeLog>
          }
          groupBy: {
            args: Prisma.ChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<ChangeLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userProfile?: UserProfileOmit
    space?: SpaceOmit
    resource?: ResourceOmit
    resourceVersion?: ResourceVersionOmit
    classification?: ClassificationOmit
    contentSummary?: ContentSummaryOmit
    vectorChunk?: VectorChunkOmit
    contentRelationship?: ContentRelationshipOmit
    knowledgeNode?: KnowledgeNodeOmit
    knowledgeEdge?: KnowledgeEdgeOmit
    searchQuery?: SearchQueryOmit
    learningAnalytic?: LearningAnalyticOmit
    batchJob?: BatchJobOmit
    promptLog?: PromptLogOmit
    changeLog?: ChangeLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    spaces: number
    resources: number
    search_queries: number
    learning_analytics: number
    content_relationships: number
    knowledge_edges_created: number
    batch_jobs: number
    prompt_logs: number
    change_logs: number
    resource_versions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spaces?: boolean | UserCountOutputTypeCountSpacesArgs
    resources?: boolean | UserCountOutputTypeCountResourcesArgs
    search_queries?: boolean | UserCountOutputTypeCountSearch_queriesArgs
    learning_analytics?: boolean | UserCountOutputTypeCountLearning_analyticsArgs
    content_relationships?: boolean | UserCountOutputTypeCountContent_relationshipsArgs
    knowledge_edges_created?: boolean | UserCountOutputTypeCountKnowledge_edges_createdArgs
    batch_jobs?: boolean | UserCountOutputTypeCountBatch_jobsArgs
    prompt_logs?: boolean | UserCountOutputTypeCountPrompt_logsArgs
    change_logs?: boolean | UserCountOutputTypeCountChange_logsArgs
    resource_versions?: boolean | UserCountOutputTypeCountResource_versionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSpacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSearch_queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchQueryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLearning_analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningAnalyticWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContent_relationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentRelationshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKnowledge_edges_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeEdgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBatch_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchJobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrompt_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChange_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResource_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceVersionWhereInput
  }


  /**
   * Count Type SpaceCountOutputType
   */

  export type SpaceCountOutputType = {
    resources: number
  }

  export type SpaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | SpaceCountOutputTypeCountResourcesArgs
  }

  // Custom InputTypes
  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceCountOutputType
     */
    select?: SpaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }


  /**
   * Count Type ResourceCountOutputType
   */

  export type ResourceCountOutputType = {
    contentSummaries: number
    vectorChunks: number
    sourceOfRelationships: number
    targetOfRelationships: number
    learningAnalytics: number
    versions: number
  }

  export type ResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentSummaries?: boolean | ResourceCountOutputTypeCountContentSummariesArgs
    vectorChunks?: boolean | ResourceCountOutputTypeCountVectorChunksArgs
    sourceOfRelationships?: boolean | ResourceCountOutputTypeCountSourceOfRelationshipsArgs
    targetOfRelationships?: boolean | ResourceCountOutputTypeCountTargetOfRelationshipsArgs
    learningAnalytics?: boolean | ResourceCountOutputTypeCountLearningAnalyticsArgs
    versions?: boolean | ResourceCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCountOutputType
     */
    select?: ResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountContentSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentSummaryWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountVectorChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VectorChunkWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountSourceOfRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentRelationshipWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountTargetOfRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentRelationshipWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountLearningAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningAnalyticWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceVersionWhereInput
  }


  /**
   * Count Type ClassificationCountOutputType
   */

  export type ClassificationCountOutputType = {
    children: number
    resources: number
  }

  export type ClassificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ClassificationCountOutputTypeCountChildrenArgs
    resources?: boolean | ClassificationCountOutputTypeCountResourcesArgs
  }

  // Custom InputTypes
  /**
   * ClassificationCountOutputType without action
   */
  export type ClassificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificationCountOutputType
     */
    select?: ClassificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassificationCountOutputType without action
   */
  export type ClassificationCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassificationWhereInput
  }

  /**
   * ClassificationCountOutputType without action
   */
  export type ClassificationCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
  }


  /**
   * Count Type ContentSummaryCountOutputType
   */

  export type ContentSummaryCountOutputType = {
    vectorChunks: number
  }

  export type ContentSummaryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vectorChunks?: boolean | ContentSummaryCountOutputTypeCountVectorChunksArgs
  }

  // Custom InputTypes
  /**
   * ContentSummaryCountOutputType without action
   */
  export type ContentSummaryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummaryCountOutputType
     */
    select?: ContentSummaryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentSummaryCountOutputType without action
   */
  export type ContentSummaryCountOutputTypeCountVectorChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VectorChunkWhereInput
  }


  /**
   * Count Type VectorChunkCountOutputType
   */

  export type VectorChunkCountOutputType = {
    childChunks: number
  }

  export type VectorChunkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childChunks?: boolean | VectorChunkCountOutputTypeCountChildChunksArgs
  }

  // Custom InputTypes
  /**
   * VectorChunkCountOutputType without action
   */
  export type VectorChunkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunkCountOutputType
     */
    select?: VectorChunkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VectorChunkCountOutputType without action
   */
  export type VectorChunkCountOutputTypeCountChildChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VectorChunkWhereInput
  }


  /**
   * Count Type KnowledgeNodeCountOutputType
   */

  export type KnowledgeNodeCountOutputType = {
    sourceKnowledgeEdges: number
    targetKnowledgeEdges: number
  }

  export type KnowledgeNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceKnowledgeEdges?: boolean | KnowledgeNodeCountOutputTypeCountSourceKnowledgeEdgesArgs
    targetKnowledgeEdges?: boolean | KnowledgeNodeCountOutputTypeCountTargetKnowledgeEdgesArgs
  }

  // Custom InputTypes
  /**
   * KnowledgeNodeCountOutputType without action
   */
  export type KnowledgeNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNodeCountOutputType
     */
    select?: KnowledgeNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KnowledgeNodeCountOutputType without action
   */
  export type KnowledgeNodeCountOutputTypeCountSourceKnowledgeEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeEdgeWhereInput
  }

  /**
   * KnowledgeNodeCountOutputType without action
   */
  export type KnowledgeNodeCountOutputTypeCountTargetKnowledgeEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeEdgeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_profile?: boolean | User$user_profileArgs<ExtArgs>
    spaces?: boolean | User$spacesArgs<ExtArgs>
    resources?: boolean | User$resourcesArgs<ExtArgs>
    search_queries?: boolean | User$search_queriesArgs<ExtArgs>
    learning_analytics?: boolean | User$learning_analyticsArgs<ExtArgs>
    content_relationships?: boolean | User$content_relationshipsArgs<ExtArgs>
    knowledge_edges_created?: boolean | User$knowledge_edges_createdArgs<ExtArgs>
    batch_jobs?: boolean | User$batch_jobsArgs<ExtArgs>
    prompt_logs?: boolean | User$prompt_logsArgs<ExtArgs>
    change_logs?: boolean | User$change_logsArgs<ExtArgs>
    resource_versions?: boolean | User$resource_versionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_profile?: boolean | User$user_profileArgs<ExtArgs>
    spaces?: boolean | User$spacesArgs<ExtArgs>
    resources?: boolean | User$resourcesArgs<ExtArgs>
    search_queries?: boolean | User$search_queriesArgs<ExtArgs>
    learning_analytics?: boolean | User$learning_analyticsArgs<ExtArgs>
    content_relationships?: boolean | User$content_relationshipsArgs<ExtArgs>
    knowledge_edges_created?: boolean | User$knowledge_edges_createdArgs<ExtArgs>
    batch_jobs?: boolean | User$batch_jobsArgs<ExtArgs>
    prompt_logs?: boolean | User$prompt_logsArgs<ExtArgs>
    change_logs?: boolean | User$change_logsArgs<ExtArgs>
    resource_versions?: boolean | User$resource_versionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      user_profile: Prisma.$UserProfilePayload<ExtArgs> | null
      spaces: Prisma.$SpacePayload<ExtArgs>[]
      resources: Prisma.$ResourcePayload<ExtArgs>[]
      search_queries: Prisma.$SearchQueryPayload<ExtArgs>[]
      learning_analytics: Prisma.$LearningAnalyticPayload<ExtArgs>[]
      content_relationships: Prisma.$ContentRelationshipPayload<ExtArgs>[]
      knowledge_edges_created: Prisma.$KnowledgeEdgePayload<ExtArgs>[]
      batch_jobs: Prisma.$BatchJobPayload<ExtArgs>[]
      prompt_logs: Prisma.$PromptLogPayload<ExtArgs>[]
      change_logs: Prisma.$ChangeLogPayload<ExtArgs>[]
      resource_versions: Prisma.$ResourceVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_profile<T extends User$user_profileArgs<ExtArgs> = {}>(args?: Subset<T, User$user_profileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    spaces<T extends User$spacesArgs<ExtArgs> = {}>(args?: Subset<T, User$spacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends User$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, User$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    search_queries<T extends User$search_queriesArgs<ExtArgs> = {}>(args?: Subset<T, User$search_queriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learning_analytics<T extends User$learning_analyticsArgs<ExtArgs> = {}>(args?: Subset<T, User$learning_analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    content_relationships<T extends User$content_relationshipsArgs<ExtArgs> = {}>(args?: Subset<T, User$content_relationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    knowledge_edges_created<T extends User$knowledge_edges_createdArgs<ExtArgs> = {}>(args?: Subset<T, User$knowledge_edges_createdArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batch_jobs<T extends User$batch_jobsArgs<ExtArgs> = {}>(args?: Subset<T, User$batch_jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prompt_logs<T extends User$prompt_logsArgs<ExtArgs> = {}>(args?: Subset<T, User$prompt_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    change_logs<T extends User$change_logsArgs<ExtArgs> = {}>(args?: Subset<T, User$change_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resource_versions<T extends User$resource_versionsArgs<ExtArgs> = {}>(args?: Subset<T, User$resource_versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.user_profile
   */
  export type User$user_profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.spaces
   */
  export type User$spacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    cursor?: SpaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * User.resources
   */
  export type User$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * User.search_queries
   */
  export type User$search_queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    where?: SearchQueryWhereInput
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    cursor?: SearchQueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * User.learning_analytics
   */
  export type User$learning_analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    where?: LearningAnalyticWhereInput
    orderBy?: LearningAnalyticOrderByWithRelationInput | LearningAnalyticOrderByWithRelationInput[]
    cursor?: LearningAnalyticWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningAnalyticScalarFieldEnum | LearningAnalyticScalarFieldEnum[]
  }

  /**
   * User.content_relationships
   */
  export type User$content_relationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    where?: ContentRelationshipWhereInput
    orderBy?: ContentRelationshipOrderByWithRelationInput | ContentRelationshipOrderByWithRelationInput[]
    cursor?: ContentRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentRelationshipScalarFieldEnum | ContentRelationshipScalarFieldEnum[]
  }

  /**
   * User.knowledge_edges_created
   */
  export type User$knowledge_edges_createdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    where?: KnowledgeEdgeWhereInput
    orderBy?: KnowledgeEdgeOrderByWithRelationInput | KnowledgeEdgeOrderByWithRelationInput[]
    cursor?: KnowledgeEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeEdgeScalarFieldEnum | KnowledgeEdgeScalarFieldEnum[]
  }

  /**
   * User.batch_jobs
   */
  export type User$batch_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
    where?: BatchJobWhereInput
    orderBy?: BatchJobOrderByWithRelationInput | BatchJobOrderByWithRelationInput[]
    cursor?: BatchJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchJobScalarFieldEnum | BatchJobScalarFieldEnum[]
  }

  /**
   * User.prompt_logs
   */
  export type User$prompt_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
    where?: PromptLogWhereInput
    orderBy?: PromptLogOrderByWithRelationInput | PromptLogOrderByWithRelationInput[]
    cursor?: PromptLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptLogScalarFieldEnum | PromptLogScalarFieldEnum[]
  }

  /**
   * User.change_logs
   */
  export type User$change_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    where?: ChangeLogWhereInput
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    cursor?: ChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }

  /**
   * User.resource_versions
   */
  export type User$resource_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    where?: ResourceVersionWhereInput
    orderBy?: ResourceVersionOrderByWithRelationInput | ResourceVersionOrderByWithRelationInput[]
    cursor?: ResourceVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceVersionScalarFieldEnum | ResourceVersionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    totalProcessedContent: number | null
    totalEmbeddings: number | null
    monthlyQuotaUsed: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    totalProcessedContent: number | null
    totalEmbeddings: number | null
    monthlyQuotaUsed: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    avatarUrl: string | null
    totalProcessedContent: number | null
    totalEmbeddings: number | null
    monthlyQuotaUsed: number | null
    lastActiveDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    avatarUrl: string | null
    totalProcessedContent: number | null
    totalEmbeddings: number | null
    monthlyQuotaUsed: number | null
    lastActiveDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    email: number
    fullName: number
    avatarUrl: number
    preferences: number
    totalProcessedContent: number
    totalEmbeddings: number
    monthlyQuotaUsed: number
    lastActiveDate: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    totalProcessedContent?: true
    totalEmbeddings?: true
    monthlyQuotaUsed?: true
  }

  export type UserProfileSumAggregateInputType = {
    totalProcessedContent?: true
    totalEmbeddings?: true
    monthlyQuotaUsed?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    avatarUrl?: true
    totalProcessedContent?: true
    totalEmbeddings?: true
    monthlyQuotaUsed?: true
    lastActiveDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    avatarUrl?: true
    totalProcessedContent?: true
    totalEmbeddings?: true
    monthlyQuotaUsed?: true
    lastActiveDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    avatarUrl?: true
    preferences?: true
    totalProcessedContent?: true
    totalEmbeddings?: true
    monthlyQuotaUsed?: true
    lastActiveDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    email: string
    fullName: string | null
    avatarUrl: string | null
    preferences: JsonValue
    totalProcessedContent: number
    totalEmbeddings: number
    monthlyQuotaUsed: number
    lastActiveDate: Date
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    totalProcessedContent?: boolean
    totalEmbeddings?: boolean
    monthlyQuotaUsed?: boolean
    lastActiveDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    totalProcessedContent?: boolean
    totalEmbeddings?: boolean
    monthlyQuotaUsed?: boolean
    lastActiveDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    totalProcessedContent?: boolean
    totalEmbeddings?: boolean
    monthlyQuotaUsed?: boolean
    lastActiveDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    email?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    preferences?: boolean
    totalProcessedContent?: boolean
    totalEmbeddings?: boolean
    monthlyQuotaUsed?: boolean
    lastActiveDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "fullName" | "avatarUrl" | "preferences" | "totalProcessedContent" | "totalEmbeddings" | "monthlyQuotaUsed" | "lastActiveDate" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      fullName: string | null
      avatarUrl: string | null
      preferences: Prisma.JsonValue
      totalProcessedContent: number
      totalEmbeddings: number
      monthlyQuotaUsed: number
      lastActiveDate: Date
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly email: FieldRef<"UserProfile", 'String'>
    readonly fullName: FieldRef<"UserProfile", 'String'>
    readonly avatarUrl: FieldRef<"UserProfile", 'String'>
    readonly preferences: FieldRef<"UserProfile", 'Json'>
    readonly totalProcessedContent: FieldRef<"UserProfile", 'Int'>
    readonly totalEmbeddings: FieldRef<"UserProfile", 'Int'>
    readonly monthlyQuotaUsed: FieldRef<"UserProfile", 'Int'>
    readonly lastActiveDate: FieldRef<"UserProfile", 'DateTime'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
    readonly deletedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model Space
   */

  export type AggregateSpace = {
    _count: SpaceCountAggregateOutputType | null
    _avg: SpaceAvgAggregateOutputType | null
    _sum: SpaceSumAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  export type SpaceAvgAggregateOutputType = {
    contentCount: number | null
  }

  export type SpaceSumAggregateOutputType = {
    contentCount: number | null
  }

  export type SpaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    domain: $Enums.ContentDomain | null
    isDefault: boolean | null
    contentCount: number | null
    lastAccessed: Date | null
    pineconeNamespace: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SpaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    domain: $Enums.ContentDomain | null
    isDefault: boolean | null
    contentCount: number | null
    lastAccessed: Date | null
    pineconeNamespace: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SpaceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    color: number
    domain: number
    isDefault: number
    contentCount: number
    lastAccessed: number
    pineconeNamespace: number
    userId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SpaceAvgAggregateInputType = {
    contentCount?: true
  }

  export type SpaceSumAggregateInputType = {
    contentCount?: true
  }

  export type SpaceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    domain?: true
    isDefault?: true
    contentCount?: true
    lastAccessed?: true
    pineconeNamespace?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SpaceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    domain?: true
    isDefault?: true
    contentCount?: true
    lastAccessed?: true
    pineconeNamespace?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SpaceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    domain?: true
    isDefault?: true
    contentCount?: true
    lastAccessed?: true
    pineconeNamespace?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SpaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Space to aggregate.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spaces
    **/
    _count?: true | SpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceMaxAggregateInputType
  }

  export type GetSpaceAggregateType<T extends SpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpace[P]>
      : GetScalarType<T[P], AggregateSpace[P]>
  }




  export type SpaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceWhereInput
    orderBy?: SpaceOrderByWithAggregationInput | SpaceOrderByWithAggregationInput[]
    by: SpaceScalarFieldEnum[] | SpaceScalarFieldEnum
    having?: SpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceCountAggregateInputType | true
    _avg?: SpaceAvgAggregateInputType
    _sum?: SpaceSumAggregateInputType
    _min?: SpaceMinAggregateInputType
    _max?: SpaceMaxAggregateInputType
  }

  export type SpaceGroupByOutputType = {
    id: string
    name: string
    description: string | null
    color: string
    domain: $Enums.ContentDomain
    isDefault: boolean
    contentCount: number
    lastAccessed: Date
    pineconeNamespace: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SpaceCountAggregateOutputType | null
    _avg: SpaceAvgAggregateOutputType | null
    _sum: SpaceSumAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  type GetSpaceGroupByPayload<T extends SpaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceGroupByOutputType[P]>
        }
      >
    >


  export type SpaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    domain?: boolean
    isDefault?: boolean
    contentCount?: boolean
    lastAccessed?: boolean
    pineconeNamespace?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resources?: boolean | Space$resourcesArgs<ExtArgs>
    _count?: boolean | SpaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    domain?: boolean
    isDefault?: boolean
    contentCount?: boolean
    lastAccessed?: boolean
    pineconeNamespace?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    domain?: boolean
    isDefault?: boolean
    contentCount?: boolean
    lastAccessed?: boolean
    pineconeNamespace?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    domain?: boolean
    isDefault?: boolean
    contentCount?: boolean
    lastAccessed?: boolean
    pineconeNamespace?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type SpaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "color" | "domain" | "isDefault" | "contentCount" | "lastAccessed" | "pineconeNamespace" | "userId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["space"]>
  export type SpaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resources?: boolean | Space$resourcesArgs<ExtArgs>
    _count?: boolean | SpaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SpaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SpacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Space"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resources: Prisma.$ResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      color: string
      domain: $Enums.ContentDomain
      isDefault: boolean
      contentCount: number
      lastAccessed: Date
      pineconeNamespace: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["space"]>
    composites: {}
  }

  type SpaceGetPayload<S extends boolean | null | undefined | SpaceDefaultArgs> = $Result.GetResult<Prisma.$SpacePayload, S>

  type SpaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpaceCountAggregateInputType | true
    }

  export interface SpaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Space'], meta: { name: 'Space' } }
    /**
     * Find zero or one Space that matches the filter.
     * @param {SpaceFindUniqueArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaceFindUniqueArgs>(args: SelectSubset<T, SpaceFindUniqueArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Space that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpaceFindUniqueOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaceFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Space that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaceFindFirstArgs>(args?: SelectSubset<T, SpaceFindFirstArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Space that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaceFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Spaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spaces
     * const spaces = await prisma.space.findMany()
     * 
     * // Get first 10 Spaces
     * const spaces = await prisma.space.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceWithIdOnly = await prisma.space.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaceFindManyArgs>(args?: SelectSubset<T, SpaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Space.
     * @param {SpaceCreateArgs} args - Arguments to create a Space.
     * @example
     * // Create one Space
     * const Space = await prisma.space.create({
     *   data: {
     *     // ... data to create a Space
     *   }
     * })
     * 
     */
    create<T extends SpaceCreateArgs>(args: SelectSubset<T, SpaceCreateArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Spaces.
     * @param {SpaceCreateManyArgs} args - Arguments to create many Spaces.
     * @example
     * // Create many Spaces
     * const space = await prisma.space.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaceCreateManyArgs>(args?: SelectSubset<T, SpaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spaces and returns the data saved in the database.
     * @param {SpaceCreateManyAndReturnArgs} args - Arguments to create many Spaces.
     * @example
     * // Create many Spaces
     * const space = await prisma.space.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spaces and only return the `id`
     * const spaceWithIdOnly = await prisma.space.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpaceCreateManyAndReturnArgs>(args?: SelectSubset<T, SpaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Space.
     * @param {SpaceDeleteArgs} args - Arguments to delete one Space.
     * @example
     * // Delete one Space
     * const Space = await prisma.space.delete({
     *   where: {
     *     // ... filter to delete one Space
     *   }
     * })
     * 
     */
    delete<T extends SpaceDeleteArgs>(args: SelectSubset<T, SpaceDeleteArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Space.
     * @param {SpaceUpdateArgs} args - Arguments to update one Space.
     * @example
     * // Update one Space
     * const space = await prisma.space.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaceUpdateArgs>(args: SelectSubset<T, SpaceUpdateArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Spaces.
     * @param {SpaceDeleteManyArgs} args - Arguments to filter Spaces to delete.
     * @example
     * // Delete a few Spaces
     * const { count } = await prisma.space.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaceDeleteManyArgs>(args?: SelectSubset<T, SpaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spaces
     * const space = await prisma.space.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaceUpdateManyArgs>(args: SelectSubset<T, SpaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spaces and returns the data updated in the database.
     * @param {SpaceUpdateManyAndReturnArgs} args - Arguments to update many Spaces.
     * @example
     * // Update many Spaces
     * const space = await prisma.space.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Spaces and only return the `id`
     * const spaceWithIdOnly = await prisma.space.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpaceUpdateManyAndReturnArgs>(args: SelectSubset<T, SpaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Space.
     * @param {SpaceUpsertArgs} args - Arguments to update or create a Space.
     * @example
     * // Update or create a Space
     * const space = await prisma.space.upsert({
     *   create: {
     *     // ... data to create a Space
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Space we want to update
     *   }
     * })
     */
    upsert<T extends SpaceUpsertArgs>(args: SelectSubset<T, SpaceUpsertArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceCountArgs} args - Arguments to filter Spaces to count.
     * @example
     * // Count the number of Spaces
     * const count = await prisma.space.count({
     *   where: {
     *     // ... the filter for the Spaces we want to count
     *   }
     * })
    **/
    count<T extends SpaceCountArgs>(
      args?: Subset<T, SpaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceAggregateArgs>(args: Subset<T, SpaceAggregateArgs>): Prisma.PrismaPromise<GetSpaceAggregateType<T>>

    /**
     * Group by Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceGroupByArgs['orderBy'] }
        : { orderBy?: SpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Space model
   */
  readonly fields: SpaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Space.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resources<T extends Space$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Space$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Space model
   */
  interface SpaceFieldRefs {
    readonly id: FieldRef<"Space", 'String'>
    readonly name: FieldRef<"Space", 'String'>
    readonly description: FieldRef<"Space", 'String'>
    readonly color: FieldRef<"Space", 'String'>
    readonly domain: FieldRef<"Space", 'ContentDomain'>
    readonly isDefault: FieldRef<"Space", 'Boolean'>
    readonly contentCount: FieldRef<"Space", 'Int'>
    readonly lastAccessed: FieldRef<"Space", 'DateTime'>
    readonly pineconeNamespace: FieldRef<"Space", 'String'>
    readonly userId: FieldRef<"Space", 'String'>
    readonly createdAt: FieldRef<"Space", 'DateTime'>
    readonly updatedAt: FieldRef<"Space", 'DateTime'>
    readonly deletedAt: FieldRef<"Space", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Space findUnique
   */
  export type SpaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findUniqueOrThrow
   */
  export type SpaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findFirst
   */
  export type SpaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space findFirstOrThrow
   */
  export type SpaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space findMany
   */
  export type SpaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Spaces to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space create
   */
  export type SpaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Space.
     */
    data: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
  }

  /**
   * Space createMany
   */
  export type SpaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spaces.
     */
    data: SpaceCreateManyInput | SpaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Space createManyAndReturn
   */
  export type SpaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * The data used to create many Spaces.
     */
    data: SpaceCreateManyInput | SpaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Space update
   */
  export type SpaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Space.
     */
    data: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
    /**
     * Choose, which Space to update.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space updateMany
   */
  export type SpaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spaces.
     */
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyInput>
    /**
     * Filter which Spaces to update
     */
    where?: SpaceWhereInput
    /**
     * Limit how many Spaces to update.
     */
    limit?: number
  }

  /**
   * Space updateManyAndReturn
   */
  export type SpaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * The data used to update Spaces.
     */
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyInput>
    /**
     * Filter which Spaces to update
     */
    where?: SpaceWhereInput
    /**
     * Limit how many Spaces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Space upsert
   */
  export type SpaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Space to update in case it exists.
     */
    where: SpaceWhereUniqueInput
    /**
     * In case the Space found by the `where` argument doesn't exist, create a new Space with this data.
     */
    create: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
    /**
     * In case the Space was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
  }

  /**
   * Space delete
   */
  export type SpaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter which Space to delete.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space deleteMany
   */
  export type SpaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spaces to delete
     */
    where?: SpaceWhereInput
    /**
     * Limit how many Spaces to delete.
     */
    limit?: number
  }

  /**
   * Space.resources
   */
  export type Space$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Space without action
   */
  export type SpaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    estimatedReadTimeMinutes: number | null
    wordCount: number | null
    noveltyScore: number | null
  }

  export type ResourceSumAggregateOutputType = {
    estimatedReadTimeMinutes: number | null
    wordCount: number | null
    noveltyScore: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    type: $Enums.ResourceType | null
    content: string | null
    domain: $Enums.ContentDomain | null
    language: string | null
    complexityLevel: $Enums.ComplexityLevel | null
    estimatedReadTimeMinutes: number | null
    wordCount: number | null
    processingStatus: $Enums.ProcessingStatus | null
    processedAt: Date | null
    actionDensity: $Enums.ActionDensity | null
    noveltyScore: number | null
    practicalApplicability: $Enums.PracticalApplicability | null
    userId: string | null
    spaceId: string | null
    classificationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    type: $Enums.ResourceType | null
    content: string | null
    domain: $Enums.ContentDomain | null
    language: string | null
    complexityLevel: $Enums.ComplexityLevel | null
    estimatedReadTimeMinutes: number | null
    wordCount: number | null
    processingStatus: $Enums.ProcessingStatus | null
    processedAt: Date | null
    actionDensity: $Enums.ActionDensity | null
    noveltyScore: number | null
    practicalApplicability: $Enums.PracticalApplicability | null
    userId: string | null
    spaceId: string | null
    classificationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    url: number
    type: number
    content: number
    tags: number
    domain: number
    language: number
    metadata: number
    complexityLevel: number
    estimatedReadTimeMinutes: number
    wordCount: number
    processingStatus: number
    processedAt: number
    actionDensity: number
    noveltyScore: number
    practicalApplicability: number
    userId: number
    spaceId: number
    classificationId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    estimatedReadTimeMinutes?: true
    wordCount?: true
    noveltyScore?: true
  }

  export type ResourceSumAggregateInputType = {
    estimatedReadTimeMinutes?: true
    wordCount?: true
    noveltyScore?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    type?: true
    content?: true
    domain?: true
    language?: true
    complexityLevel?: true
    estimatedReadTimeMinutes?: true
    wordCount?: true
    processingStatus?: true
    processedAt?: true
    actionDensity?: true
    noveltyScore?: true
    practicalApplicability?: true
    userId?: true
    spaceId?: true
    classificationId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    type?: true
    content?: true
    domain?: true
    language?: true
    complexityLevel?: true
    estimatedReadTimeMinutes?: true
    wordCount?: true
    processingStatus?: true
    processedAt?: true
    actionDensity?: true
    noveltyScore?: true
    practicalApplicability?: true
    userId?: true
    spaceId?: true
    classificationId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    type?: true
    content?: true
    tags?: true
    domain?: true
    language?: true
    metadata?: true
    complexityLevel?: true
    estimatedReadTimeMinutes?: true
    wordCount?: true
    processingStatus?: true
    processedAt?: true
    actionDensity?: true
    noveltyScore?: true
    practicalApplicability?: true
    userId?: true
    spaceId?: true
    classificationId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: string
    title: string
    description: string | null
    url: string | null
    type: $Enums.ResourceType
    content: string | null
    tags: string[]
    domain: $Enums.ContentDomain
    language: string
    metadata: JsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes: number | null
    wordCount: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt: Date | null
    actionDensity: $Enums.ActionDensity
    noveltyScore: number | null
    practicalApplicability: $Enums.PracticalApplicability | null
    userId: string
    spaceId: string | null
    classificationId: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    content?: boolean
    tags?: boolean
    domain?: boolean
    language?: boolean
    metadata?: boolean
    complexityLevel?: boolean
    estimatedReadTimeMinutes?: boolean
    wordCount?: boolean
    processingStatus?: boolean
    processedAt?: boolean
    actionDensity?: boolean
    noveltyScore?: boolean
    practicalApplicability?: boolean
    userId?: boolean
    spaceId?: boolean
    classificationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    space?: boolean | Resource$spaceArgs<ExtArgs>
    classification?: boolean | Resource$classificationArgs<ExtArgs>
    contentSummaries?: boolean | Resource$contentSummariesArgs<ExtArgs>
    vectorChunks?: boolean | Resource$vectorChunksArgs<ExtArgs>
    sourceOfRelationships?: boolean | Resource$sourceOfRelationshipsArgs<ExtArgs>
    targetOfRelationships?: boolean | Resource$targetOfRelationshipsArgs<ExtArgs>
    learningAnalytics?: boolean | Resource$learningAnalyticsArgs<ExtArgs>
    versions?: boolean | Resource$versionsArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    content?: boolean
    tags?: boolean
    domain?: boolean
    language?: boolean
    metadata?: boolean
    complexityLevel?: boolean
    estimatedReadTimeMinutes?: boolean
    wordCount?: boolean
    processingStatus?: boolean
    processedAt?: boolean
    actionDensity?: boolean
    noveltyScore?: boolean
    practicalApplicability?: boolean
    userId?: boolean
    spaceId?: boolean
    classificationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    space?: boolean | Resource$spaceArgs<ExtArgs>
    classification?: boolean | Resource$classificationArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    content?: boolean
    tags?: boolean
    domain?: boolean
    language?: boolean
    metadata?: boolean
    complexityLevel?: boolean
    estimatedReadTimeMinutes?: boolean
    wordCount?: boolean
    processingStatus?: boolean
    processedAt?: boolean
    actionDensity?: boolean
    noveltyScore?: boolean
    practicalApplicability?: boolean
    userId?: boolean
    spaceId?: boolean
    classificationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    space?: boolean | Resource$spaceArgs<ExtArgs>
    classification?: boolean | Resource$classificationArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    content?: boolean
    tags?: boolean
    domain?: boolean
    language?: boolean
    metadata?: boolean
    complexityLevel?: boolean
    estimatedReadTimeMinutes?: boolean
    wordCount?: boolean
    processingStatus?: boolean
    processedAt?: boolean
    actionDensity?: boolean
    noveltyScore?: boolean
    practicalApplicability?: boolean
    userId?: boolean
    spaceId?: boolean
    classificationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "url" | "type" | "content" | "tags" | "domain" | "language" | "metadata" | "complexityLevel" | "estimatedReadTimeMinutes" | "wordCount" | "processingStatus" | "processedAt" | "actionDensity" | "noveltyScore" | "practicalApplicability" | "userId" | "spaceId" | "classificationId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["resource"]>
  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    space?: boolean | Resource$spaceArgs<ExtArgs>
    classification?: boolean | Resource$classificationArgs<ExtArgs>
    contentSummaries?: boolean | Resource$contentSummariesArgs<ExtArgs>
    vectorChunks?: boolean | Resource$vectorChunksArgs<ExtArgs>
    sourceOfRelationships?: boolean | Resource$sourceOfRelationshipsArgs<ExtArgs>
    targetOfRelationships?: boolean | Resource$targetOfRelationshipsArgs<ExtArgs>
    learningAnalytics?: boolean | Resource$learningAnalyticsArgs<ExtArgs>
    versions?: boolean | Resource$versionsArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    space?: boolean | Resource$spaceArgs<ExtArgs>
    classification?: boolean | Resource$classificationArgs<ExtArgs>
  }
  export type ResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    space?: boolean | Resource$spaceArgs<ExtArgs>
    classification?: boolean | Resource$classificationArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      space: Prisma.$SpacePayload<ExtArgs> | null
      classification: Prisma.$ClassificationPayload<ExtArgs> | null
      contentSummaries: Prisma.$ContentSummaryPayload<ExtArgs>[]
      vectorChunks: Prisma.$VectorChunkPayload<ExtArgs>[]
      sourceOfRelationships: Prisma.$ContentRelationshipPayload<ExtArgs>[]
      targetOfRelationships: Prisma.$ContentRelationshipPayload<ExtArgs>[]
      learningAnalytics: Prisma.$LearningAnalyticPayload<ExtArgs>[]
      versions: Prisma.$ResourceVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      url: string | null
      type: $Enums.ResourceType
      content: string | null
      tags: string[]
      domain: $Enums.ContentDomain
      language: string
      metadata: Prisma.JsonValue
      complexityLevel: $Enums.ComplexityLevel
      estimatedReadTimeMinutes: number | null
      wordCount: number | null
      processingStatus: $Enums.ProcessingStatus
      processedAt: Date | null
      actionDensity: $Enums.ActionDensity
      noveltyScore: number | null
      practicalApplicability: $Enums.PracticalApplicability | null
      userId: string
      spaceId: string | null
      classificationId: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {ResourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    space<T extends Resource$spaceArgs<ExtArgs> = {}>(args?: Subset<T, Resource$spaceArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    classification<T extends Resource$classificationArgs<ExtArgs> = {}>(args?: Subset<T, Resource$classificationArgs<ExtArgs>>): Prisma__ClassificationClient<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contentSummaries<T extends Resource$contentSummariesArgs<ExtArgs> = {}>(args?: Subset<T, Resource$contentSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vectorChunks<T extends Resource$vectorChunksArgs<ExtArgs> = {}>(args?: Subset<T, Resource$vectorChunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourceOfRelationships<T extends Resource$sourceOfRelationshipsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$sourceOfRelationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    targetOfRelationships<T extends Resource$targetOfRelationshipsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$targetOfRelationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningAnalytics<T extends Resource$learningAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$learningAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    versions<T extends Resource$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'String'>
    readonly title: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly url: FieldRef<"Resource", 'String'>
    readonly type: FieldRef<"Resource", 'ResourceType'>
    readonly content: FieldRef<"Resource", 'String'>
    readonly tags: FieldRef<"Resource", 'String[]'>
    readonly domain: FieldRef<"Resource", 'ContentDomain'>
    readonly language: FieldRef<"Resource", 'String'>
    readonly metadata: FieldRef<"Resource", 'Json'>
    readonly complexityLevel: FieldRef<"Resource", 'ComplexityLevel'>
    readonly estimatedReadTimeMinutes: FieldRef<"Resource", 'Int'>
    readonly wordCount: FieldRef<"Resource", 'Int'>
    readonly processingStatus: FieldRef<"Resource", 'ProcessingStatus'>
    readonly processedAt: FieldRef<"Resource", 'DateTime'>
    readonly actionDensity: FieldRef<"Resource", 'ActionDensity'>
    readonly noveltyScore: FieldRef<"Resource", 'Int'>
    readonly practicalApplicability: FieldRef<"Resource", 'PracticalApplicability'>
    readonly userId: FieldRef<"Resource", 'String'>
    readonly spaceId: FieldRef<"Resource", 'String'>
    readonly classificationId: FieldRef<"Resource", 'String'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly updatedAt: FieldRef<"Resource", 'DateTime'>
    readonly deletedAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource updateManyAndReturn
   */
  export type ResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resource.space
   */
  export type Resource$spaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Space
     */
    omit?: SpaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
  }

  /**
   * Resource.classification
   */
  export type Resource$classificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    where?: ClassificationWhereInput
  }

  /**
   * Resource.contentSummaries
   */
  export type Resource$contentSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
    where?: ContentSummaryWhereInput
    orderBy?: ContentSummaryOrderByWithRelationInput | ContentSummaryOrderByWithRelationInput[]
    cursor?: ContentSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentSummaryScalarFieldEnum | ContentSummaryScalarFieldEnum[]
  }

  /**
   * Resource.vectorChunks
   */
  export type Resource$vectorChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    where?: VectorChunkWhereInput
    orderBy?: VectorChunkOrderByWithRelationInput | VectorChunkOrderByWithRelationInput[]
    cursor?: VectorChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VectorChunkScalarFieldEnum | VectorChunkScalarFieldEnum[]
  }

  /**
   * Resource.sourceOfRelationships
   */
  export type Resource$sourceOfRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    where?: ContentRelationshipWhereInput
    orderBy?: ContentRelationshipOrderByWithRelationInput | ContentRelationshipOrderByWithRelationInput[]
    cursor?: ContentRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentRelationshipScalarFieldEnum | ContentRelationshipScalarFieldEnum[]
  }

  /**
   * Resource.targetOfRelationships
   */
  export type Resource$targetOfRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    where?: ContentRelationshipWhereInput
    orderBy?: ContentRelationshipOrderByWithRelationInput | ContentRelationshipOrderByWithRelationInput[]
    cursor?: ContentRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentRelationshipScalarFieldEnum | ContentRelationshipScalarFieldEnum[]
  }

  /**
   * Resource.learningAnalytics
   */
  export type Resource$learningAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    where?: LearningAnalyticWhereInput
    orderBy?: LearningAnalyticOrderByWithRelationInput | LearningAnalyticOrderByWithRelationInput[]
    cursor?: LearningAnalyticWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningAnalyticScalarFieldEnum | LearningAnalyticScalarFieldEnum[]
  }

  /**
   * Resource.versions
   */
  export type Resource$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    where?: ResourceVersionWhereInput
    orderBy?: ResourceVersionOrderByWithRelationInput | ResourceVersionOrderByWithRelationInput[]
    cursor?: ResourceVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceVersionScalarFieldEnum | ResourceVersionScalarFieldEnum[]
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model ResourceVersion
   */

  export type AggregateResourceVersion = {
    _count: ResourceVersionCountAggregateOutputType | null
    _avg: ResourceVersionAvgAggregateOutputType | null
    _sum: ResourceVersionSumAggregateOutputType | null
    _min: ResourceVersionMinAggregateOutputType | null
    _max: ResourceVersionMaxAggregateOutputType | null
  }

  export type ResourceVersionAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type ResourceVersionSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type ResourceVersionMinAggregateOutputType = {
    id: string | null
    versionNumber: number | null
    title: string | null
    content: string | null
    resourceId: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type ResourceVersionMaxAggregateOutputType = {
    id: string | null
    versionNumber: number | null
    title: string | null
    content: string | null
    resourceId: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type ResourceVersionCountAggregateOutputType = {
    id: number
    versionNumber: number
    title: number
    content: number
    tags: number
    metadata: number
    resourceId: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type ResourceVersionAvgAggregateInputType = {
    versionNumber?: true
  }

  export type ResourceVersionSumAggregateInputType = {
    versionNumber?: true
  }

  export type ResourceVersionMinAggregateInputType = {
    id?: true
    versionNumber?: true
    title?: true
    content?: true
    resourceId?: true
    createdBy?: true
    createdAt?: true
  }

  export type ResourceVersionMaxAggregateInputType = {
    id?: true
    versionNumber?: true
    title?: true
    content?: true
    resourceId?: true
    createdBy?: true
    createdAt?: true
  }

  export type ResourceVersionCountAggregateInputType = {
    id?: true
    versionNumber?: true
    title?: true
    content?: true
    tags?: true
    metadata?: true
    resourceId?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type ResourceVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceVersion to aggregate.
     */
    where?: ResourceVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceVersions to fetch.
     */
    orderBy?: ResourceVersionOrderByWithRelationInput | ResourceVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResourceVersions
    **/
    _count?: true | ResourceVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceVersionMaxAggregateInputType
  }

  export type GetResourceVersionAggregateType<T extends ResourceVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceVersion[P]>
      : GetScalarType<T[P], AggregateResourceVersion[P]>
  }




  export type ResourceVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceVersionWhereInput
    orderBy?: ResourceVersionOrderByWithAggregationInput | ResourceVersionOrderByWithAggregationInput[]
    by: ResourceVersionScalarFieldEnum[] | ResourceVersionScalarFieldEnum
    having?: ResourceVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceVersionCountAggregateInputType | true
    _avg?: ResourceVersionAvgAggregateInputType
    _sum?: ResourceVersionSumAggregateInputType
    _min?: ResourceVersionMinAggregateInputType
    _max?: ResourceVersionMaxAggregateInputType
  }

  export type ResourceVersionGroupByOutputType = {
    id: string
    versionNumber: number
    title: string
    content: string | null
    tags: string[]
    metadata: JsonValue
    resourceId: string
    createdBy: string | null
    createdAt: Date
    _count: ResourceVersionCountAggregateOutputType | null
    _avg: ResourceVersionAvgAggregateOutputType | null
    _sum: ResourceVersionSumAggregateOutputType | null
    _min: ResourceVersionMinAggregateOutputType | null
    _max: ResourceVersionMaxAggregateOutputType | null
  }

  type GetResourceVersionGroupByPayload<T extends ResourceVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceVersionGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceVersionGroupByOutputType[P]>
        }
      >
    >


  export type ResourceVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionNumber?: boolean
    title?: boolean
    content?: boolean
    tags?: boolean
    metadata?: boolean
    resourceId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ResourceVersion$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["resourceVersion"]>

  export type ResourceVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionNumber?: boolean
    title?: boolean
    content?: boolean
    tags?: boolean
    metadata?: boolean
    resourceId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ResourceVersion$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["resourceVersion"]>

  export type ResourceVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionNumber?: boolean
    title?: boolean
    content?: boolean
    tags?: boolean
    metadata?: boolean
    resourceId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ResourceVersion$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["resourceVersion"]>

  export type ResourceVersionSelectScalar = {
    id?: boolean
    versionNumber?: boolean
    title?: boolean
    content?: boolean
    tags?: boolean
    metadata?: boolean
    resourceId?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type ResourceVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "versionNumber" | "title" | "content" | "tags" | "metadata" | "resourceId" | "createdBy" | "createdAt", ExtArgs["result"]["resourceVersion"]>
  export type ResourceVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ResourceVersion$creatorArgs<ExtArgs>
  }
  export type ResourceVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ResourceVersion$creatorArgs<ExtArgs>
  }
  export type ResourceVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ResourceVersion$creatorArgs<ExtArgs>
  }

  export type $ResourceVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResourceVersion"
    objects: {
      resource: Prisma.$ResourcePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      versionNumber: number
      title: string
      content: string | null
      tags: string[]
      metadata: Prisma.JsonValue
      resourceId: string
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["resourceVersion"]>
    composites: {}
  }

  type ResourceVersionGetPayload<S extends boolean | null | undefined | ResourceVersionDefaultArgs> = $Result.GetResult<Prisma.$ResourceVersionPayload, S>

  type ResourceVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceVersionCountAggregateInputType | true
    }

  export interface ResourceVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResourceVersion'], meta: { name: 'ResourceVersion' } }
    /**
     * Find zero or one ResourceVersion that matches the filter.
     * @param {ResourceVersionFindUniqueArgs} args - Arguments to find a ResourceVersion
     * @example
     * // Get one ResourceVersion
     * const resourceVersion = await prisma.resourceVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceVersionFindUniqueArgs>(args: SelectSubset<T, ResourceVersionFindUniqueArgs<ExtArgs>>): Prisma__ResourceVersionClient<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResourceVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceVersionFindUniqueOrThrowArgs} args - Arguments to find a ResourceVersion
     * @example
     * // Get one ResourceVersion
     * const resourceVersion = await prisma.resourceVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceVersionClient<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceVersionFindFirstArgs} args - Arguments to find a ResourceVersion
     * @example
     * // Get one ResourceVersion
     * const resourceVersion = await prisma.resourceVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceVersionFindFirstArgs>(args?: SelectSubset<T, ResourceVersionFindFirstArgs<ExtArgs>>): Prisma__ResourceVersionClient<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceVersionFindFirstOrThrowArgs} args - Arguments to find a ResourceVersion
     * @example
     * // Get one ResourceVersion
     * const resourceVersion = await prisma.resourceVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceVersionClient<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResourceVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceVersions
     * const resourceVersions = await prisma.resourceVersion.findMany()
     * 
     * // Get first 10 ResourceVersions
     * const resourceVersions = await prisma.resourceVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceVersionWithIdOnly = await prisma.resourceVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceVersionFindManyArgs>(args?: SelectSubset<T, ResourceVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResourceVersion.
     * @param {ResourceVersionCreateArgs} args - Arguments to create a ResourceVersion.
     * @example
     * // Create one ResourceVersion
     * const ResourceVersion = await prisma.resourceVersion.create({
     *   data: {
     *     // ... data to create a ResourceVersion
     *   }
     * })
     * 
     */
    create<T extends ResourceVersionCreateArgs>(args: SelectSubset<T, ResourceVersionCreateArgs<ExtArgs>>): Prisma__ResourceVersionClient<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResourceVersions.
     * @param {ResourceVersionCreateManyArgs} args - Arguments to create many ResourceVersions.
     * @example
     * // Create many ResourceVersions
     * const resourceVersion = await prisma.resourceVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceVersionCreateManyArgs>(args?: SelectSubset<T, ResourceVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResourceVersions and returns the data saved in the database.
     * @param {ResourceVersionCreateManyAndReturnArgs} args - Arguments to create many ResourceVersions.
     * @example
     * // Create many ResourceVersions
     * const resourceVersion = await prisma.resourceVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResourceVersions and only return the `id`
     * const resourceVersionWithIdOnly = await prisma.resourceVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResourceVersion.
     * @param {ResourceVersionDeleteArgs} args - Arguments to delete one ResourceVersion.
     * @example
     * // Delete one ResourceVersion
     * const ResourceVersion = await prisma.resourceVersion.delete({
     *   where: {
     *     // ... filter to delete one ResourceVersion
     *   }
     * })
     * 
     */
    delete<T extends ResourceVersionDeleteArgs>(args: SelectSubset<T, ResourceVersionDeleteArgs<ExtArgs>>): Prisma__ResourceVersionClient<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResourceVersion.
     * @param {ResourceVersionUpdateArgs} args - Arguments to update one ResourceVersion.
     * @example
     * // Update one ResourceVersion
     * const resourceVersion = await prisma.resourceVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceVersionUpdateArgs>(args: SelectSubset<T, ResourceVersionUpdateArgs<ExtArgs>>): Prisma__ResourceVersionClient<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResourceVersions.
     * @param {ResourceVersionDeleteManyArgs} args - Arguments to filter ResourceVersions to delete.
     * @example
     * // Delete a few ResourceVersions
     * const { count } = await prisma.resourceVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceVersionDeleteManyArgs>(args?: SelectSubset<T, ResourceVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceVersions
     * const resourceVersion = await prisma.resourceVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceVersionUpdateManyArgs>(args: SelectSubset<T, ResourceVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceVersions and returns the data updated in the database.
     * @param {ResourceVersionUpdateManyAndReturnArgs} args - Arguments to update many ResourceVersions.
     * @example
     * // Update many ResourceVersions
     * const resourceVersion = await prisma.resourceVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResourceVersions and only return the `id`
     * const resourceVersionWithIdOnly = await prisma.resourceVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResourceVersion.
     * @param {ResourceVersionUpsertArgs} args - Arguments to update or create a ResourceVersion.
     * @example
     * // Update or create a ResourceVersion
     * const resourceVersion = await prisma.resourceVersion.upsert({
     *   create: {
     *     // ... data to create a ResourceVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceVersion we want to update
     *   }
     * })
     */
    upsert<T extends ResourceVersionUpsertArgs>(args: SelectSubset<T, ResourceVersionUpsertArgs<ExtArgs>>): Prisma__ResourceVersionClient<$Result.GetResult<Prisma.$ResourceVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResourceVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceVersionCountArgs} args - Arguments to filter ResourceVersions to count.
     * @example
     * // Count the number of ResourceVersions
     * const count = await prisma.resourceVersion.count({
     *   where: {
     *     // ... the filter for the ResourceVersions we want to count
     *   }
     * })
    **/
    count<T extends ResourceVersionCountArgs>(
      args?: Subset<T, ResourceVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceVersionAggregateArgs>(args: Subset<T, ResourceVersionAggregateArgs>): Prisma.PrismaPromise<GetResourceVersionAggregateType<T>>

    /**
     * Group by ResourceVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceVersionGroupByArgs['orderBy'] }
        : { orderBy?: ResourceVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResourceVersion model
   */
  readonly fields: ResourceVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResourceVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends ResourceVersion$creatorArgs<ExtArgs> = {}>(args?: Subset<T, ResourceVersion$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResourceVersion model
   */
  interface ResourceVersionFieldRefs {
    readonly id: FieldRef<"ResourceVersion", 'String'>
    readonly versionNumber: FieldRef<"ResourceVersion", 'Int'>
    readonly title: FieldRef<"ResourceVersion", 'String'>
    readonly content: FieldRef<"ResourceVersion", 'String'>
    readonly tags: FieldRef<"ResourceVersion", 'String[]'>
    readonly metadata: FieldRef<"ResourceVersion", 'Json'>
    readonly resourceId: FieldRef<"ResourceVersion", 'String'>
    readonly createdBy: FieldRef<"ResourceVersion", 'String'>
    readonly createdAt: FieldRef<"ResourceVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResourceVersion findUnique
   */
  export type ResourceVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    /**
     * Filter, which ResourceVersion to fetch.
     */
    where: ResourceVersionWhereUniqueInput
  }

  /**
   * ResourceVersion findUniqueOrThrow
   */
  export type ResourceVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    /**
     * Filter, which ResourceVersion to fetch.
     */
    where: ResourceVersionWhereUniqueInput
  }

  /**
   * ResourceVersion findFirst
   */
  export type ResourceVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    /**
     * Filter, which ResourceVersion to fetch.
     */
    where?: ResourceVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceVersions to fetch.
     */
    orderBy?: ResourceVersionOrderByWithRelationInput | ResourceVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceVersions.
     */
    cursor?: ResourceVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceVersions.
     */
    distinct?: ResourceVersionScalarFieldEnum | ResourceVersionScalarFieldEnum[]
  }

  /**
   * ResourceVersion findFirstOrThrow
   */
  export type ResourceVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    /**
     * Filter, which ResourceVersion to fetch.
     */
    where?: ResourceVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceVersions to fetch.
     */
    orderBy?: ResourceVersionOrderByWithRelationInput | ResourceVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceVersions.
     */
    cursor?: ResourceVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceVersions.
     */
    distinct?: ResourceVersionScalarFieldEnum | ResourceVersionScalarFieldEnum[]
  }

  /**
   * ResourceVersion findMany
   */
  export type ResourceVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    /**
     * Filter, which ResourceVersions to fetch.
     */
    where?: ResourceVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceVersions to fetch.
     */
    orderBy?: ResourceVersionOrderByWithRelationInput | ResourceVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResourceVersions.
     */
    cursor?: ResourceVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceVersions.
     */
    skip?: number
    distinct?: ResourceVersionScalarFieldEnum | ResourceVersionScalarFieldEnum[]
  }

  /**
   * ResourceVersion create
   */
  export type ResourceVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a ResourceVersion.
     */
    data: XOR<ResourceVersionCreateInput, ResourceVersionUncheckedCreateInput>
  }

  /**
   * ResourceVersion createMany
   */
  export type ResourceVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResourceVersions.
     */
    data: ResourceVersionCreateManyInput | ResourceVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceVersion createManyAndReturn
   */
  export type ResourceVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * The data used to create many ResourceVersions.
     */
    data: ResourceVersionCreateManyInput | ResourceVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceVersion update
   */
  export type ResourceVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a ResourceVersion.
     */
    data: XOR<ResourceVersionUpdateInput, ResourceVersionUncheckedUpdateInput>
    /**
     * Choose, which ResourceVersion to update.
     */
    where: ResourceVersionWhereUniqueInput
  }

  /**
   * ResourceVersion updateMany
   */
  export type ResourceVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResourceVersions.
     */
    data: XOR<ResourceVersionUpdateManyMutationInput, ResourceVersionUncheckedUpdateManyInput>
    /**
     * Filter which ResourceVersions to update
     */
    where?: ResourceVersionWhereInput
    /**
     * Limit how many ResourceVersions to update.
     */
    limit?: number
  }

  /**
   * ResourceVersion updateManyAndReturn
   */
  export type ResourceVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * The data used to update ResourceVersions.
     */
    data: XOR<ResourceVersionUpdateManyMutationInput, ResourceVersionUncheckedUpdateManyInput>
    /**
     * Filter which ResourceVersions to update
     */
    where?: ResourceVersionWhereInput
    /**
     * Limit how many ResourceVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceVersion upsert
   */
  export type ResourceVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the ResourceVersion to update in case it exists.
     */
    where: ResourceVersionWhereUniqueInput
    /**
     * In case the ResourceVersion found by the `where` argument doesn't exist, create a new ResourceVersion with this data.
     */
    create: XOR<ResourceVersionCreateInput, ResourceVersionUncheckedCreateInput>
    /**
     * In case the ResourceVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceVersionUpdateInput, ResourceVersionUncheckedUpdateInput>
  }

  /**
   * ResourceVersion delete
   */
  export type ResourceVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
    /**
     * Filter which ResourceVersion to delete.
     */
    where: ResourceVersionWhereUniqueInput
  }

  /**
   * ResourceVersion deleteMany
   */
  export type ResourceVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceVersions to delete
     */
    where?: ResourceVersionWhereInput
    /**
     * Limit how many ResourceVersions to delete.
     */
    limit?: number
  }

  /**
   * ResourceVersion.creator
   */
  export type ResourceVersion$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ResourceVersion without action
   */
  export type ResourceVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceVersion
     */
    select?: ResourceVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceVersion
     */
    omit?: ResourceVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceVersionInclude<ExtArgs> | null
  }


  /**
   * Model Classification
   */

  export type AggregateClassification = {
    _count: ClassificationCountAggregateOutputType | null
    _avg: ClassificationAvgAggregateOutputType | null
    _sum: ClassificationSumAggregateOutputType | null
    _min: ClassificationMinAggregateOutputType | null
    _max: ClassificationMaxAggregateOutputType | null
  }

  export type ClassificationAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type ClassificationSumAggregateOutputType = {
    usageCount: number | null
  }

  export type ClassificationMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    domain: $Enums.ContentDomain | null
    usageCount: number | null
    isSystemDefault: boolean | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ClassificationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    domain: $Enums.ContentDomain | null
    usageCount: number | null
    isSystemDefault: boolean | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ClassificationCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    domain: number
    usageCount: number
    isSystemDefault: number
    parentId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ClassificationAvgAggregateInputType = {
    usageCount?: true
  }

  export type ClassificationSumAggregateInputType = {
    usageCount?: true
  }

  export type ClassificationMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    domain?: true
    usageCount?: true
    isSystemDefault?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ClassificationMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    domain?: true
    usageCount?: true
    isSystemDefault?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ClassificationCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    domain?: true
    usageCount?: true
    isSystemDefault?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ClassificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classification to aggregate.
     */
    where?: ClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classifications to fetch.
     */
    orderBy?: ClassificationOrderByWithRelationInput | ClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classifications
    **/
    _count?: true | ClassificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassificationMaxAggregateInputType
  }

  export type GetClassificationAggregateType<T extends ClassificationAggregateArgs> = {
        [P in keyof T & keyof AggregateClassification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassification[P]>
      : GetScalarType<T[P], AggregateClassification[P]>
  }




  export type ClassificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassificationWhereInput
    orderBy?: ClassificationOrderByWithAggregationInput | ClassificationOrderByWithAggregationInput[]
    by: ClassificationScalarFieldEnum[] | ClassificationScalarFieldEnum
    having?: ClassificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassificationCountAggregateInputType | true
    _avg?: ClassificationAvgAggregateInputType
    _sum?: ClassificationSumAggregateInputType
    _min?: ClassificationMinAggregateInputType
    _max?: ClassificationMaxAggregateInputType
  }

  export type ClassificationGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    domain: $Enums.ContentDomain
    usageCount: number
    isSystemDefault: boolean
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ClassificationCountAggregateOutputType | null
    _avg: ClassificationAvgAggregateOutputType | null
    _sum: ClassificationSumAggregateOutputType | null
    _min: ClassificationMinAggregateOutputType | null
    _max: ClassificationMaxAggregateOutputType | null
  }

  type GetClassificationGroupByPayload<T extends ClassificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassificationGroupByOutputType[P]>
            : GetScalarType<T[P], ClassificationGroupByOutputType[P]>
        }
      >
    >


  export type ClassificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    domain?: boolean
    usageCount?: boolean
    isSystemDefault?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    parent?: boolean | Classification$parentArgs<ExtArgs>
    children?: boolean | Classification$childrenArgs<ExtArgs>
    resources?: boolean | Classification$resourcesArgs<ExtArgs>
    _count?: boolean | ClassificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classification"]>

  export type ClassificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    domain?: boolean
    usageCount?: boolean
    isSystemDefault?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    parent?: boolean | Classification$parentArgs<ExtArgs>
  }, ExtArgs["result"]["classification"]>

  export type ClassificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    domain?: boolean
    usageCount?: boolean
    isSystemDefault?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    parent?: boolean | Classification$parentArgs<ExtArgs>
  }, ExtArgs["result"]["classification"]>

  export type ClassificationSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    domain?: boolean
    usageCount?: boolean
    isSystemDefault?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ClassificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "domain" | "usageCount" | "isSystemDefault" | "parentId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["classification"]>
  export type ClassificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Classification$parentArgs<ExtArgs>
    children?: boolean | Classification$childrenArgs<ExtArgs>
    resources?: boolean | Classification$resourcesArgs<ExtArgs>
    _count?: boolean | ClassificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Classification$parentArgs<ExtArgs>
  }
  export type ClassificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Classification$parentArgs<ExtArgs>
  }

  export type $ClassificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Classification"
    objects: {
      parent: Prisma.$ClassificationPayload<ExtArgs> | null
      children: Prisma.$ClassificationPayload<ExtArgs>[]
      resources: Prisma.$ResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      domain: $Enums.ContentDomain
      usageCount: number
      isSystemDefault: boolean
      parentId: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["classification"]>
    composites: {}
  }

  type ClassificationGetPayload<S extends boolean | null | undefined | ClassificationDefaultArgs> = $Result.GetResult<Prisma.$ClassificationPayload, S>

  type ClassificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassificationCountAggregateInputType | true
    }

  export interface ClassificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Classification'], meta: { name: 'Classification' } }
    /**
     * Find zero or one Classification that matches the filter.
     * @param {ClassificationFindUniqueArgs} args - Arguments to find a Classification
     * @example
     * // Get one Classification
     * const classification = await prisma.classification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassificationFindUniqueArgs>(args: SelectSubset<T, ClassificationFindUniqueArgs<ExtArgs>>): Prisma__ClassificationClient<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Classification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassificationFindUniqueOrThrowArgs} args - Arguments to find a Classification
     * @example
     * // Get one Classification
     * const classification = await prisma.classification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassificationClient<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationFindFirstArgs} args - Arguments to find a Classification
     * @example
     * // Get one Classification
     * const classification = await prisma.classification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassificationFindFirstArgs>(args?: SelectSubset<T, ClassificationFindFirstArgs<ExtArgs>>): Prisma__ClassificationClient<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationFindFirstOrThrowArgs} args - Arguments to find a Classification
     * @example
     * // Get one Classification
     * const classification = await prisma.classification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassificationClient<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classifications
     * const classifications = await prisma.classification.findMany()
     * 
     * // Get first 10 Classifications
     * const classifications = await prisma.classification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classificationWithIdOnly = await prisma.classification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassificationFindManyArgs>(args?: SelectSubset<T, ClassificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Classification.
     * @param {ClassificationCreateArgs} args - Arguments to create a Classification.
     * @example
     * // Create one Classification
     * const Classification = await prisma.classification.create({
     *   data: {
     *     // ... data to create a Classification
     *   }
     * })
     * 
     */
    create<T extends ClassificationCreateArgs>(args: SelectSubset<T, ClassificationCreateArgs<ExtArgs>>): Prisma__ClassificationClient<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classifications.
     * @param {ClassificationCreateManyArgs} args - Arguments to create many Classifications.
     * @example
     * // Create many Classifications
     * const classification = await prisma.classification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassificationCreateManyArgs>(args?: SelectSubset<T, ClassificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classifications and returns the data saved in the database.
     * @param {ClassificationCreateManyAndReturnArgs} args - Arguments to create many Classifications.
     * @example
     * // Create many Classifications
     * const classification = await prisma.classification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classifications and only return the `id`
     * const classificationWithIdOnly = await prisma.classification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassificationCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Classification.
     * @param {ClassificationDeleteArgs} args - Arguments to delete one Classification.
     * @example
     * // Delete one Classification
     * const Classification = await prisma.classification.delete({
     *   where: {
     *     // ... filter to delete one Classification
     *   }
     * })
     * 
     */
    delete<T extends ClassificationDeleteArgs>(args: SelectSubset<T, ClassificationDeleteArgs<ExtArgs>>): Prisma__ClassificationClient<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Classification.
     * @param {ClassificationUpdateArgs} args - Arguments to update one Classification.
     * @example
     * // Update one Classification
     * const classification = await prisma.classification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassificationUpdateArgs>(args: SelectSubset<T, ClassificationUpdateArgs<ExtArgs>>): Prisma__ClassificationClient<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classifications.
     * @param {ClassificationDeleteManyArgs} args - Arguments to filter Classifications to delete.
     * @example
     * // Delete a few Classifications
     * const { count } = await prisma.classification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassificationDeleteManyArgs>(args?: SelectSubset<T, ClassificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classifications
     * const classification = await prisma.classification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassificationUpdateManyArgs>(args: SelectSubset<T, ClassificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classifications and returns the data updated in the database.
     * @param {ClassificationUpdateManyAndReturnArgs} args - Arguments to update many Classifications.
     * @example
     * // Update many Classifications
     * const classification = await prisma.classification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classifications and only return the `id`
     * const classificationWithIdOnly = await prisma.classification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassificationUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Classification.
     * @param {ClassificationUpsertArgs} args - Arguments to update or create a Classification.
     * @example
     * // Update or create a Classification
     * const classification = await prisma.classification.upsert({
     *   create: {
     *     // ... data to create a Classification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classification we want to update
     *   }
     * })
     */
    upsert<T extends ClassificationUpsertArgs>(args: SelectSubset<T, ClassificationUpsertArgs<ExtArgs>>): Prisma__ClassificationClient<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationCountArgs} args - Arguments to filter Classifications to count.
     * @example
     * // Count the number of Classifications
     * const count = await prisma.classification.count({
     *   where: {
     *     // ... the filter for the Classifications we want to count
     *   }
     * })
    **/
    count<T extends ClassificationCountArgs>(
      args?: Subset<T, ClassificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassificationAggregateArgs>(args: Subset<T, ClassificationAggregateArgs>): Prisma.PrismaPromise<GetClassificationAggregateType<T>>

    /**
     * Group by Classification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassificationGroupByArgs['orderBy'] }
        : { orderBy?: ClassificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Classification model
   */
  readonly fields: ClassificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Classification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Classification$parentArgs<ExtArgs> = {}>(args?: Subset<T, Classification$parentArgs<ExtArgs>>): Prisma__ClassificationClient<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Classification$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Classification$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resources<T extends Classification$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Classification$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Classification model
   */
  interface ClassificationFieldRefs {
    readonly id: FieldRef<"Classification", 'String'>
    readonly name: FieldRef<"Classification", 'String'>
    readonly code: FieldRef<"Classification", 'String'>
    readonly description: FieldRef<"Classification", 'String'>
    readonly domain: FieldRef<"Classification", 'ContentDomain'>
    readonly usageCount: FieldRef<"Classification", 'Int'>
    readonly isSystemDefault: FieldRef<"Classification", 'Boolean'>
    readonly parentId: FieldRef<"Classification", 'String'>
    readonly createdAt: FieldRef<"Classification", 'DateTime'>
    readonly updatedAt: FieldRef<"Classification", 'DateTime'>
    readonly deletedAt: FieldRef<"Classification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Classification findUnique
   */
  export type ClassificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    /**
     * Filter, which Classification to fetch.
     */
    where: ClassificationWhereUniqueInput
  }

  /**
   * Classification findUniqueOrThrow
   */
  export type ClassificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    /**
     * Filter, which Classification to fetch.
     */
    where: ClassificationWhereUniqueInput
  }

  /**
   * Classification findFirst
   */
  export type ClassificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    /**
     * Filter, which Classification to fetch.
     */
    where?: ClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classifications to fetch.
     */
    orderBy?: ClassificationOrderByWithRelationInput | ClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classifications.
     */
    cursor?: ClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classifications.
     */
    distinct?: ClassificationScalarFieldEnum | ClassificationScalarFieldEnum[]
  }

  /**
   * Classification findFirstOrThrow
   */
  export type ClassificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    /**
     * Filter, which Classification to fetch.
     */
    where?: ClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classifications to fetch.
     */
    orderBy?: ClassificationOrderByWithRelationInput | ClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classifications.
     */
    cursor?: ClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classifications.
     */
    distinct?: ClassificationScalarFieldEnum | ClassificationScalarFieldEnum[]
  }

  /**
   * Classification findMany
   */
  export type ClassificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    /**
     * Filter, which Classifications to fetch.
     */
    where?: ClassificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classifications to fetch.
     */
    orderBy?: ClassificationOrderByWithRelationInput | ClassificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classifications.
     */
    cursor?: ClassificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classifications.
     */
    skip?: number
    distinct?: ClassificationScalarFieldEnum | ClassificationScalarFieldEnum[]
  }

  /**
   * Classification create
   */
  export type ClassificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Classification.
     */
    data: XOR<ClassificationCreateInput, ClassificationUncheckedCreateInput>
  }

  /**
   * Classification createMany
   */
  export type ClassificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classifications.
     */
    data: ClassificationCreateManyInput | ClassificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Classification createManyAndReturn
   */
  export type ClassificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * The data used to create many Classifications.
     */
    data: ClassificationCreateManyInput | ClassificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Classification update
   */
  export type ClassificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Classification.
     */
    data: XOR<ClassificationUpdateInput, ClassificationUncheckedUpdateInput>
    /**
     * Choose, which Classification to update.
     */
    where: ClassificationWhereUniqueInput
  }

  /**
   * Classification updateMany
   */
  export type ClassificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classifications.
     */
    data: XOR<ClassificationUpdateManyMutationInput, ClassificationUncheckedUpdateManyInput>
    /**
     * Filter which Classifications to update
     */
    where?: ClassificationWhereInput
    /**
     * Limit how many Classifications to update.
     */
    limit?: number
  }

  /**
   * Classification updateManyAndReturn
   */
  export type ClassificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * The data used to update Classifications.
     */
    data: XOR<ClassificationUpdateManyMutationInput, ClassificationUncheckedUpdateManyInput>
    /**
     * Filter which Classifications to update
     */
    where?: ClassificationWhereInput
    /**
     * Limit how many Classifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Classification upsert
   */
  export type ClassificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Classification to update in case it exists.
     */
    where: ClassificationWhereUniqueInput
    /**
     * In case the Classification found by the `where` argument doesn't exist, create a new Classification with this data.
     */
    create: XOR<ClassificationCreateInput, ClassificationUncheckedCreateInput>
    /**
     * In case the Classification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassificationUpdateInput, ClassificationUncheckedUpdateInput>
  }

  /**
   * Classification delete
   */
  export type ClassificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    /**
     * Filter which Classification to delete.
     */
    where: ClassificationWhereUniqueInput
  }

  /**
   * Classification deleteMany
   */
  export type ClassificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classifications to delete
     */
    where?: ClassificationWhereInput
    /**
     * Limit how many Classifications to delete.
     */
    limit?: number
  }

  /**
   * Classification.parent
   */
  export type Classification$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    where?: ClassificationWhereInput
  }

  /**
   * Classification.children
   */
  export type Classification$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
    where?: ClassificationWhereInput
    orderBy?: ClassificationOrderByWithRelationInput | ClassificationOrderByWithRelationInput[]
    cursor?: ClassificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassificationScalarFieldEnum | ClassificationScalarFieldEnum[]
  }

  /**
   * Classification.resources
   */
  export type Classification$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    cursor?: ResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Classification without action
   */
  export type ClassificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classification
     */
    select?: ClassificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classification
     */
    omit?: ClassificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificationInclude<ExtArgs> | null
  }


  /**
   * Model ContentSummary
   */

  export type AggregateContentSummary = {
    _count: ContentSummaryCountAggregateOutputType | null
    _avg: ContentSummaryAvgAggregateOutputType | null
    _sum: ContentSummarySumAggregateOutputType | null
    _min: ContentSummaryMinAggregateOutputType | null
    _max: ContentSummaryMaxAggregateOutputType | null
  }

  export type ContentSummaryAvgAggregateOutputType = {
    totalChunks: number | null
    avgChunkTokens: number | null
  }

  export type ContentSummarySumAggregateOutputType = {
    totalChunks: number | null
    avgChunkTokens: number | null
  }

  export type ContentSummaryMinAggregateOutputType = {
    id: string | null
    executiveSummary: string | null
    keyInsights: string | null
    immediateActions: string | null
    criticalWarnings: string | null
    totalChunks: number | null
    embeddingModel: string | null
    avgChunkTokens: number | null
    resourceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ContentSummaryMaxAggregateOutputType = {
    id: string | null
    executiveSummary: string | null
    keyInsights: string | null
    immediateActions: string | null
    criticalWarnings: string | null
    totalChunks: number | null
    embeddingModel: string | null
    avgChunkTokens: number | null
    resourceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ContentSummaryCountAggregateOutputType = {
    id: number
    executiveSummary: number
    keyInsights: number
    immediateActions: number
    criticalWarnings: number
    keyMetrics: number
    toolsResources: number
    peopleCompanies: number
    primaryKeywords: number
    semanticTags: number
    questionBasedTags: number
    totalChunks: number
    embeddingModel: number
    avgChunkTokens: number
    resourceId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ContentSummaryAvgAggregateInputType = {
    totalChunks?: true
    avgChunkTokens?: true
  }

  export type ContentSummarySumAggregateInputType = {
    totalChunks?: true
    avgChunkTokens?: true
  }

  export type ContentSummaryMinAggregateInputType = {
    id?: true
    executiveSummary?: true
    keyInsights?: true
    immediateActions?: true
    criticalWarnings?: true
    totalChunks?: true
    embeddingModel?: true
    avgChunkTokens?: true
    resourceId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ContentSummaryMaxAggregateInputType = {
    id?: true
    executiveSummary?: true
    keyInsights?: true
    immediateActions?: true
    criticalWarnings?: true
    totalChunks?: true
    embeddingModel?: true
    avgChunkTokens?: true
    resourceId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ContentSummaryCountAggregateInputType = {
    id?: true
    executiveSummary?: true
    keyInsights?: true
    immediateActions?: true
    criticalWarnings?: true
    keyMetrics?: true
    toolsResources?: true
    peopleCompanies?: true
    primaryKeywords?: true
    semanticTags?: true
    questionBasedTags?: true
    totalChunks?: true
    embeddingModel?: true
    avgChunkTokens?: true
    resourceId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ContentSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentSummary to aggregate.
     */
    where?: ContentSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSummaries to fetch.
     */
    orderBy?: ContentSummaryOrderByWithRelationInput | ContentSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentSummaries
    **/
    _count?: true | ContentSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentSummaryMaxAggregateInputType
  }

  export type GetContentSummaryAggregateType<T extends ContentSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateContentSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentSummary[P]>
      : GetScalarType<T[P], AggregateContentSummary[P]>
  }




  export type ContentSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentSummaryWhereInput
    orderBy?: ContentSummaryOrderByWithAggregationInput | ContentSummaryOrderByWithAggregationInput[]
    by: ContentSummaryScalarFieldEnum[] | ContentSummaryScalarFieldEnum
    having?: ContentSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentSummaryCountAggregateInputType | true
    _avg?: ContentSummaryAvgAggregateInputType
    _sum?: ContentSummarySumAggregateInputType
    _min?: ContentSummaryMinAggregateInputType
    _max?: ContentSummaryMaxAggregateInputType
  }

  export type ContentSummaryGroupByOutputType = {
    id: string
    executiveSummary: string
    keyInsights: string | null
    immediateActions: string | null
    criticalWarnings: string | null
    keyMetrics: JsonValue
    toolsResources: JsonValue
    peopleCompanies: string[]
    primaryKeywords: string[]
    semanticTags: string[]
    questionBasedTags: string[]
    totalChunks: number
    embeddingModel: string
    avgChunkTokens: number | null
    resourceId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ContentSummaryCountAggregateOutputType | null
    _avg: ContentSummaryAvgAggregateOutputType | null
    _sum: ContentSummarySumAggregateOutputType | null
    _min: ContentSummaryMinAggregateOutputType | null
    _max: ContentSummaryMaxAggregateOutputType | null
  }

  type GetContentSummaryGroupByPayload<T extends ContentSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], ContentSummaryGroupByOutputType[P]>
        }
      >
    >


  export type ContentSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executiveSummary?: boolean
    keyInsights?: boolean
    immediateActions?: boolean
    criticalWarnings?: boolean
    keyMetrics?: boolean
    toolsResources?: boolean
    peopleCompanies?: boolean
    primaryKeywords?: boolean
    semanticTags?: boolean
    questionBasedTags?: boolean
    totalChunks?: boolean
    embeddingModel?: boolean
    avgChunkTokens?: boolean
    resourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    vectorChunks?: boolean | ContentSummary$vectorChunksArgs<ExtArgs>
    _count?: boolean | ContentSummaryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentSummary"]>

  export type ContentSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executiveSummary?: boolean
    keyInsights?: boolean
    immediateActions?: boolean
    criticalWarnings?: boolean
    keyMetrics?: boolean
    toolsResources?: boolean
    peopleCompanies?: boolean
    primaryKeywords?: boolean
    semanticTags?: boolean
    questionBasedTags?: boolean
    totalChunks?: boolean
    embeddingModel?: boolean
    avgChunkTokens?: boolean
    resourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentSummary"]>

  export type ContentSummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    executiveSummary?: boolean
    keyInsights?: boolean
    immediateActions?: boolean
    criticalWarnings?: boolean
    keyMetrics?: boolean
    toolsResources?: boolean
    peopleCompanies?: boolean
    primaryKeywords?: boolean
    semanticTags?: boolean
    questionBasedTags?: boolean
    totalChunks?: boolean
    embeddingModel?: boolean
    avgChunkTokens?: boolean
    resourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentSummary"]>

  export type ContentSummarySelectScalar = {
    id?: boolean
    executiveSummary?: boolean
    keyInsights?: boolean
    immediateActions?: boolean
    criticalWarnings?: boolean
    keyMetrics?: boolean
    toolsResources?: boolean
    peopleCompanies?: boolean
    primaryKeywords?: boolean
    semanticTags?: boolean
    questionBasedTags?: boolean
    totalChunks?: boolean
    embeddingModel?: boolean
    avgChunkTokens?: boolean
    resourceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ContentSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "executiveSummary" | "keyInsights" | "immediateActions" | "criticalWarnings" | "keyMetrics" | "toolsResources" | "peopleCompanies" | "primaryKeywords" | "semanticTags" | "questionBasedTags" | "totalChunks" | "embeddingModel" | "avgChunkTokens" | "resourceId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["contentSummary"]>
  export type ContentSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    vectorChunks?: boolean | ContentSummary$vectorChunksArgs<ExtArgs>
    _count?: boolean | ContentSummaryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentSummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type ContentSummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $ContentSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentSummary"
    objects: {
      resource: Prisma.$ResourcePayload<ExtArgs>
      vectorChunks: Prisma.$VectorChunkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      executiveSummary: string
      keyInsights: string | null
      immediateActions: string | null
      criticalWarnings: string | null
      keyMetrics: Prisma.JsonValue
      toolsResources: Prisma.JsonValue
      peopleCompanies: string[]
      primaryKeywords: string[]
      semanticTags: string[]
      questionBasedTags: string[]
      totalChunks: number
      embeddingModel: string
      avgChunkTokens: number | null
      resourceId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["contentSummary"]>
    composites: {}
  }

  type ContentSummaryGetPayload<S extends boolean | null | undefined | ContentSummaryDefaultArgs> = $Result.GetResult<Prisma.$ContentSummaryPayload, S>

  type ContentSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentSummaryCountAggregateInputType | true
    }

  export interface ContentSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentSummary'], meta: { name: 'ContentSummary' } }
    /**
     * Find zero or one ContentSummary that matches the filter.
     * @param {ContentSummaryFindUniqueArgs} args - Arguments to find a ContentSummary
     * @example
     * // Get one ContentSummary
     * const contentSummary = await prisma.contentSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentSummaryFindUniqueArgs>(args: SelectSubset<T, ContentSummaryFindUniqueArgs<ExtArgs>>): Prisma__ContentSummaryClient<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentSummaryFindUniqueOrThrowArgs} args - Arguments to find a ContentSummary
     * @example
     * // Get one ContentSummary
     * const contentSummary = await prisma.contentSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentSummaryClient<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSummaryFindFirstArgs} args - Arguments to find a ContentSummary
     * @example
     * // Get one ContentSummary
     * const contentSummary = await prisma.contentSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentSummaryFindFirstArgs>(args?: SelectSubset<T, ContentSummaryFindFirstArgs<ExtArgs>>): Prisma__ContentSummaryClient<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSummaryFindFirstOrThrowArgs} args - Arguments to find a ContentSummary
     * @example
     * // Get one ContentSummary
     * const contentSummary = await prisma.contentSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentSummaryClient<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentSummaries
     * const contentSummaries = await prisma.contentSummary.findMany()
     * 
     * // Get first 10 ContentSummaries
     * const contentSummaries = await prisma.contentSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentSummaryWithIdOnly = await prisma.contentSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentSummaryFindManyArgs>(args?: SelectSubset<T, ContentSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentSummary.
     * @param {ContentSummaryCreateArgs} args - Arguments to create a ContentSummary.
     * @example
     * // Create one ContentSummary
     * const ContentSummary = await prisma.contentSummary.create({
     *   data: {
     *     // ... data to create a ContentSummary
     *   }
     * })
     * 
     */
    create<T extends ContentSummaryCreateArgs>(args: SelectSubset<T, ContentSummaryCreateArgs<ExtArgs>>): Prisma__ContentSummaryClient<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentSummaries.
     * @param {ContentSummaryCreateManyArgs} args - Arguments to create many ContentSummaries.
     * @example
     * // Create many ContentSummaries
     * const contentSummary = await prisma.contentSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentSummaryCreateManyArgs>(args?: SelectSubset<T, ContentSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentSummaries and returns the data saved in the database.
     * @param {ContentSummaryCreateManyAndReturnArgs} args - Arguments to create many ContentSummaries.
     * @example
     * // Create many ContentSummaries
     * const contentSummary = await prisma.contentSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentSummaries and only return the `id`
     * const contentSummaryWithIdOnly = await prisma.contentSummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentSummary.
     * @param {ContentSummaryDeleteArgs} args - Arguments to delete one ContentSummary.
     * @example
     * // Delete one ContentSummary
     * const ContentSummary = await prisma.contentSummary.delete({
     *   where: {
     *     // ... filter to delete one ContentSummary
     *   }
     * })
     * 
     */
    delete<T extends ContentSummaryDeleteArgs>(args: SelectSubset<T, ContentSummaryDeleteArgs<ExtArgs>>): Prisma__ContentSummaryClient<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentSummary.
     * @param {ContentSummaryUpdateArgs} args - Arguments to update one ContentSummary.
     * @example
     * // Update one ContentSummary
     * const contentSummary = await prisma.contentSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentSummaryUpdateArgs>(args: SelectSubset<T, ContentSummaryUpdateArgs<ExtArgs>>): Prisma__ContentSummaryClient<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentSummaries.
     * @param {ContentSummaryDeleteManyArgs} args - Arguments to filter ContentSummaries to delete.
     * @example
     * // Delete a few ContentSummaries
     * const { count } = await prisma.contentSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentSummaryDeleteManyArgs>(args?: SelectSubset<T, ContentSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentSummaries
     * const contentSummary = await prisma.contentSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentSummaryUpdateManyArgs>(args: SelectSubset<T, ContentSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentSummaries and returns the data updated in the database.
     * @param {ContentSummaryUpdateManyAndReturnArgs} args - Arguments to update many ContentSummaries.
     * @example
     * // Update many ContentSummaries
     * const contentSummary = await prisma.contentSummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentSummaries and only return the `id`
     * const contentSummaryWithIdOnly = await prisma.contentSummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentSummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentSummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentSummary.
     * @param {ContentSummaryUpsertArgs} args - Arguments to update or create a ContentSummary.
     * @example
     * // Update or create a ContentSummary
     * const contentSummary = await prisma.contentSummary.upsert({
     *   create: {
     *     // ... data to create a ContentSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentSummary we want to update
     *   }
     * })
     */
    upsert<T extends ContentSummaryUpsertArgs>(args: SelectSubset<T, ContentSummaryUpsertArgs<ExtArgs>>): Prisma__ContentSummaryClient<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSummaryCountArgs} args - Arguments to filter ContentSummaries to count.
     * @example
     * // Count the number of ContentSummaries
     * const count = await prisma.contentSummary.count({
     *   where: {
     *     // ... the filter for the ContentSummaries we want to count
     *   }
     * })
    **/
    count<T extends ContentSummaryCountArgs>(
      args?: Subset<T, ContentSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentSummaryAggregateArgs>(args: Subset<T, ContentSummaryAggregateArgs>): Prisma.PrismaPromise<GetContentSummaryAggregateType<T>>

    /**
     * Group by ContentSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentSummaryGroupByArgs['orderBy'] }
        : { orderBy?: ContentSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentSummary model
   */
  readonly fields: ContentSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vectorChunks<T extends ContentSummary$vectorChunksArgs<ExtArgs> = {}>(args?: Subset<T, ContentSummary$vectorChunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentSummary model
   */
  interface ContentSummaryFieldRefs {
    readonly id: FieldRef<"ContentSummary", 'String'>
    readonly executiveSummary: FieldRef<"ContentSummary", 'String'>
    readonly keyInsights: FieldRef<"ContentSummary", 'String'>
    readonly immediateActions: FieldRef<"ContentSummary", 'String'>
    readonly criticalWarnings: FieldRef<"ContentSummary", 'String'>
    readonly keyMetrics: FieldRef<"ContentSummary", 'Json'>
    readonly toolsResources: FieldRef<"ContentSummary", 'Json'>
    readonly peopleCompanies: FieldRef<"ContentSummary", 'String[]'>
    readonly primaryKeywords: FieldRef<"ContentSummary", 'String[]'>
    readonly semanticTags: FieldRef<"ContentSummary", 'String[]'>
    readonly questionBasedTags: FieldRef<"ContentSummary", 'String[]'>
    readonly totalChunks: FieldRef<"ContentSummary", 'Int'>
    readonly embeddingModel: FieldRef<"ContentSummary", 'String'>
    readonly avgChunkTokens: FieldRef<"ContentSummary", 'Int'>
    readonly resourceId: FieldRef<"ContentSummary", 'String'>
    readonly createdAt: FieldRef<"ContentSummary", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentSummary", 'DateTime'>
    readonly deletedAt: FieldRef<"ContentSummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentSummary findUnique
   */
  export type ContentSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
    /**
     * Filter, which ContentSummary to fetch.
     */
    where: ContentSummaryWhereUniqueInput
  }

  /**
   * ContentSummary findUniqueOrThrow
   */
  export type ContentSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
    /**
     * Filter, which ContentSummary to fetch.
     */
    where: ContentSummaryWhereUniqueInput
  }

  /**
   * ContentSummary findFirst
   */
  export type ContentSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
    /**
     * Filter, which ContentSummary to fetch.
     */
    where?: ContentSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSummaries to fetch.
     */
    orderBy?: ContentSummaryOrderByWithRelationInput | ContentSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentSummaries.
     */
    cursor?: ContentSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentSummaries.
     */
    distinct?: ContentSummaryScalarFieldEnum | ContentSummaryScalarFieldEnum[]
  }

  /**
   * ContentSummary findFirstOrThrow
   */
  export type ContentSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
    /**
     * Filter, which ContentSummary to fetch.
     */
    where?: ContentSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSummaries to fetch.
     */
    orderBy?: ContentSummaryOrderByWithRelationInput | ContentSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentSummaries.
     */
    cursor?: ContentSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentSummaries.
     */
    distinct?: ContentSummaryScalarFieldEnum | ContentSummaryScalarFieldEnum[]
  }

  /**
   * ContentSummary findMany
   */
  export type ContentSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
    /**
     * Filter, which ContentSummaries to fetch.
     */
    where?: ContentSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentSummaries to fetch.
     */
    orderBy?: ContentSummaryOrderByWithRelationInput | ContentSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentSummaries.
     */
    cursor?: ContentSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentSummaries.
     */
    skip?: number
    distinct?: ContentSummaryScalarFieldEnum | ContentSummaryScalarFieldEnum[]
  }

  /**
   * ContentSummary create
   */
  export type ContentSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentSummary.
     */
    data: XOR<ContentSummaryCreateInput, ContentSummaryUncheckedCreateInput>
  }

  /**
   * ContentSummary createMany
   */
  export type ContentSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentSummaries.
     */
    data: ContentSummaryCreateManyInput | ContentSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentSummary createManyAndReturn
   */
  export type ContentSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * The data used to create many ContentSummaries.
     */
    data: ContentSummaryCreateManyInput | ContentSummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentSummary update
   */
  export type ContentSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentSummary.
     */
    data: XOR<ContentSummaryUpdateInput, ContentSummaryUncheckedUpdateInput>
    /**
     * Choose, which ContentSummary to update.
     */
    where: ContentSummaryWhereUniqueInput
  }

  /**
   * ContentSummary updateMany
   */
  export type ContentSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentSummaries.
     */
    data: XOR<ContentSummaryUpdateManyMutationInput, ContentSummaryUncheckedUpdateManyInput>
    /**
     * Filter which ContentSummaries to update
     */
    where?: ContentSummaryWhereInput
    /**
     * Limit how many ContentSummaries to update.
     */
    limit?: number
  }

  /**
   * ContentSummary updateManyAndReturn
   */
  export type ContentSummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * The data used to update ContentSummaries.
     */
    data: XOR<ContentSummaryUpdateManyMutationInput, ContentSummaryUncheckedUpdateManyInput>
    /**
     * Filter which ContentSummaries to update
     */
    where?: ContentSummaryWhereInput
    /**
     * Limit how many ContentSummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentSummary upsert
   */
  export type ContentSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentSummary to update in case it exists.
     */
    where: ContentSummaryWhereUniqueInput
    /**
     * In case the ContentSummary found by the `where` argument doesn't exist, create a new ContentSummary with this data.
     */
    create: XOR<ContentSummaryCreateInput, ContentSummaryUncheckedCreateInput>
    /**
     * In case the ContentSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentSummaryUpdateInput, ContentSummaryUncheckedUpdateInput>
  }

  /**
   * ContentSummary delete
   */
  export type ContentSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
    /**
     * Filter which ContentSummary to delete.
     */
    where: ContentSummaryWhereUniqueInput
  }

  /**
   * ContentSummary deleteMany
   */
  export type ContentSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentSummaries to delete
     */
    where?: ContentSummaryWhereInput
    /**
     * Limit how many ContentSummaries to delete.
     */
    limit?: number
  }

  /**
   * ContentSummary.vectorChunks
   */
  export type ContentSummary$vectorChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    where?: VectorChunkWhereInput
    orderBy?: VectorChunkOrderByWithRelationInput | VectorChunkOrderByWithRelationInput[]
    cursor?: VectorChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VectorChunkScalarFieldEnum | VectorChunkScalarFieldEnum[]
  }

  /**
   * ContentSummary without action
   */
  export type ContentSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentSummary
     */
    select?: ContentSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentSummary
     */
    omit?: ContentSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentSummaryInclude<ExtArgs> | null
  }


  /**
   * Model VectorChunk
   */

  export type AggregateVectorChunk = {
    _count: VectorChunkCountAggregateOutputType | null
    _avg: VectorChunkAvgAggregateOutputType | null
    _sum: VectorChunkSumAggregateOutputType | null
    _min: VectorChunkMinAggregateOutputType | null
    _max: VectorChunkMaxAggregateOutputType | null
  }

  export type VectorChunkAvgAggregateOutputType = {
    chunkIndex: number | null
    tokenCount: number | null
    vectorDimension: number | null
    semanticDensity: Decimal | null
    retrievalFrequency: number | null
  }

  export type VectorChunkSumAggregateOutputType = {
    chunkIndex: number | null
    tokenCount: number | null
    vectorDimension: number | null
    semanticDensity: Decimal | null
    retrievalFrequency: number | null
  }

  export type VectorChunkMinAggregateOutputType = {
    id: string | null
    chunkIndex: number | null
    chunkType: $Enums.ChunkType | null
    content: string | null
    tokenCount: number | null
    pineconeId: string | null
    pineconeNamespace: string | null
    embeddingModel: string | null
    vectorDimension: number | null
    semanticDensity: Decimal | null
    retrievalFrequency: number | null
    lastRetrieved: Date | null
    resourceId: string | null
    summaryId: string | null
    parentChunkId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type VectorChunkMaxAggregateOutputType = {
    id: string | null
    chunkIndex: number | null
    chunkType: $Enums.ChunkType | null
    content: string | null
    tokenCount: number | null
    pineconeId: string | null
    pineconeNamespace: string | null
    embeddingModel: string | null
    vectorDimension: number | null
    semanticDensity: Decimal | null
    retrievalFrequency: number | null
    lastRetrieved: Date | null
    resourceId: string | null
    summaryId: string | null
    parentChunkId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type VectorChunkCountAggregateOutputType = {
    id: number
    chunkIndex: number
    chunkType: number
    content: number
    tokenCount: number
    pineconeId: number
    pineconeNamespace: number
    embeddingModel: number
    vectorDimension: number
    overlappingChunks: number
    semanticDensity: number
    retrievalFrequency: number
    lastRetrieved: number
    resourceId: number
    summaryId: number
    parentChunkId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type VectorChunkAvgAggregateInputType = {
    chunkIndex?: true
    tokenCount?: true
    vectorDimension?: true
    semanticDensity?: true
    retrievalFrequency?: true
  }

  export type VectorChunkSumAggregateInputType = {
    chunkIndex?: true
    tokenCount?: true
    vectorDimension?: true
    semanticDensity?: true
    retrievalFrequency?: true
  }

  export type VectorChunkMinAggregateInputType = {
    id?: true
    chunkIndex?: true
    chunkType?: true
    content?: true
    tokenCount?: true
    pineconeId?: true
    pineconeNamespace?: true
    embeddingModel?: true
    vectorDimension?: true
    semanticDensity?: true
    retrievalFrequency?: true
    lastRetrieved?: true
    resourceId?: true
    summaryId?: true
    parentChunkId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type VectorChunkMaxAggregateInputType = {
    id?: true
    chunkIndex?: true
    chunkType?: true
    content?: true
    tokenCount?: true
    pineconeId?: true
    pineconeNamespace?: true
    embeddingModel?: true
    vectorDimension?: true
    semanticDensity?: true
    retrievalFrequency?: true
    lastRetrieved?: true
    resourceId?: true
    summaryId?: true
    parentChunkId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type VectorChunkCountAggregateInputType = {
    id?: true
    chunkIndex?: true
    chunkType?: true
    content?: true
    tokenCount?: true
    pineconeId?: true
    pineconeNamespace?: true
    embeddingModel?: true
    vectorDimension?: true
    overlappingChunks?: true
    semanticDensity?: true
    retrievalFrequency?: true
    lastRetrieved?: true
    resourceId?: true
    summaryId?: true
    parentChunkId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type VectorChunkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VectorChunk to aggregate.
     */
    where?: VectorChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VectorChunks to fetch.
     */
    orderBy?: VectorChunkOrderByWithRelationInput | VectorChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VectorChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VectorChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VectorChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VectorChunks
    **/
    _count?: true | VectorChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VectorChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VectorChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VectorChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VectorChunkMaxAggregateInputType
  }

  export type GetVectorChunkAggregateType<T extends VectorChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateVectorChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVectorChunk[P]>
      : GetScalarType<T[P], AggregateVectorChunk[P]>
  }




  export type VectorChunkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VectorChunkWhereInput
    orderBy?: VectorChunkOrderByWithAggregationInput | VectorChunkOrderByWithAggregationInput[]
    by: VectorChunkScalarFieldEnum[] | VectorChunkScalarFieldEnum
    having?: VectorChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VectorChunkCountAggregateInputType | true
    _avg?: VectorChunkAvgAggregateInputType
    _sum?: VectorChunkSumAggregateInputType
    _min?: VectorChunkMinAggregateInputType
    _max?: VectorChunkMaxAggregateInputType
  }

  export type VectorChunkGroupByOutputType = {
    id: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId: string | null
    pineconeNamespace: string | null
    embeddingModel: string
    vectorDimension: number
    overlappingChunks: string[]
    semanticDensity: Decimal | null
    retrievalFrequency: number
    lastRetrieved: Date | null
    resourceId: string
    summaryId: string
    parentChunkId: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: VectorChunkCountAggregateOutputType | null
    _avg: VectorChunkAvgAggregateOutputType | null
    _sum: VectorChunkSumAggregateOutputType | null
    _min: VectorChunkMinAggregateOutputType | null
    _max: VectorChunkMaxAggregateOutputType | null
  }

  type GetVectorChunkGroupByPayload<T extends VectorChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VectorChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VectorChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VectorChunkGroupByOutputType[P]>
            : GetScalarType<T[P], VectorChunkGroupByOutputType[P]>
        }
      >
    >


  export type VectorChunkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chunkIndex?: boolean
    chunkType?: boolean
    content?: boolean
    tokenCount?: boolean
    pineconeId?: boolean
    pineconeNamespace?: boolean
    embeddingModel?: boolean
    vectorDimension?: boolean
    overlappingChunks?: boolean
    semanticDensity?: boolean
    retrievalFrequency?: boolean
    lastRetrieved?: boolean
    resourceId?: boolean
    summaryId?: boolean
    parentChunkId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    summary?: boolean | ContentSummaryDefaultArgs<ExtArgs>
    parentChunk?: boolean | VectorChunk$parentChunkArgs<ExtArgs>
    childChunks?: boolean | VectorChunk$childChunksArgs<ExtArgs>
    _count?: boolean | VectorChunkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vectorChunk"]>

  export type VectorChunkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chunkIndex?: boolean
    chunkType?: boolean
    content?: boolean
    tokenCount?: boolean
    pineconeId?: boolean
    pineconeNamespace?: boolean
    embeddingModel?: boolean
    vectorDimension?: boolean
    overlappingChunks?: boolean
    semanticDensity?: boolean
    retrievalFrequency?: boolean
    lastRetrieved?: boolean
    resourceId?: boolean
    summaryId?: boolean
    parentChunkId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    summary?: boolean | ContentSummaryDefaultArgs<ExtArgs>
    parentChunk?: boolean | VectorChunk$parentChunkArgs<ExtArgs>
  }, ExtArgs["result"]["vectorChunk"]>

  export type VectorChunkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chunkIndex?: boolean
    chunkType?: boolean
    content?: boolean
    tokenCount?: boolean
    pineconeId?: boolean
    pineconeNamespace?: boolean
    embeddingModel?: boolean
    vectorDimension?: boolean
    overlappingChunks?: boolean
    semanticDensity?: boolean
    retrievalFrequency?: boolean
    lastRetrieved?: boolean
    resourceId?: boolean
    summaryId?: boolean
    parentChunkId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    summary?: boolean | ContentSummaryDefaultArgs<ExtArgs>
    parentChunk?: boolean | VectorChunk$parentChunkArgs<ExtArgs>
  }, ExtArgs["result"]["vectorChunk"]>

  export type VectorChunkSelectScalar = {
    id?: boolean
    chunkIndex?: boolean
    chunkType?: boolean
    content?: boolean
    tokenCount?: boolean
    pineconeId?: boolean
    pineconeNamespace?: boolean
    embeddingModel?: boolean
    vectorDimension?: boolean
    overlappingChunks?: boolean
    semanticDensity?: boolean
    retrievalFrequency?: boolean
    lastRetrieved?: boolean
    resourceId?: boolean
    summaryId?: boolean
    parentChunkId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type VectorChunkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chunkIndex" | "chunkType" | "content" | "tokenCount" | "pineconeId" | "pineconeNamespace" | "embeddingModel" | "vectorDimension" | "overlappingChunks" | "semanticDensity" | "retrievalFrequency" | "lastRetrieved" | "resourceId" | "summaryId" | "parentChunkId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["vectorChunk"]>
  export type VectorChunkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    summary?: boolean | ContentSummaryDefaultArgs<ExtArgs>
    parentChunk?: boolean | VectorChunk$parentChunkArgs<ExtArgs>
    childChunks?: boolean | VectorChunk$childChunksArgs<ExtArgs>
    _count?: boolean | VectorChunkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VectorChunkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    summary?: boolean | ContentSummaryDefaultArgs<ExtArgs>
    parentChunk?: boolean | VectorChunk$parentChunkArgs<ExtArgs>
  }
  export type VectorChunkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
    summary?: boolean | ContentSummaryDefaultArgs<ExtArgs>
    parentChunk?: boolean | VectorChunk$parentChunkArgs<ExtArgs>
  }

  export type $VectorChunkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VectorChunk"
    objects: {
      resource: Prisma.$ResourcePayload<ExtArgs>
      summary: Prisma.$ContentSummaryPayload<ExtArgs>
      parentChunk: Prisma.$VectorChunkPayload<ExtArgs> | null
      childChunks: Prisma.$VectorChunkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chunkIndex: number
      chunkType: $Enums.ChunkType
      content: string
      tokenCount: number
      pineconeId: string | null
      pineconeNamespace: string | null
      embeddingModel: string
      vectorDimension: number
      overlappingChunks: string[]
      semanticDensity: Prisma.Decimal | null
      retrievalFrequency: number
      lastRetrieved: Date | null
      resourceId: string
      summaryId: string
      parentChunkId: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["vectorChunk"]>
    composites: {}
  }

  type VectorChunkGetPayload<S extends boolean | null | undefined | VectorChunkDefaultArgs> = $Result.GetResult<Prisma.$VectorChunkPayload, S>

  type VectorChunkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VectorChunkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VectorChunkCountAggregateInputType | true
    }

  export interface VectorChunkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VectorChunk'], meta: { name: 'VectorChunk' } }
    /**
     * Find zero or one VectorChunk that matches the filter.
     * @param {VectorChunkFindUniqueArgs} args - Arguments to find a VectorChunk
     * @example
     * // Get one VectorChunk
     * const vectorChunk = await prisma.vectorChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VectorChunkFindUniqueArgs>(args: SelectSubset<T, VectorChunkFindUniqueArgs<ExtArgs>>): Prisma__VectorChunkClient<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VectorChunk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VectorChunkFindUniqueOrThrowArgs} args - Arguments to find a VectorChunk
     * @example
     * // Get one VectorChunk
     * const vectorChunk = await prisma.vectorChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VectorChunkFindUniqueOrThrowArgs>(args: SelectSubset<T, VectorChunkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VectorChunkClient<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VectorChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorChunkFindFirstArgs} args - Arguments to find a VectorChunk
     * @example
     * // Get one VectorChunk
     * const vectorChunk = await prisma.vectorChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VectorChunkFindFirstArgs>(args?: SelectSubset<T, VectorChunkFindFirstArgs<ExtArgs>>): Prisma__VectorChunkClient<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VectorChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorChunkFindFirstOrThrowArgs} args - Arguments to find a VectorChunk
     * @example
     * // Get one VectorChunk
     * const vectorChunk = await prisma.vectorChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VectorChunkFindFirstOrThrowArgs>(args?: SelectSubset<T, VectorChunkFindFirstOrThrowArgs<ExtArgs>>): Prisma__VectorChunkClient<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VectorChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorChunkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VectorChunks
     * const vectorChunks = await prisma.vectorChunk.findMany()
     * 
     * // Get first 10 VectorChunks
     * const vectorChunks = await prisma.vectorChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vectorChunkWithIdOnly = await prisma.vectorChunk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VectorChunkFindManyArgs>(args?: SelectSubset<T, VectorChunkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VectorChunk.
     * @param {VectorChunkCreateArgs} args - Arguments to create a VectorChunk.
     * @example
     * // Create one VectorChunk
     * const VectorChunk = await prisma.vectorChunk.create({
     *   data: {
     *     // ... data to create a VectorChunk
     *   }
     * })
     * 
     */
    create<T extends VectorChunkCreateArgs>(args: SelectSubset<T, VectorChunkCreateArgs<ExtArgs>>): Prisma__VectorChunkClient<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VectorChunks.
     * @param {VectorChunkCreateManyArgs} args - Arguments to create many VectorChunks.
     * @example
     * // Create many VectorChunks
     * const vectorChunk = await prisma.vectorChunk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VectorChunkCreateManyArgs>(args?: SelectSubset<T, VectorChunkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VectorChunks and returns the data saved in the database.
     * @param {VectorChunkCreateManyAndReturnArgs} args - Arguments to create many VectorChunks.
     * @example
     * // Create many VectorChunks
     * const vectorChunk = await prisma.vectorChunk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VectorChunks and only return the `id`
     * const vectorChunkWithIdOnly = await prisma.vectorChunk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VectorChunkCreateManyAndReturnArgs>(args?: SelectSubset<T, VectorChunkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VectorChunk.
     * @param {VectorChunkDeleteArgs} args - Arguments to delete one VectorChunk.
     * @example
     * // Delete one VectorChunk
     * const VectorChunk = await prisma.vectorChunk.delete({
     *   where: {
     *     // ... filter to delete one VectorChunk
     *   }
     * })
     * 
     */
    delete<T extends VectorChunkDeleteArgs>(args: SelectSubset<T, VectorChunkDeleteArgs<ExtArgs>>): Prisma__VectorChunkClient<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VectorChunk.
     * @param {VectorChunkUpdateArgs} args - Arguments to update one VectorChunk.
     * @example
     * // Update one VectorChunk
     * const vectorChunk = await prisma.vectorChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VectorChunkUpdateArgs>(args: SelectSubset<T, VectorChunkUpdateArgs<ExtArgs>>): Prisma__VectorChunkClient<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VectorChunks.
     * @param {VectorChunkDeleteManyArgs} args - Arguments to filter VectorChunks to delete.
     * @example
     * // Delete a few VectorChunks
     * const { count } = await prisma.vectorChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VectorChunkDeleteManyArgs>(args?: SelectSubset<T, VectorChunkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VectorChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VectorChunks
     * const vectorChunk = await prisma.vectorChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VectorChunkUpdateManyArgs>(args: SelectSubset<T, VectorChunkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VectorChunks and returns the data updated in the database.
     * @param {VectorChunkUpdateManyAndReturnArgs} args - Arguments to update many VectorChunks.
     * @example
     * // Update many VectorChunks
     * const vectorChunk = await prisma.vectorChunk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VectorChunks and only return the `id`
     * const vectorChunkWithIdOnly = await prisma.vectorChunk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VectorChunkUpdateManyAndReturnArgs>(args: SelectSubset<T, VectorChunkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VectorChunk.
     * @param {VectorChunkUpsertArgs} args - Arguments to update or create a VectorChunk.
     * @example
     * // Update or create a VectorChunk
     * const vectorChunk = await prisma.vectorChunk.upsert({
     *   create: {
     *     // ... data to create a VectorChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VectorChunk we want to update
     *   }
     * })
     */
    upsert<T extends VectorChunkUpsertArgs>(args: SelectSubset<T, VectorChunkUpsertArgs<ExtArgs>>): Prisma__VectorChunkClient<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VectorChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorChunkCountArgs} args - Arguments to filter VectorChunks to count.
     * @example
     * // Count the number of VectorChunks
     * const count = await prisma.vectorChunk.count({
     *   where: {
     *     // ... the filter for the VectorChunks we want to count
     *   }
     * })
    **/
    count<T extends VectorChunkCountArgs>(
      args?: Subset<T, VectorChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VectorChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VectorChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VectorChunkAggregateArgs>(args: Subset<T, VectorChunkAggregateArgs>): Prisma.PrismaPromise<GetVectorChunkAggregateType<T>>

    /**
     * Group by VectorChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VectorChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VectorChunkGroupByArgs['orderBy'] }
        : { orderBy?: VectorChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VectorChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVectorChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VectorChunk model
   */
  readonly fields: VectorChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VectorChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VectorChunkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    summary<T extends ContentSummaryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentSummaryDefaultArgs<ExtArgs>>): Prisma__ContentSummaryClient<$Result.GetResult<Prisma.$ContentSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentChunk<T extends VectorChunk$parentChunkArgs<ExtArgs> = {}>(args?: Subset<T, VectorChunk$parentChunkArgs<ExtArgs>>): Prisma__VectorChunkClient<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    childChunks<T extends VectorChunk$childChunksArgs<ExtArgs> = {}>(args?: Subset<T, VectorChunk$childChunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VectorChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VectorChunk model
   */
  interface VectorChunkFieldRefs {
    readonly id: FieldRef<"VectorChunk", 'String'>
    readonly chunkIndex: FieldRef<"VectorChunk", 'Int'>
    readonly chunkType: FieldRef<"VectorChunk", 'ChunkType'>
    readonly content: FieldRef<"VectorChunk", 'String'>
    readonly tokenCount: FieldRef<"VectorChunk", 'Int'>
    readonly pineconeId: FieldRef<"VectorChunk", 'String'>
    readonly pineconeNamespace: FieldRef<"VectorChunk", 'String'>
    readonly embeddingModel: FieldRef<"VectorChunk", 'String'>
    readonly vectorDimension: FieldRef<"VectorChunk", 'Int'>
    readonly overlappingChunks: FieldRef<"VectorChunk", 'String[]'>
    readonly semanticDensity: FieldRef<"VectorChunk", 'Decimal'>
    readonly retrievalFrequency: FieldRef<"VectorChunk", 'Int'>
    readonly lastRetrieved: FieldRef<"VectorChunk", 'DateTime'>
    readonly resourceId: FieldRef<"VectorChunk", 'String'>
    readonly summaryId: FieldRef<"VectorChunk", 'String'>
    readonly parentChunkId: FieldRef<"VectorChunk", 'String'>
    readonly createdAt: FieldRef<"VectorChunk", 'DateTime'>
    readonly updatedAt: FieldRef<"VectorChunk", 'DateTime'>
    readonly deletedAt: FieldRef<"VectorChunk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VectorChunk findUnique
   */
  export type VectorChunkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    /**
     * Filter, which VectorChunk to fetch.
     */
    where: VectorChunkWhereUniqueInput
  }

  /**
   * VectorChunk findUniqueOrThrow
   */
  export type VectorChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    /**
     * Filter, which VectorChunk to fetch.
     */
    where: VectorChunkWhereUniqueInput
  }

  /**
   * VectorChunk findFirst
   */
  export type VectorChunkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    /**
     * Filter, which VectorChunk to fetch.
     */
    where?: VectorChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VectorChunks to fetch.
     */
    orderBy?: VectorChunkOrderByWithRelationInput | VectorChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VectorChunks.
     */
    cursor?: VectorChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VectorChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VectorChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VectorChunks.
     */
    distinct?: VectorChunkScalarFieldEnum | VectorChunkScalarFieldEnum[]
  }

  /**
   * VectorChunk findFirstOrThrow
   */
  export type VectorChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    /**
     * Filter, which VectorChunk to fetch.
     */
    where?: VectorChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VectorChunks to fetch.
     */
    orderBy?: VectorChunkOrderByWithRelationInput | VectorChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VectorChunks.
     */
    cursor?: VectorChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VectorChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VectorChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VectorChunks.
     */
    distinct?: VectorChunkScalarFieldEnum | VectorChunkScalarFieldEnum[]
  }

  /**
   * VectorChunk findMany
   */
  export type VectorChunkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    /**
     * Filter, which VectorChunks to fetch.
     */
    where?: VectorChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VectorChunks to fetch.
     */
    orderBy?: VectorChunkOrderByWithRelationInput | VectorChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VectorChunks.
     */
    cursor?: VectorChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VectorChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VectorChunks.
     */
    skip?: number
    distinct?: VectorChunkScalarFieldEnum | VectorChunkScalarFieldEnum[]
  }

  /**
   * VectorChunk create
   */
  export type VectorChunkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a VectorChunk.
     */
    data: XOR<VectorChunkCreateInput, VectorChunkUncheckedCreateInput>
  }

  /**
   * VectorChunk createMany
   */
  export type VectorChunkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VectorChunks.
     */
    data: VectorChunkCreateManyInput | VectorChunkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VectorChunk createManyAndReturn
   */
  export type VectorChunkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * The data used to create many VectorChunks.
     */
    data: VectorChunkCreateManyInput | VectorChunkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VectorChunk update
   */
  export type VectorChunkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a VectorChunk.
     */
    data: XOR<VectorChunkUpdateInput, VectorChunkUncheckedUpdateInput>
    /**
     * Choose, which VectorChunk to update.
     */
    where: VectorChunkWhereUniqueInput
  }

  /**
   * VectorChunk updateMany
   */
  export type VectorChunkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VectorChunks.
     */
    data: XOR<VectorChunkUpdateManyMutationInput, VectorChunkUncheckedUpdateManyInput>
    /**
     * Filter which VectorChunks to update
     */
    where?: VectorChunkWhereInput
    /**
     * Limit how many VectorChunks to update.
     */
    limit?: number
  }

  /**
   * VectorChunk updateManyAndReturn
   */
  export type VectorChunkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * The data used to update VectorChunks.
     */
    data: XOR<VectorChunkUpdateManyMutationInput, VectorChunkUncheckedUpdateManyInput>
    /**
     * Filter which VectorChunks to update
     */
    where?: VectorChunkWhereInput
    /**
     * Limit how many VectorChunks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VectorChunk upsert
   */
  export type VectorChunkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the VectorChunk to update in case it exists.
     */
    where: VectorChunkWhereUniqueInput
    /**
     * In case the VectorChunk found by the `where` argument doesn't exist, create a new VectorChunk with this data.
     */
    create: XOR<VectorChunkCreateInput, VectorChunkUncheckedCreateInput>
    /**
     * In case the VectorChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VectorChunkUpdateInput, VectorChunkUncheckedUpdateInput>
  }

  /**
   * VectorChunk delete
   */
  export type VectorChunkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    /**
     * Filter which VectorChunk to delete.
     */
    where: VectorChunkWhereUniqueInput
  }

  /**
   * VectorChunk deleteMany
   */
  export type VectorChunkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VectorChunks to delete
     */
    where?: VectorChunkWhereInput
    /**
     * Limit how many VectorChunks to delete.
     */
    limit?: number
  }

  /**
   * VectorChunk.parentChunk
   */
  export type VectorChunk$parentChunkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    where?: VectorChunkWhereInput
  }

  /**
   * VectorChunk.childChunks
   */
  export type VectorChunk$childChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
    where?: VectorChunkWhereInput
    orderBy?: VectorChunkOrderByWithRelationInput | VectorChunkOrderByWithRelationInput[]
    cursor?: VectorChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VectorChunkScalarFieldEnum | VectorChunkScalarFieldEnum[]
  }

  /**
   * VectorChunk without action
   */
  export type VectorChunkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorChunk
     */
    select?: VectorChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorChunk
     */
    omit?: VectorChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorChunkInclude<ExtArgs> | null
  }


  /**
   * Model ContentRelationship
   */

  export type AggregateContentRelationship = {
    _count: ContentRelationshipCountAggregateOutputType | null
    _avg: ContentRelationshipAvgAggregateOutputType | null
    _sum: ContentRelationshipSumAggregateOutputType | null
    _min: ContentRelationshipMinAggregateOutputType | null
    _max: ContentRelationshipMaxAggregateOutputType | null
  }

  export type ContentRelationshipAvgAggregateOutputType = {
    confidenceScore: Decimal | null
  }

  export type ContentRelationshipSumAggregateOutputType = {
    confidenceScore: Decimal | null
  }

  export type ContentRelationshipMinAggregateOutputType = {
    id: string | null
    relationshipType: $Enums.RelationshipType | null
    confidenceScore: Decimal | null
    relationshipReason: string | null
    isAutoGenerated: boolean | null
    sourceResourceId: string | null
    targetResourceId: string | null
    createdBy: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type ContentRelationshipMaxAggregateOutputType = {
    id: string | null
    relationshipType: $Enums.RelationshipType | null
    confidenceScore: Decimal | null
    relationshipReason: string | null
    isAutoGenerated: boolean | null
    sourceResourceId: string | null
    targetResourceId: string | null
    createdBy: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type ContentRelationshipCountAggregateOutputType = {
    id: number
    relationshipType: number
    confidenceScore: number
    relationshipReason: number
    isAutoGenerated: number
    sourceResourceId: number
    targetResourceId: number
    createdBy: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type ContentRelationshipAvgAggregateInputType = {
    confidenceScore?: true
  }

  export type ContentRelationshipSumAggregateInputType = {
    confidenceScore?: true
  }

  export type ContentRelationshipMinAggregateInputType = {
    id?: true
    relationshipType?: true
    confidenceScore?: true
    relationshipReason?: true
    isAutoGenerated?: true
    sourceResourceId?: true
    targetResourceId?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
  }

  export type ContentRelationshipMaxAggregateInputType = {
    id?: true
    relationshipType?: true
    confidenceScore?: true
    relationshipReason?: true
    isAutoGenerated?: true
    sourceResourceId?: true
    targetResourceId?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
  }

  export type ContentRelationshipCountAggregateInputType = {
    id?: true
    relationshipType?: true
    confidenceScore?: true
    relationshipReason?: true
    isAutoGenerated?: true
    sourceResourceId?: true
    targetResourceId?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ContentRelationshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentRelationship to aggregate.
     */
    where?: ContentRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentRelationships to fetch.
     */
    orderBy?: ContentRelationshipOrderByWithRelationInput | ContentRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentRelationships
    **/
    _count?: true | ContentRelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentRelationshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentRelationshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentRelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentRelationshipMaxAggregateInputType
  }

  export type GetContentRelationshipAggregateType<T extends ContentRelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateContentRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentRelationship[P]>
      : GetScalarType<T[P], AggregateContentRelationship[P]>
  }




  export type ContentRelationshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentRelationshipWhereInput
    orderBy?: ContentRelationshipOrderByWithAggregationInput | ContentRelationshipOrderByWithAggregationInput[]
    by: ContentRelationshipScalarFieldEnum[] | ContentRelationshipScalarFieldEnum
    having?: ContentRelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentRelationshipCountAggregateInputType | true
    _avg?: ContentRelationshipAvgAggregateInputType
    _sum?: ContentRelationshipSumAggregateInputType
    _min?: ContentRelationshipMinAggregateInputType
    _max?: ContentRelationshipMaxAggregateInputType
  }

  export type ContentRelationshipGroupByOutputType = {
    id: string
    relationshipType: $Enums.RelationshipType
    confidenceScore: Decimal
    relationshipReason: string | null
    isAutoGenerated: boolean
    sourceResourceId: string
    targetResourceId: string
    createdBy: string | null
    createdAt: Date
    deletedAt: Date | null
    _count: ContentRelationshipCountAggregateOutputType | null
    _avg: ContentRelationshipAvgAggregateOutputType | null
    _sum: ContentRelationshipSumAggregateOutputType | null
    _min: ContentRelationshipMinAggregateOutputType | null
    _max: ContentRelationshipMaxAggregateOutputType | null
  }

  type GetContentRelationshipGroupByPayload<T extends ContentRelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentRelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentRelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentRelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], ContentRelationshipGroupByOutputType[P]>
        }
      >
    >


  export type ContentRelationshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipType?: boolean
    confidenceScore?: boolean
    relationshipReason?: boolean
    isAutoGenerated?: boolean
    sourceResourceId?: boolean
    targetResourceId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    sourceResource?: boolean | ResourceDefaultArgs<ExtArgs>
    targetResource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ContentRelationship$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["contentRelationship"]>

  export type ContentRelationshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipType?: boolean
    confidenceScore?: boolean
    relationshipReason?: boolean
    isAutoGenerated?: boolean
    sourceResourceId?: boolean
    targetResourceId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    sourceResource?: boolean | ResourceDefaultArgs<ExtArgs>
    targetResource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ContentRelationship$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["contentRelationship"]>

  export type ContentRelationshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipType?: boolean
    confidenceScore?: boolean
    relationshipReason?: boolean
    isAutoGenerated?: boolean
    sourceResourceId?: boolean
    targetResourceId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    sourceResource?: boolean | ResourceDefaultArgs<ExtArgs>
    targetResource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ContentRelationship$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["contentRelationship"]>

  export type ContentRelationshipSelectScalar = {
    id?: boolean
    relationshipType?: boolean
    confidenceScore?: boolean
    relationshipReason?: boolean
    isAutoGenerated?: boolean
    sourceResourceId?: boolean
    targetResourceId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type ContentRelationshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "relationshipType" | "confidenceScore" | "relationshipReason" | "isAutoGenerated" | "sourceResourceId" | "targetResourceId" | "createdBy" | "createdAt" | "deletedAt", ExtArgs["result"]["contentRelationship"]>
  export type ContentRelationshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceResource?: boolean | ResourceDefaultArgs<ExtArgs>
    targetResource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ContentRelationship$creatorArgs<ExtArgs>
  }
  export type ContentRelationshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceResource?: boolean | ResourceDefaultArgs<ExtArgs>
    targetResource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ContentRelationship$creatorArgs<ExtArgs>
  }
  export type ContentRelationshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceResource?: boolean | ResourceDefaultArgs<ExtArgs>
    targetResource?: boolean | ResourceDefaultArgs<ExtArgs>
    creator?: boolean | ContentRelationship$creatorArgs<ExtArgs>
  }

  export type $ContentRelationshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentRelationship"
    objects: {
      sourceResource: Prisma.$ResourcePayload<ExtArgs>
      targetResource: Prisma.$ResourcePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationshipType: $Enums.RelationshipType
      confidenceScore: Prisma.Decimal
      relationshipReason: string | null
      isAutoGenerated: boolean
      sourceResourceId: string
      targetResourceId: string
      createdBy: string | null
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["contentRelationship"]>
    composites: {}
  }

  type ContentRelationshipGetPayload<S extends boolean | null | undefined | ContentRelationshipDefaultArgs> = $Result.GetResult<Prisma.$ContentRelationshipPayload, S>

  type ContentRelationshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentRelationshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentRelationshipCountAggregateInputType | true
    }

  export interface ContentRelationshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentRelationship'], meta: { name: 'ContentRelationship' } }
    /**
     * Find zero or one ContentRelationship that matches the filter.
     * @param {ContentRelationshipFindUniqueArgs} args - Arguments to find a ContentRelationship
     * @example
     * // Get one ContentRelationship
     * const contentRelationship = await prisma.contentRelationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentRelationshipFindUniqueArgs>(args: SelectSubset<T, ContentRelationshipFindUniqueArgs<ExtArgs>>): Prisma__ContentRelationshipClient<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentRelationship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentRelationshipFindUniqueOrThrowArgs} args - Arguments to find a ContentRelationship
     * @example
     * // Get one ContentRelationship
     * const contentRelationship = await prisma.contentRelationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentRelationshipFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentRelationshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentRelationshipClient<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentRelationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRelationshipFindFirstArgs} args - Arguments to find a ContentRelationship
     * @example
     * // Get one ContentRelationship
     * const contentRelationship = await prisma.contentRelationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentRelationshipFindFirstArgs>(args?: SelectSubset<T, ContentRelationshipFindFirstArgs<ExtArgs>>): Prisma__ContentRelationshipClient<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentRelationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRelationshipFindFirstOrThrowArgs} args - Arguments to find a ContentRelationship
     * @example
     * // Get one ContentRelationship
     * const contentRelationship = await prisma.contentRelationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentRelationshipFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentRelationshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentRelationshipClient<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentRelationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRelationshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentRelationships
     * const contentRelationships = await prisma.contentRelationship.findMany()
     * 
     * // Get first 10 ContentRelationships
     * const contentRelationships = await prisma.contentRelationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentRelationshipWithIdOnly = await prisma.contentRelationship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentRelationshipFindManyArgs>(args?: SelectSubset<T, ContentRelationshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentRelationship.
     * @param {ContentRelationshipCreateArgs} args - Arguments to create a ContentRelationship.
     * @example
     * // Create one ContentRelationship
     * const ContentRelationship = await prisma.contentRelationship.create({
     *   data: {
     *     // ... data to create a ContentRelationship
     *   }
     * })
     * 
     */
    create<T extends ContentRelationshipCreateArgs>(args: SelectSubset<T, ContentRelationshipCreateArgs<ExtArgs>>): Prisma__ContentRelationshipClient<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentRelationships.
     * @param {ContentRelationshipCreateManyArgs} args - Arguments to create many ContentRelationships.
     * @example
     * // Create many ContentRelationships
     * const contentRelationship = await prisma.contentRelationship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentRelationshipCreateManyArgs>(args?: SelectSubset<T, ContentRelationshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentRelationships and returns the data saved in the database.
     * @param {ContentRelationshipCreateManyAndReturnArgs} args - Arguments to create many ContentRelationships.
     * @example
     * // Create many ContentRelationships
     * const contentRelationship = await prisma.contentRelationship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentRelationships and only return the `id`
     * const contentRelationshipWithIdOnly = await prisma.contentRelationship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentRelationshipCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentRelationshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentRelationship.
     * @param {ContentRelationshipDeleteArgs} args - Arguments to delete one ContentRelationship.
     * @example
     * // Delete one ContentRelationship
     * const ContentRelationship = await prisma.contentRelationship.delete({
     *   where: {
     *     // ... filter to delete one ContentRelationship
     *   }
     * })
     * 
     */
    delete<T extends ContentRelationshipDeleteArgs>(args: SelectSubset<T, ContentRelationshipDeleteArgs<ExtArgs>>): Prisma__ContentRelationshipClient<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentRelationship.
     * @param {ContentRelationshipUpdateArgs} args - Arguments to update one ContentRelationship.
     * @example
     * // Update one ContentRelationship
     * const contentRelationship = await prisma.contentRelationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentRelationshipUpdateArgs>(args: SelectSubset<T, ContentRelationshipUpdateArgs<ExtArgs>>): Prisma__ContentRelationshipClient<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentRelationships.
     * @param {ContentRelationshipDeleteManyArgs} args - Arguments to filter ContentRelationships to delete.
     * @example
     * // Delete a few ContentRelationships
     * const { count } = await prisma.contentRelationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentRelationshipDeleteManyArgs>(args?: SelectSubset<T, ContentRelationshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentRelationships
     * const contentRelationship = await prisma.contentRelationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentRelationshipUpdateManyArgs>(args: SelectSubset<T, ContentRelationshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentRelationships and returns the data updated in the database.
     * @param {ContentRelationshipUpdateManyAndReturnArgs} args - Arguments to update many ContentRelationships.
     * @example
     * // Update many ContentRelationships
     * const contentRelationship = await prisma.contentRelationship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentRelationships and only return the `id`
     * const contentRelationshipWithIdOnly = await prisma.contentRelationship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentRelationshipUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentRelationshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentRelationship.
     * @param {ContentRelationshipUpsertArgs} args - Arguments to update or create a ContentRelationship.
     * @example
     * // Update or create a ContentRelationship
     * const contentRelationship = await prisma.contentRelationship.upsert({
     *   create: {
     *     // ... data to create a ContentRelationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentRelationship we want to update
     *   }
     * })
     */
    upsert<T extends ContentRelationshipUpsertArgs>(args: SelectSubset<T, ContentRelationshipUpsertArgs<ExtArgs>>): Prisma__ContentRelationshipClient<$Result.GetResult<Prisma.$ContentRelationshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRelationshipCountArgs} args - Arguments to filter ContentRelationships to count.
     * @example
     * // Count the number of ContentRelationships
     * const count = await prisma.contentRelationship.count({
     *   where: {
     *     // ... the filter for the ContentRelationships we want to count
     *   }
     * })
    **/
    count<T extends ContentRelationshipCountArgs>(
      args?: Subset<T, ContentRelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentRelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentRelationshipAggregateArgs>(args: Subset<T, ContentRelationshipAggregateArgs>): Prisma.PrismaPromise<GetContentRelationshipAggregateType<T>>

    /**
     * Group by ContentRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentRelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentRelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentRelationshipGroupByArgs['orderBy'] }
        : { orderBy?: ContentRelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentRelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentRelationship model
   */
  readonly fields: ContentRelationshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentRelationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentRelationshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceResource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetResource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends ContentRelationship$creatorArgs<ExtArgs> = {}>(args?: Subset<T, ContentRelationship$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentRelationship model
   */
  interface ContentRelationshipFieldRefs {
    readonly id: FieldRef<"ContentRelationship", 'String'>
    readonly relationshipType: FieldRef<"ContentRelationship", 'RelationshipType'>
    readonly confidenceScore: FieldRef<"ContentRelationship", 'Decimal'>
    readonly relationshipReason: FieldRef<"ContentRelationship", 'String'>
    readonly isAutoGenerated: FieldRef<"ContentRelationship", 'Boolean'>
    readonly sourceResourceId: FieldRef<"ContentRelationship", 'String'>
    readonly targetResourceId: FieldRef<"ContentRelationship", 'String'>
    readonly createdBy: FieldRef<"ContentRelationship", 'String'>
    readonly createdAt: FieldRef<"ContentRelationship", 'DateTime'>
    readonly deletedAt: FieldRef<"ContentRelationship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentRelationship findUnique
   */
  export type ContentRelationshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ContentRelationship to fetch.
     */
    where: ContentRelationshipWhereUniqueInput
  }

  /**
   * ContentRelationship findUniqueOrThrow
   */
  export type ContentRelationshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ContentRelationship to fetch.
     */
    where: ContentRelationshipWhereUniqueInput
  }

  /**
   * ContentRelationship findFirst
   */
  export type ContentRelationshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ContentRelationship to fetch.
     */
    where?: ContentRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentRelationships to fetch.
     */
    orderBy?: ContentRelationshipOrderByWithRelationInput | ContentRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentRelationships.
     */
    cursor?: ContentRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentRelationships.
     */
    distinct?: ContentRelationshipScalarFieldEnum | ContentRelationshipScalarFieldEnum[]
  }

  /**
   * ContentRelationship findFirstOrThrow
   */
  export type ContentRelationshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ContentRelationship to fetch.
     */
    where?: ContentRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentRelationships to fetch.
     */
    orderBy?: ContentRelationshipOrderByWithRelationInput | ContentRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentRelationships.
     */
    cursor?: ContentRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentRelationships.
     */
    distinct?: ContentRelationshipScalarFieldEnum | ContentRelationshipScalarFieldEnum[]
  }

  /**
   * ContentRelationship findMany
   */
  export type ContentRelationshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ContentRelationships to fetch.
     */
    where?: ContentRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentRelationships to fetch.
     */
    orderBy?: ContentRelationshipOrderByWithRelationInput | ContentRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentRelationships.
     */
    cursor?: ContentRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentRelationships.
     */
    skip?: number
    distinct?: ContentRelationshipScalarFieldEnum | ContentRelationshipScalarFieldEnum[]
  }

  /**
   * ContentRelationship create
   */
  export type ContentRelationshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentRelationship.
     */
    data: XOR<ContentRelationshipCreateInput, ContentRelationshipUncheckedCreateInput>
  }

  /**
   * ContentRelationship createMany
   */
  export type ContentRelationshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentRelationships.
     */
    data: ContentRelationshipCreateManyInput | ContentRelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentRelationship createManyAndReturn
   */
  export type ContentRelationshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * The data used to create many ContentRelationships.
     */
    data: ContentRelationshipCreateManyInput | ContentRelationshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentRelationship update
   */
  export type ContentRelationshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentRelationship.
     */
    data: XOR<ContentRelationshipUpdateInput, ContentRelationshipUncheckedUpdateInput>
    /**
     * Choose, which ContentRelationship to update.
     */
    where: ContentRelationshipWhereUniqueInput
  }

  /**
   * ContentRelationship updateMany
   */
  export type ContentRelationshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentRelationships.
     */
    data: XOR<ContentRelationshipUpdateManyMutationInput, ContentRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which ContentRelationships to update
     */
    where?: ContentRelationshipWhereInput
    /**
     * Limit how many ContentRelationships to update.
     */
    limit?: number
  }

  /**
   * ContentRelationship updateManyAndReturn
   */
  export type ContentRelationshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * The data used to update ContentRelationships.
     */
    data: XOR<ContentRelationshipUpdateManyMutationInput, ContentRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which ContentRelationships to update
     */
    where?: ContentRelationshipWhereInput
    /**
     * Limit how many ContentRelationships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentRelationship upsert
   */
  export type ContentRelationshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentRelationship to update in case it exists.
     */
    where: ContentRelationshipWhereUniqueInput
    /**
     * In case the ContentRelationship found by the `where` argument doesn't exist, create a new ContentRelationship with this data.
     */
    create: XOR<ContentRelationshipCreateInput, ContentRelationshipUncheckedCreateInput>
    /**
     * In case the ContentRelationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentRelationshipUpdateInput, ContentRelationshipUncheckedUpdateInput>
  }

  /**
   * ContentRelationship delete
   */
  export type ContentRelationshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
    /**
     * Filter which ContentRelationship to delete.
     */
    where: ContentRelationshipWhereUniqueInput
  }

  /**
   * ContentRelationship deleteMany
   */
  export type ContentRelationshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentRelationships to delete
     */
    where?: ContentRelationshipWhereInput
    /**
     * Limit how many ContentRelationships to delete.
     */
    limit?: number
  }

  /**
   * ContentRelationship.creator
   */
  export type ContentRelationship$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ContentRelationship without action
   */
  export type ContentRelationshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentRelationship
     */
    select?: ContentRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentRelationship
     */
    omit?: ContentRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentRelationshipInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeNode
   */

  export type AggregateKnowledgeNode = {
    _count: KnowledgeNodeCountAggregateOutputType | null
    _avg: KnowledgeNodeAvgAggregateOutputType | null
    _sum: KnowledgeNodeSumAggregateOutputType | null
    _min: KnowledgeNodeMinAggregateOutputType | null
    _max: KnowledgeNodeMaxAggregateOutputType | null
  }

  export type KnowledgeNodeAvgAggregateOutputType = {
    importanceScore: number | null
    mentionFrequency: number | null
  }

  export type KnowledgeNodeSumAggregateOutputType = {
    importanceScore: number | null
    mentionFrequency: number | null
  }

  export type KnowledgeNodeMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    domain: $Enums.ContentDomain | null
    importanceScore: number | null
    mentionFrequency: number | null
    firstMentionedDate: Date | null
    lastMentionedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type KnowledgeNodeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    domain: $Enums.ContentDomain | null
    importanceScore: number | null
    mentionFrequency: number | null
    firstMentionedDate: Date | null
    lastMentionedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type KnowledgeNodeCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    domain: number
    importanceScore: number
    mentionFrequency: number
    mentionedInResources: number
    firstMentionedDate: number
    lastMentionedDate: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type KnowledgeNodeAvgAggregateInputType = {
    importanceScore?: true
    mentionFrequency?: true
  }

  export type KnowledgeNodeSumAggregateInputType = {
    importanceScore?: true
    mentionFrequency?: true
  }

  export type KnowledgeNodeMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    domain?: true
    importanceScore?: true
    mentionFrequency?: true
    firstMentionedDate?: true
    lastMentionedDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type KnowledgeNodeMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    domain?: true
    importanceScore?: true
    mentionFrequency?: true
    firstMentionedDate?: true
    lastMentionedDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type KnowledgeNodeCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    domain?: true
    importanceScore?: true
    mentionFrequency?: true
    mentionedInResources?: true
    firstMentionedDate?: true
    lastMentionedDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type KnowledgeNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeNode to aggregate.
     */
    where?: KnowledgeNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeNodes to fetch.
     */
    orderBy?: KnowledgeNodeOrderByWithRelationInput | KnowledgeNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeNodes
    **/
    _count?: true | KnowledgeNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeNodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeNodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeNodeMaxAggregateInputType
  }

  export type GetKnowledgeNodeAggregateType<T extends KnowledgeNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeNode[P]>
      : GetScalarType<T[P], AggregateKnowledgeNode[P]>
  }




  export type KnowledgeNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeNodeWhereInput
    orderBy?: KnowledgeNodeOrderByWithAggregationInput | KnowledgeNodeOrderByWithAggregationInput[]
    by: KnowledgeNodeScalarFieldEnum[] | KnowledgeNodeScalarFieldEnum
    having?: KnowledgeNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeNodeCountAggregateInputType | true
    _avg?: KnowledgeNodeAvgAggregateInputType
    _sum?: KnowledgeNodeSumAggregateInputType
    _min?: KnowledgeNodeMinAggregateInputType
    _max?: KnowledgeNodeMaxAggregateInputType
  }

  export type KnowledgeNodeGroupByOutputType = {
    id: string
    name: string
    type: string
    description: string | null
    domain: $Enums.ContentDomain | null
    importanceScore: number
    mentionFrequency: number
    mentionedInResources: string[]
    firstMentionedDate: Date
    lastMentionedDate: Date
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: KnowledgeNodeCountAggregateOutputType | null
    _avg: KnowledgeNodeAvgAggregateOutputType | null
    _sum: KnowledgeNodeSumAggregateOutputType | null
    _min: KnowledgeNodeMinAggregateOutputType | null
    _max: KnowledgeNodeMaxAggregateOutputType | null
  }

  type GetKnowledgeNodeGroupByPayload<T extends KnowledgeNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeNodeGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeNodeGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    domain?: boolean
    importanceScore?: boolean
    mentionFrequency?: boolean
    mentionedInResources?: boolean
    firstMentionedDate?: boolean
    lastMentionedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    sourceKnowledgeEdges?: boolean | KnowledgeNode$sourceKnowledgeEdgesArgs<ExtArgs>
    targetKnowledgeEdges?: boolean | KnowledgeNode$targetKnowledgeEdgesArgs<ExtArgs>
    _count?: boolean | KnowledgeNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeNode"]>

  export type KnowledgeNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    domain?: boolean
    importanceScore?: boolean
    mentionFrequency?: boolean
    mentionedInResources?: boolean
    firstMentionedDate?: boolean
    lastMentionedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["knowledgeNode"]>

  export type KnowledgeNodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    domain?: boolean
    importanceScore?: boolean
    mentionFrequency?: boolean
    mentionedInResources?: boolean
    firstMentionedDate?: boolean
    lastMentionedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["knowledgeNode"]>

  export type KnowledgeNodeSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    domain?: boolean
    importanceScore?: boolean
    mentionFrequency?: boolean
    mentionedInResources?: boolean
    firstMentionedDate?: boolean
    lastMentionedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type KnowledgeNodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "description" | "domain" | "importanceScore" | "mentionFrequency" | "mentionedInResources" | "firstMentionedDate" | "lastMentionedDate" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["knowledgeNode"]>
  export type KnowledgeNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceKnowledgeEdges?: boolean | KnowledgeNode$sourceKnowledgeEdgesArgs<ExtArgs>
    targetKnowledgeEdges?: boolean | KnowledgeNode$targetKnowledgeEdgesArgs<ExtArgs>
    _count?: boolean | KnowledgeNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KnowledgeNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type KnowledgeNodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KnowledgeNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeNode"
    objects: {
      sourceKnowledgeEdges: Prisma.$KnowledgeEdgePayload<ExtArgs>[]
      targetKnowledgeEdges: Prisma.$KnowledgeEdgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      description: string | null
      domain: $Enums.ContentDomain | null
      importanceScore: number
      mentionFrequency: number
      mentionedInResources: string[]
      firstMentionedDate: Date
      lastMentionedDate: Date
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["knowledgeNode"]>
    composites: {}
  }

  type KnowledgeNodeGetPayload<S extends boolean | null | undefined | KnowledgeNodeDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeNodePayload, S>

  type KnowledgeNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeNodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeNodeCountAggregateInputType | true
    }

  export interface KnowledgeNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeNode'], meta: { name: 'KnowledgeNode' } }
    /**
     * Find zero or one KnowledgeNode that matches the filter.
     * @param {KnowledgeNodeFindUniqueArgs} args - Arguments to find a KnowledgeNode
     * @example
     * // Get one KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeNodeFindUniqueArgs>(args: SelectSubset<T, KnowledgeNodeFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeNode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeNodeFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeNode
     * @example
     * // Get one KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeFindFirstArgs} args - Arguments to find a KnowledgeNode
     * @example
     * // Get one KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeNodeFindFirstArgs>(args?: SelectSubset<T, KnowledgeNodeFindFirstArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeFindFirstOrThrowArgs} args - Arguments to find a KnowledgeNode
     * @example
     * // Get one KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeNodes
     * const knowledgeNodes = await prisma.knowledgeNode.findMany()
     * 
     * // Get first 10 KnowledgeNodes
     * const knowledgeNodes = await prisma.knowledgeNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeNodeWithIdOnly = await prisma.knowledgeNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeNodeFindManyArgs>(args?: SelectSubset<T, KnowledgeNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeNode.
     * @param {KnowledgeNodeCreateArgs} args - Arguments to create a KnowledgeNode.
     * @example
     * // Create one KnowledgeNode
     * const KnowledgeNode = await prisma.knowledgeNode.create({
     *   data: {
     *     // ... data to create a KnowledgeNode
     *   }
     * })
     * 
     */
    create<T extends KnowledgeNodeCreateArgs>(args: SelectSubset<T, KnowledgeNodeCreateArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeNodes.
     * @param {KnowledgeNodeCreateManyArgs} args - Arguments to create many KnowledgeNodes.
     * @example
     * // Create many KnowledgeNodes
     * const knowledgeNode = await prisma.knowledgeNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeNodeCreateManyArgs>(args?: SelectSubset<T, KnowledgeNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeNodes and returns the data saved in the database.
     * @param {KnowledgeNodeCreateManyAndReturnArgs} args - Arguments to create many KnowledgeNodes.
     * @example
     * // Create many KnowledgeNodes
     * const knowledgeNode = await prisma.knowledgeNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeNodes and only return the `id`
     * const knowledgeNodeWithIdOnly = await prisma.knowledgeNode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeNode.
     * @param {KnowledgeNodeDeleteArgs} args - Arguments to delete one KnowledgeNode.
     * @example
     * // Delete one KnowledgeNode
     * const KnowledgeNode = await prisma.knowledgeNode.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeNode
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeNodeDeleteArgs>(args: SelectSubset<T, KnowledgeNodeDeleteArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeNode.
     * @param {KnowledgeNodeUpdateArgs} args - Arguments to update one KnowledgeNode.
     * @example
     * // Update one KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeNodeUpdateArgs>(args: SelectSubset<T, KnowledgeNodeUpdateArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeNodes.
     * @param {KnowledgeNodeDeleteManyArgs} args - Arguments to filter KnowledgeNodes to delete.
     * @example
     * // Delete a few KnowledgeNodes
     * const { count } = await prisma.knowledgeNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeNodeDeleteManyArgs>(args?: SelectSubset<T, KnowledgeNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeNodes
     * const knowledgeNode = await prisma.knowledgeNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeNodeUpdateManyArgs>(args: SelectSubset<T, KnowledgeNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeNodes and returns the data updated in the database.
     * @param {KnowledgeNodeUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeNodes.
     * @example
     * // Update many KnowledgeNodes
     * const knowledgeNode = await prisma.knowledgeNode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeNodes and only return the `id`
     * const knowledgeNodeWithIdOnly = await prisma.knowledgeNode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeNodeUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeNodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeNode.
     * @param {KnowledgeNodeUpsertArgs} args - Arguments to update or create a KnowledgeNode.
     * @example
     * // Update or create a KnowledgeNode
     * const knowledgeNode = await prisma.knowledgeNode.upsert({
     *   create: {
     *     // ... data to create a KnowledgeNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeNode we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeNodeUpsertArgs>(args: SelectSubset<T, KnowledgeNodeUpsertArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeCountArgs} args - Arguments to filter KnowledgeNodes to count.
     * @example
     * // Count the number of KnowledgeNodes
     * const count = await prisma.knowledgeNode.count({
     *   where: {
     *     // ... the filter for the KnowledgeNodes we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeNodeCountArgs>(
      args?: Subset<T, KnowledgeNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeNodeAggregateArgs>(args: Subset<T, KnowledgeNodeAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeNodeAggregateType<T>>

    /**
     * Group by KnowledgeNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeNodeGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeNode model
   */
  readonly fields: KnowledgeNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceKnowledgeEdges<T extends KnowledgeNode$sourceKnowledgeEdgesArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeNode$sourceKnowledgeEdgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    targetKnowledgeEdges<T extends KnowledgeNode$targetKnowledgeEdgesArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeNode$targetKnowledgeEdgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeNode model
   */
  interface KnowledgeNodeFieldRefs {
    readonly id: FieldRef<"KnowledgeNode", 'String'>
    readonly name: FieldRef<"KnowledgeNode", 'String'>
    readonly type: FieldRef<"KnowledgeNode", 'String'>
    readonly description: FieldRef<"KnowledgeNode", 'String'>
    readonly domain: FieldRef<"KnowledgeNode", 'ContentDomain'>
    readonly importanceScore: FieldRef<"KnowledgeNode", 'Int'>
    readonly mentionFrequency: FieldRef<"KnowledgeNode", 'Int'>
    readonly mentionedInResources: FieldRef<"KnowledgeNode", 'String[]'>
    readonly firstMentionedDate: FieldRef<"KnowledgeNode", 'DateTime'>
    readonly lastMentionedDate: FieldRef<"KnowledgeNode", 'DateTime'>
    readonly createdAt: FieldRef<"KnowledgeNode", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeNode", 'DateTime'>
    readonly deletedAt: FieldRef<"KnowledgeNode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeNode findUnique
   */
  export type KnowledgeNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeNode to fetch.
     */
    where: KnowledgeNodeWhereUniqueInput
  }

  /**
   * KnowledgeNode findUniqueOrThrow
   */
  export type KnowledgeNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeNode to fetch.
     */
    where: KnowledgeNodeWhereUniqueInput
  }

  /**
   * KnowledgeNode findFirst
   */
  export type KnowledgeNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeNode to fetch.
     */
    where?: KnowledgeNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeNodes to fetch.
     */
    orderBy?: KnowledgeNodeOrderByWithRelationInput | KnowledgeNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeNodes.
     */
    cursor?: KnowledgeNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeNodes.
     */
    distinct?: KnowledgeNodeScalarFieldEnum | KnowledgeNodeScalarFieldEnum[]
  }

  /**
   * KnowledgeNode findFirstOrThrow
   */
  export type KnowledgeNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeNode to fetch.
     */
    where?: KnowledgeNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeNodes to fetch.
     */
    orderBy?: KnowledgeNodeOrderByWithRelationInput | KnowledgeNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeNodes.
     */
    cursor?: KnowledgeNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeNodes.
     */
    distinct?: KnowledgeNodeScalarFieldEnum | KnowledgeNodeScalarFieldEnum[]
  }

  /**
   * KnowledgeNode findMany
   */
  export type KnowledgeNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeNodes to fetch.
     */
    where?: KnowledgeNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeNodes to fetch.
     */
    orderBy?: KnowledgeNodeOrderByWithRelationInput | KnowledgeNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeNodes.
     */
    cursor?: KnowledgeNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeNodes.
     */
    skip?: number
    distinct?: KnowledgeNodeScalarFieldEnum | KnowledgeNodeScalarFieldEnum[]
  }

  /**
   * KnowledgeNode create
   */
  export type KnowledgeNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeNode.
     */
    data: XOR<KnowledgeNodeCreateInput, KnowledgeNodeUncheckedCreateInput>
  }

  /**
   * KnowledgeNode createMany
   */
  export type KnowledgeNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeNodes.
     */
    data: KnowledgeNodeCreateManyInput | KnowledgeNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeNode createManyAndReturn
   */
  export type KnowledgeNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeNodes.
     */
    data: KnowledgeNodeCreateManyInput | KnowledgeNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeNode update
   */
  export type KnowledgeNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeNode.
     */
    data: XOR<KnowledgeNodeUpdateInput, KnowledgeNodeUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeNode to update.
     */
    where: KnowledgeNodeWhereUniqueInput
  }

  /**
   * KnowledgeNode updateMany
   */
  export type KnowledgeNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeNodes.
     */
    data: XOR<KnowledgeNodeUpdateManyMutationInput, KnowledgeNodeUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeNodes to update
     */
    where?: KnowledgeNodeWhereInput
    /**
     * Limit how many KnowledgeNodes to update.
     */
    limit?: number
  }

  /**
   * KnowledgeNode updateManyAndReturn
   */
  export type KnowledgeNodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeNodes.
     */
    data: XOR<KnowledgeNodeUpdateManyMutationInput, KnowledgeNodeUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeNodes to update
     */
    where?: KnowledgeNodeWhereInput
    /**
     * Limit how many KnowledgeNodes to update.
     */
    limit?: number
  }

  /**
   * KnowledgeNode upsert
   */
  export type KnowledgeNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeNode to update in case it exists.
     */
    where: KnowledgeNodeWhereUniqueInput
    /**
     * In case the KnowledgeNode found by the `where` argument doesn't exist, create a new KnowledgeNode with this data.
     */
    create: XOR<KnowledgeNodeCreateInput, KnowledgeNodeUncheckedCreateInput>
    /**
     * In case the KnowledgeNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeNodeUpdateInput, KnowledgeNodeUncheckedUpdateInput>
  }

  /**
   * KnowledgeNode delete
   */
  export type KnowledgeNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeNode to delete.
     */
    where: KnowledgeNodeWhereUniqueInput
  }

  /**
   * KnowledgeNode deleteMany
   */
  export type KnowledgeNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeNodes to delete
     */
    where?: KnowledgeNodeWhereInput
    /**
     * Limit how many KnowledgeNodes to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeNode.sourceKnowledgeEdges
   */
  export type KnowledgeNode$sourceKnowledgeEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    where?: KnowledgeEdgeWhereInput
    orderBy?: KnowledgeEdgeOrderByWithRelationInput | KnowledgeEdgeOrderByWithRelationInput[]
    cursor?: KnowledgeEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeEdgeScalarFieldEnum | KnowledgeEdgeScalarFieldEnum[]
  }

  /**
   * KnowledgeNode.targetKnowledgeEdges
   */
  export type KnowledgeNode$targetKnowledgeEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    where?: KnowledgeEdgeWhereInput
    orderBy?: KnowledgeEdgeOrderByWithRelationInput | KnowledgeEdgeOrderByWithRelationInput[]
    cursor?: KnowledgeEdgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeEdgeScalarFieldEnum | KnowledgeEdgeScalarFieldEnum[]
  }

  /**
   * KnowledgeNode without action
   */
  export type KnowledgeNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeNode
     */
    select?: KnowledgeNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeNode
     */
    omit?: KnowledgeNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeNodeInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeEdge
   */

  export type AggregateKnowledgeEdge = {
    _count: KnowledgeEdgeCountAggregateOutputType | null
    _avg: KnowledgeEdgeAvgAggregateOutputType | null
    _sum: KnowledgeEdgeSumAggregateOutputType | null
    _min: KnowledgeEdgeMinAggregateOutputType | null
    _max: KnowledgeEdgeMaxAggregateOutputType | null
  }

  export type KnowledgeEdgeAvgAggregateOutputType = {
    strength: Decimal | null
  }

  export type KnowledgeEdgeSumAggregateOutputType = {
    strength: Decimal | null
  }

  export type KnowledgeEdgeMinAggregateOutputType = {
    id: string | null
    relationshipType: $Enums.RelationshipType | null
    strength: Decimal | null
    isAutoGenerated: boolean | null
    sourceNodeId: string | null
    targetNodeId: string | null
    createdBy: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type KnowledgeEdgeMaxAggregateOutputType = {
    id: string | null
    relationshipType: $Enums.RelationshipType | null
    strength: Decimal | null
    isAutoGenerated: boolean | null
    sourceNodeId: string | null
    targetNodeId: string | null
    createdBy: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type KnowledgeEdgeCountAggregateOutputType = {
    id: number
    relationshipType: number
    strength: number
    evidenceResources: number
    isAutoGenerated: number
    sourceNodeId: number
    targetNodeId: number
    createdBy: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type KnowledgeEdgeAvgAggregateInputType = {
    strength?: true
  }

  export type KnowledgeEdgeSumAggregateInputType = {
    strength?: true
  }

  export type KnowledgeEdgeMinAggregateInputType = {
    id?: true
    relationshipType?: true
    strength?: true
    isAutoGenerated?: true
    sourceNodeId?: true
    targetNodeId?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
  }

  export type KnowledgeEdgeMaxAggregateInputType = {
    id?: true
    relationshipType?: true
    strength?: true
    isAutoGenerated?: true
    sourceNodeId?: true
    targetNodeId?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
  }

  export type KnowledgeEdgeCountAggregateInputType = {
    id?: true
    relationshipType?: true
    strength?: true
    evidenceResources?: true
    isAutoGenerated?: true
    sourceNodeId?: true
    targetNodeId?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type KnowledgeEdgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeEdge to aggregate.
     */
    where?: KnowledgeEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeEdges to fetch.
     */
    orderBy?: KnowledgeEdgeOrderByWithRelationInput | KnowledgeEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeEdges
    **/
    _count?: true | KnowledgeEdgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeEdgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeEdgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeEdgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeEdgeMaxAggregateInputType
  }

  export type GetKnowledgeEdgeAggregateType<T extends KnowledgeEdgeAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeEdge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeEdge[P]>
      : GetScalarType<T[P], AggregateKnowledgeEdge[P]>
  }




  export type KnowledgeEdgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeEdgeWhereInput
    orderBy?: KnowledgeEdgeOrderByWithAggregationInput | KnowledgeEdgeOrderByWithAggregationInput[]
    by: KnowledgeEdgeScalarFieldEnum[] | KnowledgeEdgeScalarFieldEnum
    having?: KnowledgeEdgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeEdgeCountAggregateInputType | true
    _avg?: KnowledgeEdgeAvgAggregateInputType
    _sum?: KnowledgeEdgeSumAggregateInputType
    _min?: KnowledgeEdgeMinAggregateInputType
    _max?: KnowledgeEdgeMaxAggregateInputType
  }

  export type KnowledgeEdgeGroupByOutputType = {
    id: string
    relationshipType: $Enums.RelationshipType
    strength: Decimal
    evidenceResources: string[]
    isAutoGenerated: boolean
    sourceNodeId: string
    targetNodeId: string
    createdBy: string | null
    createdAt: Date
    deletedAt: Date | null
    _count: KnowledgeEdgeCountAggregateOutputType | null
    _avg: KnowledgeEdgeAvgAggregateOutputType | null
    _sum: KnowledgeEdgeSumAggregateOutputType | null
    _min: KnowledgeEdgeMinAggregateOutputType | null
    _max: KnowledgeEdgeMaxAggregateOutputType | null
  }

  type GetKnowledgeEdgeGroupByPayload<T extends KnowledgeEdgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeEdgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeEdgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeEdgeGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeEdgeGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeEdgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipType?: boolean
    strength?: boolean
    evidenceResources?: boolean
    isAutoGenerated?: boolean
    sourceNodeId?: boolean
    targetNodeId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    sourceNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    creator?: boolean | KnowledgeEdge$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeEdge"]>

  export type KnowledgeEdgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipType?: boolean
    strength?: boolean
    evidenceResources?: boolean
    isAutoGenerated?: boolean
    sourceNodeId?: boolean
    targetNodeId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    sourceNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    creator?: boolean | KnowledgeEdge$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeEdge"]>

  export type KnowledgeEdgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipType?: boolean
    strength?: boolean
    evidenceResources?: boolean
    isAutoGenerated?: boolean
    sourceNodeId?: boolean
    targetNodeId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    sourceNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    creator?: boolean | KnowledgeEdge$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeEdge"]>

  export type KnowledgeEdgeSelectScalar = {
    id?: boolean
    relationshipType?: boolean
    strength?: boolean
    evidenceResources?: boolean
    isAutoGenerated?: boolean
    sourceNodeId?: boolean
    targetNodeId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type KnowledgeEdgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "relationshipType" | "strength" | "evidenceResources" | "isAutoGenerated" | "sourceNodeId" | "targetNodeId" | "createdBy" | "createdAt" | "deletedAt", ExtArgs["result"]["knowledgeEdge"]>
  export type KnowledgeEdgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    creator?: boolean | KnowledgeEdge$creatorArgs<ExtArgs>
  }
  export type KnowledgeEdgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    creator?: boolean | KnowledgeEdge$creatorArgs<ExtArgs>
  }
  export type KnowledgeEdgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    targetNode?: boolean | KnowledgeNodeDefaultArgs<ExtArgs>
    creator?: boolean | KnowledgeEdge$creatorArgs<ExtArgs>
  }

  export type $KnowledgeEdgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeEdge"
    objects: {
      sourceNode: Prisma.$KnowledgeNodePayload<ExtArgs>
      targetNode: Prisma.$KnowledgeNodePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationshipType: $Enums.RelationshipType
      strength: Prisma.Decimal
      evidenceResources: string[]
      isAutoGenerated: boolean
      sourceNodeId: string
      targetNodeId: string
      createdBy: string | null
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["knowledgeEdge"]>
    composites: {}
  }

  type KnowledgeEdgeGetPayload<S extends boolean | null | undefined | KnowledgeEdgeDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeEdgePayload, S>

  type KnowledgeEdgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeEdgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeEdgeCountAggregateInputType | true
    }

  export interface KnowledgeEdgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeEdge'], meta: { name: 'KnowledgeEdge' } }
    /**
     * Find zero or one KnowledgeEdge that matches the filter.
     * @param {KnowledgeEdgeFindUniqueArgs} args - Arguments to find a KnowledgeEdge
     * @example
     * // Get one KnowledgeEdge
     * const knowledgeEdge = await prisma.knowledgeEdge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeEdgeFindUniqueArgs>(args: SelectSubset<T, KnowledgeEdgeFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeEdgeClient<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeEdge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeEdgeFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeEdge
     * @example
     * // Get one KnowledgeEdge
     * const knowledgeEdge = await prisma.knowledgeEdge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeEdgeFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeEdgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeEdgeClient<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeEdge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeEdgeFindFirstArgs} args - Arguments to find a KnowledgeEdge
     * @example
     * // Get one KnowledgeEdge
     * const knowledgeEdge = await prisma.knowledgeEdge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeEdgeFindFirstArgs>(args?: SelectSubset<T, KnowledgeEdgeFindFirstArgs<ExtArgs>>): Prisma__KnowledgeEdgeClient<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeEdge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeEdgeFindFirstOrThrowArgs} args - Arguments to find a KnowledgeEdge
     * @example
     * // Get one KnowledgeEdge
     * const knowledgeEdge = await prisma.knowledgeEdge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeEdgeFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeEdgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeEdgeClient<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeEdges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeEdgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeEdges
     * const knowledgeEdges = await prisma.knowledgeEdge.findMany()
     * 
     * // Get first 10 KnowledgeEdges
     * const knowledgeEdges = await prisma.knowledgeEdge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeEdgeWithIdOnly = await prisma.knowledgeEdge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeEdgeFindManyArgs>(args?: SelectSubset<T, KnowledgeEdgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeEdge.
     * @param {KnowledgeEdgeCreateArgs} args - Arguments to create a KnowledgeEdge.
     * @example
     * // Create one KnowledgeEdge
     * const KnowledgeEdge = await prisma.knowledgeEdge.create({
     *   data: {
     *     // ... data to create a KnowledgeEdge
     *   }
     * })
     * 
     */
    create<T extends KnowledgeEdgeCreateArgs>(args: SelectSubset<T, KnowledgeEdgeCreateArgs<ExtArgs>>): Prisma__KnowledgeEdgeClient<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeEdges.
     * @param {KnowledgeEdgeCreateManyArgs} args - Arguments to create many KnowledgeEdges.
     * @example
     * // Create many KnowledgeEdges
     * const knowledgeEdge = await prisma.knowledgeEdge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeEdgeCreateManyArgs>(args?: SelectSubset<T, KnowledgeEdgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeEdges and returns the data saved in the database.
     * @param {KnowledgeEdgeCreateManyAndReturnArgs} args - Arguments to create many KnowledgeEdges.
     * @example
     * // Create many KnowledgeEdges
     * const knowledgeEdge = await prisma.knowledgeEdge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeEdges and only return the `id`
     * const knowledgeEdgeWithIdOnly = await prisma.knowledgeEdge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeEdgeCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeEdgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeEdge.
     * @param {KnowledgeEdgeDeleteArgs} args - Arguments to delete one KnowledgeEdge.
     * @example
     * // Delete one KnowledgeEdge
     * const KnowledgeEdge = await prisma.knowledgeEdge.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeEdge
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeEdgeDeleteArgs>(args: SelectSubset<T, KnowledgeEdgeDeleteArgs<ExtArgs>>): Prisma__KnowledgeEdgeClient<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeEdge.
     * @param {KnowledgeEdgeUpdateArgs} args - Arguments to update one KnowledgeEdge.
     * @example
     * // Update one KnowledgeEdge
     * const knowledgeEdge = await prisma.knowledgeEdge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeEdgeUpdateArgs>(args: SelectSubset<T, KnowledgeEdgeUpdateArgs<ExtArgs>>): Prisma__KnowledgeEdgeClient<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeEdges.
     * @param {KnowledgeEdgeDeleteManyArgs} args - Arguments to filter KnowledgeEdges to delete.
     * @example
     * // Delete a few KnowledgeEdges
     * const { count } = await prisma.knowledgeEdge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeEdgeDeleteManyArgs>(args?: SelectSubset<T, KnowledgeEdgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeEdges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeEdgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeEdges
     * const knowledgeEdge = await prisma.knowledgeEdge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeEdgeUpdateManyArgs>(args: SelectSubset<T, KnowledgeEdgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeEdges and returns the data updated in the database.
     * @param {KnowledgeEdgeUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeEdges.
     * @example
     * // Update many KnowledgeEdges
     * const knowledgeEdge = await prisma.knowledgeEdge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeEdges and only return the `id`
     * const knowledgeEdgeWithIdOnly = await prisma.knowledgeEdge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeEdgeUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeEdgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeEdge.
     * @param {KnowledgeEdgeUpsertArgs} args - Arguments to update or create a KnowledgeEdge.
     * @example
     * // Update or create a KnowledgeEdge
     * const knowledgeEdge = await prisma.knowledgeEdge.upsert({
     *   create: {
     *     // ... data to create a KnowledgeEdge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeEdge we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeEdgeUpsertArgs>(args: SelectSubset<T, KnowledgeEdgeUpsertArgs<ExtArgs>>): Prisma__KnowledgeEdgeClient<$Result.GetResult<Prisma.$KnowledgeEdgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeEdges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeEdgeCountArgs} args - Arguments to filter KnowledgeEdges to count.
     * @example
     * // Count the number of KnowledgeEdges
     * const count = await prisma.knowledgeEdge.count({
     *   where: {
     *     // ... the filter for the KnowledgeEdges we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeEdgeCountArgs>(
      args?: Subset<T, KnowledgeEdgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeEdgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeEdge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeEdgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeEdgeAggregateArgs>(args: Subset<T, KnowledgeEdgeAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeEdgeAggregateType<T>>

    /**
     * Group by KnowledgeEdge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeEdgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeEdgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeEdgeGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeEdgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeEdgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeEdgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeEdge model
   */
  readonly fields: KnowledgeEdgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeEdge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeEdgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceNode<T extends KnowledgeNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeNodeDefaultArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetNode<T extends KnowledgeNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeNodeDefaultArgs<ExtArgs>>): Prisma__KnowledgeNodeClient<$Result.GetResult<Prisma.$KnowledgeNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends KnowledgeEdge$creatorArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeEdge$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeEdge model
   */
  interface KnowledgeEdgeFieldRefs {
    readonly id: FieldRef<"KnowledgeEdge", 'String'>
    readonly relationshipType: FieldRef<"KnowledgeEdge", 'RelationshipType'>
    readonly strength: FieldRef<"KnowledgeEdge", 'Decimal'>
    readonly evidenceResources: FieldRef<"KnowledgeEdge", 'String[]'>
    readonly isAutoGenerated: FieldRef<"KnowledgeEdge", 'Boolean'>
    readonly sourceNodeId: FieldRef<"KnowledgeEdge", 'String'>
    readonly targetNodeId: FieldRef<"KnowledgeEdge", 'String'>
    readonly createdBy: FieldRef<"KnowledgeEdge", 'String'>
    readonly createdAt: FieldRef<"KnowledgeEdge", 'DateTime'>
    readonly deletedAt: FieldRef<"KnowledgeEdge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeEdge findUnique
   */
  export type KnowledgeEdgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeEdge to fetch.
     */
    where: KnowledgeEdgeWhereUniqueInput
  }

  /**
   * KnowledgeEdge findUniqueOrThrow
   */
  export type KnowledgeEdgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeEdge to fetch.
     */
    where: KnowledgeEdgeWhereUniqueInput
  }

  /**
   * KnowledgeEdge findFirst
   */
  export type KnowledgeEdgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeEdge to fetch.
     */
    where?: KnowledgeEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeEdges to fetch.
     */
    orderBy?: KnowledgeEdgeOrderByWithRelationInput | KnowledgeEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeEdges.
     */
    cursor?: KnowledgeEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeEdges.
     */
    distinct?: KnowledgeEdgeScalarFieldEnum | KnowledgeEdgeScalarFieldEnum[]
  }

  /**
   * KnowledgeEdge findFirstOrThrow
   */
  export type KnowledgeEdgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeEdge to fetch.
     */
    where?: KnowledgeEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeEdges to fetch.
     */
    orderBy?: KnowledgeEdgeOrderByWithRelationInput | KnowledgeEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeEdges.
     */
    cursor?: KnowledgeEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeEdges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeEdges.
     */
    distinct?: KnowledgeEdgeScalarFieldEnum | KnowledgeEdgeScalarFieldEnum[]
  }

  /**
   * KnowledgeEdge findMany
   */
  export type KnowledgeEdgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeEdges to fetch.
     */
    where?: KnowledgeEdgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeEdges to fetch.
     */
    orderBy?: KnowledgeEdgeOrderByWithRelationInput | KnowledgeEdgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeEdges.
     */
    cursor?: KnowledgeEdgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeEdges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeEdges.
     */
    skip?: number
    distinct?: KnowledgeEdgeScalarFieldEnum | KnowledgeEdgeScalarFieldEnum[]
  }

  /**
   * KnowledgeEdge create
   */
  export type KnowledgeEdgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeEdge.
     */
    data: XOR<KnowledgeEdgeCreateInput, KnowledgeEdgeUncheckedCreateInput>
  }

  /**
   * KnowledgeEdge createMany
   */
  export type KnowledgeEdgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeEdges.
     */
    data: KnowledgeEdgeCreateManyInput | KnowledgeEdgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeEdge createManyAndReturn
   */
  export type KnowledgeEdgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeEdges.
     */
    data: KnowledgeEdgeCreateManyInput | KnowledgeEdgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeEdge update
   */
  export type KnowledgeEdgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeEdge.
     */
    data: XOR<KnowledgeEdgeUpdateInput, KnowledgeEdgeUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeEdge to update.
     */
    where: KnowledgeEdgeWhereUniqueInput
  }

  /**
   * KnowledgeEdge updateMany
   */
  export type KnowledgeEdgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeEdges.
     */
    data: XOR<KnowledgeEdgeUpdateManyMutationInput, KnowledgeEdgeUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeEdges to update
     */
    where?: KnowledgeEdgeWhereInput
    /**
     * Limit how many KnowledgeEdges to update.
     */
    limit?: number
  }

  /**
   * KnowledgeEdge updateManyAndReturn
   */
  export type KnowledgeEdgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeEdges.
     */
    data: XOR<KnowledgeEdgeUpdateManyMutationInput, KnowledgeEdgeUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeEdges to update
     */
    where?: KnowledgeEdgeWhereInput
    /**
     * Limit how many KnowledgeEdges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeEdge upsert
   */
  export type KnowledgeEdgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeEdge to update in case it exists.
     */
    where: KnowledgeEdgeWhereUniqueInput
    /**
     * In case the KnowledgeEdge found by the `where` argument doesn't exist, create a new KnowledgeEdge with this data.
     */
    create: XOR<KnowledgeEdgeCreateInput, KnowledgeEdgeUncheckedCreateInput>
    /**
     * In case the KnowledgeEdge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeEdgeUpdateInput, KnowledgeEdgeUncheckedUpdateInput>
  }

  /**
   * KnowledgeEdge delete
   */
  export type KnowledgeEdgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeEdge to delete.
     */
    where: KnowledgeEdgeWhereUniqueInput
  }

  /**
   * KnowledgeEdge deleteMany
   */
  export type KnowledgeEdgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeEdges to delete
     */
    where?: KnowledgeEdgeWhereInput
    /**
     * Limit how many KnowledgeEdges to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeEdge.creator
   */
  export type KnowledgeEdge$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * KnowledgeEdge without action
   */
  export type KnowledgeEdgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeEdge
     */
    select?: KnowledgeEdgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeEdge
     */
    omit?: KnowledgeEdgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeEdgeInclude<ExtArgs> | null
  }


  /**
   * Model SearchQuery
   */

  export type AggregateSearchQuery = {
    _count: SearchQueryCountAggregateOutputType | null
    _avg: SearchQueryAvgAggregateOutputType | null
    _sum: SearchQuerySumAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  export type SearchQueryAvgAggregateOutputType = {
    resultsCount: number | null
    avgRelevanceScore: Decimal | null
    responseTimeMs: number | null
    userSatisfaction: number | null
  }

  export type SearchQuerySumAggregateOutputType = {
    resultsCount: number | null
    avgRelevanceScore: Decimal | null
    responseTimeMs: number | null
    userSatisfaction: number | null
  }

  export type SearchQueryMinAggregateOutputType = {
    id: string | null
    query: string | null
    queryType: string | null
    resultsCount: number | null
    avgRelevanceScore: Decimal | null
    extractedIntent: string | null
    domainClassification: $Enums.ContentDomain | null
    complexityDetected: $Enums.ComplexityLevel | null
    responseTimeMs: number | null
    userSatisfaction: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type SearchQueryMaxAggregateOutputType = {
    id: string | null
    query: string | null
    queryType: string | null
    resultsCount: number | null
    avgRelevanceScore: Decimal | null
    extractedIntent: string | null
    domainClassification: $Enums.ContentDomain | null
    complexityDetected: $Enums.ComplexityLevel | null
    responseTimeMs: number | null
    userSatisfaction: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type SearchQueryCountAggregateOutputType = {
    id: number
    query: number
    queryType: number
    resultsCount: number
    avgRelevanceScore: number
    clickedResults: number
    extractedIntent: number
    domainClassification: number
    complexityDetected: number
    responseTimeMs: number
    userSatisfaction: number
    userId: number
    createdAt: number
    _all: number
  }


  export type SearchQueryAvgAggregateInputType = {
    resultsCount?: true
    avgRelevanceScore?: true
    responseTimeMs?: true
    userSatisfaction?: true
  }

  export type SearchQuerySumAggregateInputType = {
    resultsCount?: true
    avgRelevanceScore?: true
    responseTimeMs?: true
    userSatisfaction?: true
  }

  export type SearchQueryMinAggregateInputType = {
    id?: true
    query?: true
    queryType?: true
    resultsCount?: true
    avgRelevanceScore?: true
    extractedIntent?: true
    domainClassification?: true
    complexityDetected?: true
    responseTimeMs?: true
    userSatisfaction?: true
    userId?: true
    createdAt?: true
  }

  export type SearchQueryMaxAggregateInputType = {
    id?: true
    query?: true
    queryType?: true
    resultsCount?: true
    avgRelevanceScore?: true
    extractedIntent?: true
    domainClassification?: true
    complexityDetected?: true
    responseTimeMs?: true
    userSatisfaction?: true
    userId?: true
    createdAt?: true
  }

  export type SearchQueryCountAggregateInputType = {
    id?: true
    query?: true
    queryType?: true
    resultsCount?: true
    avgRelevanceScore?: true
    clickedResults?: true
    extractedIntent?: true
    domainClassification?: true
    complexityDetected?: true
    responseTimeMs?: true
    userSatisfaction?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type SearchQueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQuery to aggregate.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchQueries
    **/
    _count?: true | SearchQueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchQueryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchQuerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchQueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchQueryMaxAggregateInputType
  }

  export type GetSearchQueryAggregateType<T extends SearchQueryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchQuery[P]>
      : GetScalarType<T[P], AggregateSearchQuery[P]>
  }




  export type SearchQueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchQueryWhereInput
    orderBy?: SearchQueryOrderByWithAggregationInput | SearchQueryOrderByWithAggregationInput[]
    by: SearchQueryScalarFieldEnum[] | SearchQueryScalarFieldEnum
    having?: SearchQueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchQueryCountAggregateInputType | true
    _avg?: SearchQueryAvgAggregateInputType
    _sum?: SearchQuerySumAggregateInputType
    _min?: SearchQueryMinAggregateInputType
    _max?: SearchQueryMaxAggregateInputType
  }

  export type SearchQueryGroupByOutputType = {
    id: string
    query: string
    queryType: string
    resultsCount: number
    avgRelevanceScore: Decimal | null
    clickedResults: string[]
    extractedIntent: string | null
    domainClassification: $Enums.ContentDomain | null
    complexityDetected: $Enums.ComplexityLevel | null
    responseTimeMs: number | null
    userSatisfaction: number | null
    userId: string
    createdAt: Date
    _count: SearchQueryCountAggregateOutputType | null
    _avg: SearchQueryAvgAggregateOutputType | null
    _sum: SearchQuerySumAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  type GetSearchQueryGroupByPayload<T extends SearchQueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchQueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchQueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
        }
      >
    >


  export type SearchQuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    queryType?: boolean
    resultsCount?: boolean
    avgRelevanceScore?: boolean
    clickedResults?: boolean
    extractedIntent?: boolean
    domainClassification?: boolean
    complexityDetected?: boolean
    responseTimeMs?: boolean
    userSatisfaction?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    queryType?: boolean
    resultsCount?: boolean
    avgRelevanceScore?: boolean
    clickedResults?: boolean
    extractedIntent?: boolean
    domainClassification?: boolean
    complexityDetected?: boolean
    responseTimeMs?: boolean
    userSatisfaction?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    queryType?: boolean
    resultsCount?: boolean
    avgRelevanceScore?: boolean
    clickedResults?: boolean
    extractedIntent?: boolean
    domainClassification?: boolean
    complexityDetected?: boolean
    responseTimeMs?: boolean
    userSatisfaction?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchQuery"]>

  export type SearchQuerySelectScalar = {
    id?: boolean
    query?: boolean
    queryType?: boolean
    resultsCount?: boolean
    avgRelevanceScore?: boolean
    clickedResults?: boolean
    extractedIntent?: boolean
    domainClassification?: boolean
    complexityDetected?: boolean
    responseTimeMs?: boolean
    userSatisfaction?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type SearchQueryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "query" | "queryType" | "resultsCount" | "avgRelevanceScore" | "clickedResults" | "extractedIntent" | "domainClassification" | "complexityDetected" | "responseTimeMs" | "userSatisfaction" | "userId" | "createdAt", ExtArgs["result"]["searchQuery"]>
  export type SearchQueryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchQueryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SearchQueryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SearchQueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchQuery"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      query: string
      queryType: string
      resultsCount: number
      avgRelevanceScore: Prisma.Decimal | null
      clickedResults: string[]
      extractedIntent: string | null
      domainClassification: $Enums.ContentDomain | null
      complexityDetected: $Enums.ComplexityLevel | null
      responseTimeMs: number | null
      userSatisfaction: number | null
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["searchQuery"]>
    composites: {}
  }

  type SearchQueryGetPayload<S extends boolean | null | undefined | SearchQueryDefaultArgs> = $Result.GetResult<Prisma.$SearchQueryPayload, S>

  type SearchQueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchQueryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchQueryCountAggregateInputType | true
    }

  export interface SearchQueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchQuery'], meta: { name: 'SearchQuery' } }
    /**
     * Find zero or one SearchQuery that matches the filter.
     * @param {SearchQueryFindUniqueArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchQueryFindUniqueArgs>(args: SelectSubset<T, SearchQueryFindUniqueArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchQuery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchQueryFindUniqueOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchQueryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchQueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchQuery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchQueryFindFirstArgs>(args?: SelectSubset<T, SearchQueryFindFirstArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchQuery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchQueryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchQueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchQueries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany()
     * 
     * // Get first 10 SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchQueryFindManyArgs>(args?: SelectSubset<T, SearchQueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchQuery.
     * @param {SearchQueryCreateArgs} args - Arguments to create a SearchQuery.
     * @example
     * // Create one SearchQuery
     * const SearchQuery = await prisma.searchQuery.create({
     *   data: {
     *     // ... data to create a SearchQuery
     *   }
     * })
     * 
     */
    create<T extends SearchQueryCreateArgs>(args: SelectSubset<T, SearchQueryCreateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchQueries.
     * @param {SearchQueryCreateManyArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchQueryCreateManyArgs>(args?: SelectSubset<T, SearchQueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchQueries and returns the data saved in the database.
     * @param {SearchQueryCreateManyAndReturnArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchQueries and only return the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchQueryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchQueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchQuery.
     * @param {SearchQueryDeleteArgs} args - Arguments to delete one SearchQuery.
     * @example
     * // Delete one SearchQuery
     * const SearchQuery = await prisma.searchQuery.delete({
     *   where: {
     *     // ... filter to delete one SearchQuery
     *   }
     * })
     * 
     */
    delete<T extends SearchQueryDeleteArgs>(args: SelectSubset<T, SearchQueryDeleteArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchQuery.
     * @param {SearchQueryUpdateArgs} args - Arguments to update one SearchQuery.
     * @example
     * // Update one SearchQuery
     * const searchQuery = await prisma.searchQuery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchQueryUpdateArgs>(args: SelectSubset<T, SearchQueryUpdateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchQueries.
     * @param {SearchQueryDeleteManyArgs} args - Arguments to filter SearchQueries to delete.
     * @example
     * // Delete a few SearchQueries
     * const { count } = await prisma.searchQuery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchQueryDeleteManyArgs>(args?: SelectSubset<T, SearchQueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchQueries
     * const searchQuery = await prisma.searchQuery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchQueryUpdateManyArgs>(args: SelectSubset<T, SearchQueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchQueries and returns the data updated in the database.
     * @param {SearchQueryUpdateManyAndReturnArgs} args - Arguments to update many SearchQueries.
     * @example
     * // Update many SearchQueries
     * const searchQuery = await prisma.searchQuery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SearchQueries and only return the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SearchQueryUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchQueryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SearchQuery.
     * @param {SearchQueryUpsertArgs} args - Arguments to update or create a SearchQuery.
     * @example
     * // Update or create a SearchQuery
     * const searchQuery = await prisma.searchQuery.upsert({
     *   create: {
     *     // ... data to create a SearchQuery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchQuery we want to update
     *   }
     * })
     */
    upsert<T extends SearchQueryUpsertArgs>(args: SelectSubset<T, SearchQueryUpsertArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryCountArgs} args - Arguments to filter SearchQueries to count.
     * @example
     * // Count the number of SearchQueries
     * const count = await prisma.searchQuery.count({
     *   where: {
     *     // ... the filter for the SearchQueries we want to count
     *   }
     * })
    **/
    count<T extends SearchQueryCountArgs>(
      args?: Subset<T, SearchQueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchQueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchQueryAggregateArgs>(args: Subset<T, SearchQueryAggregateArgs>): Prisma.PrismaPromise<GetSearchQueryAggregateType<T>>

    /**
     * Group by SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchQueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchQueryGroupByArgs['orderBy'] }
        : { orderBy?: SearchQueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchQueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchQuery model
   */
  readonly fields: SearchQueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchQuery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchQueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchQuery model
   */
  interface SearchQueryFieldRefs {
    readonly id: FieldRef<"SearchQuery", 'String'>
    readonly query: FieldRef<"SearchQuery", 'String'>
    readonly queryType: FieldRef<"SearchQuery", 'String'>
    readonly resultsCount: FieldRef<"SearchQuery", 'Int'>
    readonly avgRelevanceScore: FieldRef<"SearchQuery", 'Decimal'>
    readonly clickedResults: FieldRef<"SearchQuery", 'String[]'>
    readonly extractedIntent: FieldRef<"SearchQuery", 'String'>
    readonly domainClassification: FieldRef<"SearchQuery", 'ContentDomain'>
    readonly complexityDetected: FieldRef<"SearchQuery", 'ComplexityLevel'>
    readonly responseTimeMs: FieldRef<"SearchQuery", 'Int'>
    readonly userSatisfaction: FieldRef<"SearchQuery", 'Int'>
    readonly userId: FieldRef<"SearchQuery", 'String'>
    readonly createdAt: FieldRef<"SearchQuery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchQuery findUnique
   */
  export type SearchQueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery findUniqueOrThrow
   */
  export type SearchQueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery findFirst
   */
  export type SearchQueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery findFirstOrThrow
   */
  export type SearchQueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery findMany
   */
  export type SearchQueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQueries to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery create
   */
  export type SearchQueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchQuery.
     */
    data: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
  }

  /**
   * SearchQuery createMany
   */
  export type SearchQueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchQuery createManyAndReturn
   */
  export type SearchQueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchQuery update
   */
  export type SearchQueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchQuery.
     */
    data: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
    /**
     * Choose, which SearchQuery to update.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery updateMany
   */
  export type SearchQueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchQueries.
     */
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyInput>
    /**
     * Filter which SearchQueries to update
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to update.
     */
    limit?: number
  }

  /**
   * SearchQuery updateManyAndReturn
   */
  export type SearchQueryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * The data used to update SearchQueries.
     */
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyInput>
    /**
     * Filter which SearchQueries to update
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchQuery upsert
   */
  export type SearchQueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchQuery to update in case it exists.
     */
    where: SearchQueryWhereUniqueInput
    /**
     * In case the SearchQuery found by the `where` argument doesn't exist, create a new SearchQuery with this data.
     */
    create: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
    /**
     * In case the SearchQuery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
  }

  /**
   * SearchQuery delete
   */
  export type SearchQueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter which SearchQuery to delete.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery deleteMany
   */
  export type SearchQueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQueries to delete
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to delete.
     */
    limit?: number
  }

  /**
   * SearchQuery without action
   */
  export type SearchQueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
  }


  /**
   * Model LearningAnalytic
   */

  export type AggregateLearningAnalytic = {
    _count: LearningAnalyticCountAggregateOutputType | null
    _avg: LearningAnalyticAvgAggregateOutputType | null
    _sum: LearningAnalyticSumAggregateOutputType | null
    _min: LearningAnalyticMinAggregateOutputType | null
    _max: LearningAnalyticMaxAggregateOutputType | null
  }

  export type LearningAnalyticAvgAggregateOutputType = {
    comprehensionLevel: number | null
    timeSpentSeconds: number | null
  }

  export type LearningAnalyticSumAggregateOutputType = {
    comprehensionLevel: number | null
    timeSpentSeconds: number | null
  }

  export type LearningAnalyticMinAggregateOutputType = {
    id: string | null
    eventType: string | null
    sessionId: string | null
    comprehensionLevel: number | null
    implementationStatus: $Enums.ImplementationStatus | null
    deviceType: string | null
    timeSpentSeconds: number | null
    referralSource: string | null
    userId: string | null
    resourceId: string | null
    createdAt: Date | null
  }

  export type LearningAnalyticMaxAggregateOutputType = {
    id: string | null
    eventType: string | null
    sessionId: string | null
    comprehensionLevel: number | null
    implementationStatus: $Enums.ImplementationStatus | null
    deviceType: string | null
    timeSpentSeconds: number | null
    referralSource: string | null
    userId: string | null
    resourceId: string | null
    createdAt: Date | null
  }

  export type LearningAnalyticCountAggregateOutputType = {
    id: number
    eventType: number
    eventDetails: number
    sessionId: number
    comprehensionLevel: number
    implementationStatus: number
    deviceType: number
    timeSpentSeconds: number
    referralSource: number
    userId: number
    resourceId: number
    createdAt: number
    _all: number
  }


  export type LearningAnalyticAvgAggregateInputType = {
    comprehensionLevel?: true
    timeSpentSeconds?: true
  }

  export type LearningAnalyticSumAggregateInputType = {
    comprehensionLevel?: true
    timeSpentSeconds?: true
  }

  export type LearningAnalyticMinAggregateInputType = {
    id?: true
    eventType?: true
    sessionId?: true
    comprehensionLevel?: true
    implementationStatus?: true
    deviceType?: true
    timeSpentSeconds?: true
    referralSource?: true
    userId?: true
    resourceId?: true
    createdAt?: true
  }

  export type LearningAnalyticMaxAggregateInputType = {
    id?: true
    eventType?: true
    sessionId?: true
    comprehensionLevel?: true
    implementationStatus?: true
    deviceType?: true
    timeSpentSeconds?: true
    referralSource?: true
    userId?: true
    resourceId?: true
    createdAt?: true
  }

  export type LearningAnalyticCountAggregateInputType = {
    id?: true
    eventType?: true
    eventDetails?: true
    sessionId?: true
    comprehensionLevel?: true
    implementationStatus?: true
    deviceType?: true
    timeSpentSeconds?: true
    referralSource?: true
    userId?: true
    resourceId?: true
    createdAt?: true
    _all?: true
  }

  export type LearningAnalyticAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningAnalytic to aggregate.
     */
    where?: LearningAnalyticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningAnalytics to fetch.
     */
    orderBy?: LearningAnalyticOrderByWithRelationInput | LearningAnalyticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningAnalyticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningAnalytics
    **/
    _count?: true | LearningAnalyticCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningAnalyticAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningAnalyticSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningAnalyticMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningAnalyticMaxAggregateInputType
  }

  export type GetLearningAnalyticAggregateType<T extends LearningAnalyticAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningAnalytic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningAnalytic[P]>
      : GetScalarType<T[P], AggregateLearningAnalytic[P]>
  }




  export type LearningAnalyticGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningAnalyticWhereInput
    orderBy?: LearningAnalyticOrderByWithAggregationInput | LearningAnalyticOrderByWithAggregationInput[]
    by: LearningAnalyticScalarFieldEnum[] | LearningAnalyticScalarFieldEnum
    having?: LearningAnalyticScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningAnalyticCountAggregateInputType | true
    _avg?: LearningAnalyticAvgAggregateInputType
    _sum?: LearningAnalyticSumAggregateInputType
    _min?: LearningAnalyticMinAggregateInputType
    _max?: LearningAnalyticMaxAggregateInputType
  }

  export type LearningAnalyticGroupByOutputType = {
    id: string
    eventType: string
    eventDetails: JsonValue
    sessionId: string | null
    comprehensionLevel: number | null
    implementationStatus: $Enums.ImplementationStatus | null
    deviceType: string | null
    timeSpentSeconds: number | null
    referralSource: string | null
    userId: string
    resourceId: string | null
    createdAt: Date
    _count: LearningAnalyticCountAggregateOutputType | null
    _avg: LearningAnalyticAvgAggregateOutputType | null
    _sum: LearningAnalyticSumAggregateOutputType | null
    _min: LearningAnalyticMinAggregateOutputType | null
    _max: LearningAnalyticMaxAggregateOutputType | null
  }

  type GetLearningAnalyticGroupByPayload<T extends LearningAnalyticGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningAnalyticGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningAnalyticGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningAnalyticGroupByOutputType[P]>
            : GetScalarType<T[P], LearningAnalyticGroupByOutputType[P]>
        }
      >
    >


  export type LearningAnalyticSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    eventDetails?: boolean
    sessionId?: boolean
    comprehensionLevel?: boolean
    implementationStatus?: boolean
    deviceType?: boolean
    timeSpentSeconds?: boolean
    referralSource?: boolean
    userId?: boolean
    resourceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | LearningAnalytic$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["learningAnalytic"]>

  export type LearningAnalyticSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    eventDetails?: boolean
    sessionId?: boolean
    comprehensionLevel?: boolean
    implementationStatus?: boolean
    deviceType?: boolean
    timeSpentSeconds?: boolean
    referralSource?: boolean
    userId?: boolean
    resourceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | LearningAnalytic$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["learningAnalytic"]>

  export type LearningAnalyticSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    eventDetails?: boolean
    sessionId?: boolean
    comprehensionLevel?: boolean
    implementationStatus?: boolean
    deviceType?: boolean
    timeSpentSeconds?: boolean
    referralSource?: boolean
    userId?: boolean
    resourceId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | LearningAnalytic$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["learningAnalytic"]>

  export type LearningAnalyticSelectScalar = {
    id?: boolean
    eventType?: boolean
    eventDetails?: boolean
    sessionId?: boolean
    comprehensionLevel?: boolean
    implementationStatus?: boolean
    deviceType?: boolean
    timeSpentSeconds?: boolean
    referralSource?: boolean
    userId?: boolean
    resourceId?: boolean
    createdAt?: boolean
  }

  export type LearningAnalyticOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventType" | "eventDetails" | "sessionId" | "comprehensionLevel" | "implementationStatus" | "deviceType" | "timeSpentSeconds" | "referralSource" | "userId" | "resourceId" | "createdAt", ExtArgs["result"]["learningAnalytic"]>
  export type LearningAnalyticInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | LearningAnalytic$resourceArgs<ExtArgs>
  }
  export type LearningAnalyticIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | LearningAnalytic$resourceArgs<ExtArgs>
  }
  export type LearningAnalyticIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    resource?: boolean | LearningAnalytic$resourceArgs<ExtArgs>
  }

  export type $LearningAnalyticPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningAnalytic"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: string
      eventDetails: Prisma.JsonValue
      sessionId: string | null
      comprehensionLevel: number | null
      implementationStatus: $Enums.ImplementationStatus | null
      deviceType: string | null
      timeSpentSeconds: number | null
      referralSource: string | null
      userId: string
      resourceId: string | null
      createdAt: Date
    }, ExtArgs["result"]["learningAnalytic"]>
    composites: {}
  }

  type LearningAnalyticGetPayload<S extends boolean | null | undefined | LearningAnalyticDefaultArgs> = $Result.GetResult<Prisma.$LearningAnalyticPayload, S>

  type LearningAnalyticCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningAnalyticFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningAnalyticCountAggregateInputType | true
    }

  export interface LearningAnalyticDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningAnalytic'], meta: { name: 'LearningAnalytic' } }
    /**
     * Find zero or one LearningAnalytic that matches the filter.
     * @param {LearningAnalyticFindUniqueArgs} args - Arguments to find a LearningAnalytic
     * @example
     * // Get one LearningAnalytic
     * const learningAnalytic = await prisma.learningAnalytic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningAnalyticFindUniqueArgs>(args: SelectSubset<T, LearningAnalyticFindUniqueArgs<ExtArgs>>): Prisma__LearningAnalyticClient<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningAnalytic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningAnalyticFindUniqueOrThrowArgs} args - Arguments to find a LearningAnalytic
     * @example
     * // Get one LearningAnalytic
     * const learningAnalytic = await prisma.learningAnalytic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningAnalyticFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningAnalyticFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningAnalyticClient<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningAnalytic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningAnalyticFindFirstArgs} args - Arguments to find a LearningAnalytic
     * @example
     * // Get one LearningAnalytic
     * const learningAnalytic = await prisma.learningAnalytic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningAnalyticFindFirstArgs>(args?: SelectSubset<T, LearningAnalyticFindFirstArgs<ExtArgs>>): Prisma__LearningAnalyticClient<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningAnalytic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningAnalyticFindFirstOrThrowArgs} args - Arguments to find a LearningAnalytic
     * @example
     * // Get one LearningAnalytic
     * const learningAnalytic = await prisma.learningAnalytic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningAnalyticFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningAnalyticFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningAnalyticClient<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningAnalyticFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningAnalytics
     * const learningAnalytics = await prisma.learningAnalytic.findMany()
     * 
     * // Get first 10 LearningAnalytics
     * const learningAnalytics = await prisma.learningAnalytic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningAnalyticWithIdOnly = await prisma.learningAnalytic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningAnalyticFindManyArgs>(args?: SelectSubset<T, LearningAnalyticFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningAnalytic.
     * @param {LearningAnalyticCreateArgs} args - Arguments to create a LearningAnalytic.
     * @example
     * // Create one LearningAnalytic
     * const LearningAnalytic = await prisma.learningAnalytic.create({
     *   data: {
     *     // ... data to create a LearningAnalytic
     *   }
     * })
     * 
     */
    create<T extends LearningAnalyticCreateArgs>(args: SelectSubset<T, LearningAnalyticCreateArgs<ExtArgs>>): Prisma__LearningAnalyticClient<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningAnalytics.
     * @param {LearningAnalyticCreateManyArgs} args - Arguments to create many LearningAnalytics.
     * @example
     * // Create many LearningAnalytics
     * const learningAnalytic = await prisma.learningAnalytic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningAnalyticCreateManyArgs>(args?: SelectSubset<T, LearningAnalyticCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningAnalytics and returns the data saved in the database.
     * @param {LearningAnalyticCreateManyAndReturnArgs} args - Arguments to create many LearningAnalytics.
     * @example
     * // Create many LearningAnalytics
     * const learningAnalytic = await prisma.learningAnalytic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningAnalytics and only return the `id`
     * const learningAnalyticWithIdOnly = await prisma.learningAnalytic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningAnalyticCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningAnalyticCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningAnalytic.
     * @param {LearningAnalyticDeleteArgs} args - Arguments to delete one LearningAnalytic.
     * @example
     * // Delete one LearningAnalytic
     * const LearningAnalytic = await prisma.learningAnalytic.delete({
     *   where: {
     *     // ... filter to delete one LearningAnalytic
     *   }
     * })
     * 
     */
    delete<T extends LearningAnalyticDeleteArgs>(args: SelectSubset<T, LearningAnalyticDeleteArgs<ExtArgs>>): Prisma__LearningAnalyticClient<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningAnalytic.
     * @param {LearningAnalyticUpdateArgs} args - Arguments to update one LearningAnalytic.
     * @example
     * // Update one LearningAnalytic
     * const learningAnalytic = await prisma.learningAnalytic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningAnalyticUpdateArgs>(args: SelectSubset<T, LearningAnalyticUpdateArgs<ExtArgs>>): Prisma__LearningAnalyticClient<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningAnalytics.
     * @param {LearningAnalyticDeleteManyArgs} args - Arguments to filter LearningAnalytics to delete.
     * @example
     * // Delete a few LearningAnalytics
     * const { count } = await prisma.learningAnalytic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningAnalyticDeleteManyArgs>(args?: SelectSubset<T, LearningAnalyticDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningAnalyticUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningAnalytics
     * const learningAnalytic = await prisma.learningAnalytic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningAnalyticUpdateManyArgs>(args: SelectSubset<T, LearningAnalyticUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningAnalytics and returns the data updated in the database.
     * @param {LearningAnalyticUpdateManyAndReturnArgs} args - Arguments to update many LearningAnalytics.
     * @example
     * // Update many LearningAnalytics
     * const learningAnalytic = await prisma.learningAnalytic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningAnalytics and only return the `id`
     * const learningAnalyticWithIdOnly = await prisma.learningAnalytic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningAnalyticUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningAnalyticUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningAnalytic.
     * @param {LearningAnalyticUpsertArgs} args - Arguments to update or create a LearningAnalytic.
     * @example
     * // Update or create a LearningAnalytic
     * const learningAnalytic = await prisma.learningAnalytic.upsert({
     *   create: {
     *     // ... data to create a LearningAnalytic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningAnalytic we want to update
     *   }
     * })
     */
    upsert<T extends LearningAnalyticUpsertArgs>(args: SelectSubset<T, LearningAnalyticUpsertArgs<ExtArgs>>): Prisma__LearningAnalyticClient<$Result.GetResult<Prisma.$LearningAnalyticPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningAnalyticCountArgs} args - Arguments to filter LearningAnalytics to count.
     * @example
     * // Count the number of LearningAnalytics
     * const count = await prisma.learningAnalytic.count({
     *   where: {
     *     // ... the filter for the LearningAnalytics we want to count
     *   }
     * })
    **/
    count<T extends LearningAnalyticCountArgs>(
      args?: Subset<T, LearningAnalyticCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningAnalyticCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningAnalytic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningAnalyticAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningAnalyticAggregateArgs>(args: Subset<T, LearningAnalyticAggregateArgs>): Prisma.PrismaPromise<GetLearningAnalyticAggregateType<T>>

    /**
     * Group by LearningAnalytic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningAnalyticGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningAnalyticGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningAnalyticGroupByArgs['orderBy'] }
        : { orderBy?: LearningAnalyticGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningAnalyticGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningAnalyticGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningAnalytic model
   */
  readonly fields: LearningAnalyticFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningAnalytic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningAnalyticClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resource<T extends LearningAnalytic$resourceArgs<ExtArgs> = {}>(args?: Subset<T, LearningAnalytic$resourceArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningAnalytic model
   */
  interface LearningAnalyticFieldRefs {
    readonly id: FieldRef<"LearningAnalytic", 'String'>
    readonly eventType: FieldRef<"LearningAnalytic", 'String'>
    readonly eventDetails: FieldRef<"LearningAnalytic", 'Json'>
    readonly sessionId: FieldRef<"LearningAnalytic", 'String'>
    readonly comprehensionLevel: FieldRef<"LearningAnalytic", 'Int'>
    readonly implementationStatus: FieldRef<"LearningAnalytic", 'ImplementationStatus'>
    readonly deviceType: FieldRef<"LearningAnalytic", 'String'>
    readonly timeSpentSeconds: FieldRef<"LearningAnalytic", 'Int'>
    readonly referralSource: FieldRef<"LearningAnalytic", 'String'>
    readonly userId: FieldRef<"LearningAnalytic", 'String'>
    readonly resourceId: FieldRef<"LearningAnalytic", 'String'>
    readonly createdAt: FieldRef<"LearningAnalytic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningAnalytic findUnique
   */
  export type LearningAnalyticFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    /**
     * Filter, which LearningAnalytic to fetch.
     */
    where: LearningAnalyticWhereUniqueInput
  }

  /**
   * LearningAnalytic findUniqueOrThrow
   */
  export type LearningAnalyticFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    /**
     * Filter, which LearningAnalytic to fetch.
     */
    where: LearningAnalyticWhereUniqueInput
  }

  /**
   * LearningAnalytic findFirst
   */
  export type LearningAnalyticFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    /**
     * Filter, which LearningAnalytic to fetch.
     */
    where?: LearningAnalyticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningAnalytics to fetch.
     */
    orderBy?: LearningAnalyticOrderByWithRelationInput | LearningAnalyticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningAnalytics.
     */
    cursor?: LearningAnalyticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningAnalytics.
     */
    distinct?: LearningAnalyticScalarFieldEnum | LearningAnalyticScalarFieldEnum[]
  }

  /**
   * LearningAnalytic findFirstOrThrow
   */
  export type LearningAnalyticFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    /**
     * Filter, which LearningAnalytic to fetch.
     */
    where?: LearningAnalyticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningAnalytics to fetch.
     */
    orderBy?: LearningAnalyticOrderByWithRelationInput | LearningAnalyticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningAnalytics.
     */
    cursor?: LearningAnalyticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningAnalytics.
     */
    distinct?: LearningAnalyticScalarFieldEnum | LearningAnalyticScalarFieldEnum[]
  }

  /**
   * LearningAnalytic findMany
   */
  export type LearningAnalyticFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    /**
     * Filter, which LearningAnalytics to fetch.
     */
    where?: LearningAnalyticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningAnalytics to fetch.
     */
    orderBy?: LearningAnalyticOrderByWithRelationInput | LearningAnalyticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningAnalytics.
     */
    cursor?: LearningAnalyticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningAnalytics.
     */
    skip?: number
    distinct?: LearningAnalyticScalarFieldEnum | LearningAnalyticScalarFieldEnum[]
  }

  /**
   * LearningAnalytic create
   */
  export type LearningAnalyticCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningAnalytic.
     */
    data: XOR<LearningAnalyticCreateInput, LearningAnalyticUncheckedCreateInput>
  }

  /**
   * LearningAnalytic createMany
   */
  export type LearningAnalyticCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningAnalytics.
     */
    data: LearningAnalyticCreateManyInput | LearningAnalyticCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningAnalytic createManyAndReturn
   */
  export type LearningAnalyticCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * The data used to create many LearningAnalytics.
     */
    data: LearningAnalyticCreateManyInput | LearningAnalyticCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningAnalytic update
   */
  export type LearningAnalyticUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningAnalytic.
     */
    data: XOR<LearningAnalyticUpdateInput, LearningAnalyticUncheckedUpdateInput>
    /**
     * Choose, which LearningAnalytic to update.
     */
    where: LearningAnalyticWhereUniqueInput
  }

  /**
   * LearningAnalytic updateMany
   */
  export type LearningAnalyticUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningAnalytics.
     */
    data: XOR<LearningAnalyticUpdateManyMutationInput, LearningAnalyticUncheckedUpdateManyInput>
    /**
     * Filter which LearningAnalytics to update
     */
    where?: LearningAnalyticWhereInput
    /**
     * Limit how many LearningAnalytics to update.
     */
    limit?: number
  }

  /**
   * LearningAnalytic updateManyAndReturn
   */
  export type LearningAnalyticUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * The data used to update LearningAnalytics.
     */
    data: XOR<LearningAnalyticUpdateManyMutationInput, LearningAnalyticUncheckedUpdateManyInput>
    /**
     * Filter which LearningAnalytics to update
     */
    where?: LearningAnalyticWhereInput
    /**
     * Limit how many LearningAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningAnalytic upsert
   */
  export type LearningAnalyticUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningAnalytic to update in case it exists.
     */
    where: LearningAnalyticWhereUniqueInput
    /**
     * In case the LearningAnalytic found by the `where` argument doesn't exist, create a new LearningAnalytic with this data.
     */
    create: XOR<LearningAnalyticCreateInput, LearningAnalyticUncheckedCreateInput>
    /**
     * In case the LearningAnalytic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningAnalyticUpdateInput, LearningAnalyticUncheckedUpdateInput>
  }

  /**
   * LearningAnalytic delete
   */
  export type LearningAnalyticDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
    /**
     * Filter which LearningAnalytic to delete.
     */
    where: LearningAnalyticWhereUniqueInput
  }

  /**
   * LearningAnalytic deleteMany
   */
  export type LearningAnalyticDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningAnalytics to delete
     */
    where?: LearningAnalyticWhereInput
    /**
     * Limit how many LearningAnalytics to delete.
     */
    limit?: number
  }

  /**
   * LearningAnalytic.resource
   */
  export type LearningAnalytic$resourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
  }

  /**
   * LearningAnalytic without action
   */
  export type LearningAnalyticDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningAnalytic
     */
    select?: LearningAnalyticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningAnalytic
     */
    omit?: LearningAnalyticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningAnalyticInclude<ExtArgs> | null
  }


  /**
   * Model BatchJob
   */

  export type AggregateBatchJob = {
    _count: BatchJobCountAggregateOutputType | null
    _avg: BatchJobAvgAggregateOutputType | null
    _sum: BatchJobSumAggregateOutputType | null
    _min: BatchJobMinAggregateOutputType | null
    _max: BatchJobMaxAggregateOutputType | null
  }

  export type BatchJobAvgAggregateOutputType = {
    progress: number | null
    totalItems: number | null
  }

  export type BatchJobSumAggregateOutputType = {
    progress: number | null
    totalItems: number | null
  }

  export type BatchJobMinAggregateOutputType = {
    id: string | null
    status: $Enums.BatchJobStatus | null
    progress: number | null
    totalItems: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchJobMaxAggregateOutputType = {
    id: string | null
    status: $Enums.BatchJobStatus | null
    progress: number | null
    totalItems: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchJobCountAggregateOutputType = {
    id: number
    status: number
    progress: number
    totalItems: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchJobAvgAggregateInputType = {
    progress?: true
    totalItems?: true
  }

  export type BatchJobSumAggregateInputType = {
    progress?: true
    totalItems?: true
  }

  export type BatchJobMinAggregateInputType = {
    id?: true
    status?: true
    progress?: true
    totalItems?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchJobMaxAggregateInputType = {
    id?: true
    status?: true
    progress?: true
    totalItems?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchJobCountAggregateInputType = {
    id?: true
    status?: true
    progress?: true
    totalItems?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchJob to aggregate.
     */
    where?: BatchJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchJobs to fetch.
     */
    orderBy?: BatchJobOrderByWithRelationInput | BatchJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchJobs
    **/
    _count?: true | BatchJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchJobMaxAggregateInputType
  }

  export type GetBatchJobAggregateType<T extends BatchJobAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchJob[P]>
      : GetScalarType<T[P], AggregateBatchJob[P]>
  }




  export type BatchJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchJobWhereInput
    orderBy?: BatchJobOrderByWithAggregationInput | BatchJobOrderByWithAggregationInput[]
    by: BatchJobScalarFieldEnum[] | BatchJobScalarFieldEnum
    having?: BatchJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchJobCountAggregateInputType | true
    _avg?: BatchJobAvgAggregateInputType
    _sum?: BatchJobSumAggregateInputType
    _min?: BatchJobMinAggregateInputType
    _max?: BatchJobMaxAggregateInputType
  }

  export type BatchJobGroupByOutputType = {
    id: string
    status: $Enums.BatchJobStatus
    progress: number
    totalItems: number
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: BatchJobCountAggregateOutputType | null
    _avg: BatchJobAvgAggregateOutputType | null
    _sum: BatchJobSumAggregateOutputType | null
    _min: BatchJobMinAggregateOutputType | null
    _max: BatchJobMaxAggregateOutputType | null
  }

  type GetBatchJobGroupByPayload<T extends BatchJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchJobGroupByOutputType[P]>
            : GetScalarType<T[P], BatchJobGroupByOutputType[P]>
        }
      >
    >


  export type BatchJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    progress?: boolean
    totalItems?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchJob"]>

  export type BatchJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    progress?: boolean
    totalItems?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchJob"]>

  export type BatchJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    progress?: boolean
    totalItems?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchJob"]>

  export type BatchJobSelectScalar = {
    id?: boolean
    status?: boolean
    progress?: boolean
    totalItems?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "progress" | "totalItems" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["batchJob"]>
  export type BatchJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BatchJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BatchJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BatchJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchJob"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.BatchJobStatus
      progress: number
      totalItems: number
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batchJob"]>
    composites: {}
  }

  type BatchJobGetPayload<S extends boolean | null | undefined | BatchJobDefaultArgs> = $Result.GetResult<Prisma.$BatchJobPayload, S>

  type BatchJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchJobCountAggregateInputType | true
    }

  export interface BatchJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchJob'], meta: { name: 'BatchJob' } }
    /**
     * Find zero or one BatchJob that matches the filter.
     * @param {BatchJobFindUniqueArgs} args - Arguments to find a BatchJob
     * @example
     * // Get one BatchJob
     * const batchJob = await prisma.batchJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchJobFindUniqueArgs>(args: SelectSubset<T, BatchJobFindUniqueArgs<ExtArgs>>): Prisma__BatchJobClient<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BatchJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchJobFindUniqueOrThrowArgs} args - Arguments to find a BatchJob
     * @example
     * // Get one BatchJob
     * const batchJob = await prisma.batchJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchJobFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchJobClient<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchJobFindFirstArgs} args - Arguments to find a BatchJob
     * @example
     * // Get one BatchJob
     * const batchJob = await prisma.batchJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchJobFindFirstArgs>(args?: SelectSubset<T, BatchJobFindFirstArgs<ExtArgs>>): Prisma__BatchJobClient<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchJobFindFirstOrThrowArgs} args - Arguments to find a BatchJob
     * @example
     * // Get one BatchJob
     * const batchJob = await prisma.batchJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchJobFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchJobClient<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BatchJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchJobs
     * const batchJobs = await prisma.batchJob.findMany()
     * 
     * // Get first 10 BatchJobs
     * const batchJobs = await prisma.batchJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchJobWithIdOnly = await prisma.batchJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchJobFindManyArgs>(args?: SelectSubset<T, BatchJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BatchJob.
     * @param {BatchJobCreateArgs} args - Arguments to create a BatchJob.
     * @example
     * // Create one BatchJob
     * const BatchJob = await prisma.batchJob.create({
     *   data: {
     *     // ... data to create a BatchJob
     *   }
     * })
     * 
     */
    create<T extends BatchJobCreateArgs>(args: SelectSubset<T, BatchJobCreateArgs<ExtArgs>>): Prisma__BatchJobClient<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BatchJobs.
     * @param {BatchJobCreateManyArgs} args - Arguments to create many BatchJobs.
     * @example
     * // Create many BatchJobs
     * const batchJob = await prisma.batchJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchJobCreateManyArgs>(args?: SelectSubset<T, BatchJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchJobs and returns the data saved in the database.
     * @param {BatchJobCreateManyAndReturnArgs} args - Arguments to create many BatchJobs.
     * @example
     * // Create many BatchJobs
     * const batchJob = await prisma.batchJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchJobs and only return the `id`
     * const batchJobWithIdOnly = await prisma.batchJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchJobCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BatchJob.
     * @param {BatchJobDeleteArgs} args - Arguments to delete one BatchJob.
     * @example
     * // Delete one BatchJob
     * const BatchJob = await prisma.batchJob.delete({
     *   where: {
     *     // ... filter to delete one BatchJob
     *   }
     * })
     * 
     */
    delete<T extends BatchJobDeleteArgs>(args: SelectSubset<T, BatchJobDeleteArgs<ExtArgs>>): Prisma__BatchJobClient<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BatchJob.
     * @param {BatchJobUpdateArgs} args - Arguments to update one BatchJob.
     * @example
     * // Update one BatchJob
     * const batchJob = await prisma.batchJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchJobUpdateArgs>(args: SelectSubset<T, BatchJobUpdateArgs<ExtArgs>>): Prisma__BatchJobClient<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BatchJobs.
     * @param {BatchJobDeleteManyArgs} args - Arguments to filter BatchJobs to delete.
     * @example
     * // Delete a few BatchJobs
     * const { count } = await prisma.batchJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchJobDeleteManyArgs>(args?: SelectSubset<T, BatchJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchJobs
     * const batchJob = await prisma.batchJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchJobUpdateManyArgs>(args: SelectSubset<T, BatchJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchJobs and returns the data updated in the database.
     * @param {BatchJobUpdateManyAndReturnArgs} args - Arguments to update many BatchJobs.
     * @example
     * // Update many BatchJobs
     * const batchJob = await prisma.batchJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BatchJobs and only return the `id`
     * const batchJobWithIdOnly = await prisma.batchJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchJobUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BatchJob.
     * @param {BatchJobUpsertArgs} args - Arguments to update or create a BatchJob.
     * @example
     * // Update or create a BatchJob
     * const batchJob = await prisma.batchJob.upsert({
     *   create: {
     *     // ... data to create a BatchJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchJob we want to update
     *   }
     * })
     */
    upsert<T extends BatchJobUpsertArgs>(args: SelectSubset<T, BatchJobUpsertArgs<ExtArgs>>): Prisma__BatchJobClient<$Result.GetResult<Prisma.$BatchJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BatchJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchJobCountArgs} args - Arguments to filter BatchJobs to count.
     * @example
     * // Count the number of BatchJobs
     * const count = await prisma.batchJob.count({
     *   where: {
     *     // ... the filter for the BatchJobs we want to count
     *   }
     * })
    **/
    count<T extends BatchJobCountArgs>(
      args?: Subset<T, BatchJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchJobAggregateArgs>(args: Subset<T, BatchJobAggregateArgs>): Prisma.PrismaPromise<GetBatchJobAggregateType<T>>

    /**
     * Group by BatchJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchJobGroupByArgs['orderBy'] }
        : { orderBy?: BatchJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchJob model
   */
  readonly fields: BatchJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchJob model
   */
  interface BatchJobFieldRefs {
    readonly id: FieldRef<"BatchJob", 'String'>
    readonly status: FieldRef<"BatchJob", 'BatchJobStatus'>
    readonly progress: FieldRef<"BatchJob", 'Int'>
    readonly totalItems: FieldRef<"BatchJob", 'Int'>
    readonly userId: FieldRef<"BatchJob", 'String'>
    readonly createdAt: FieldRef<"BatchJob", 'DateTime'>
    readonly updatedAt: FieldRef<"BatchJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchJob findUnique
   */
  export type BatchJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
    /**
     * Filter, which BatchJob to fetch.
     */
    where: BatchJobWhereUniqueInput
  }

  /**
   * BatchJob findUniqueOrThrow
   */
  export type BatchJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
    /**
     * Filter, which BatchJob to fetch.
     */
    where: BatchJobWhereUniqueInput
  }

  /**
   * BatchJob findFirst
   */
  export type BatchJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
    /**
     * Filter, which BatchJob to fetch.
     */
    where?: BatchJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchJobs to fetch.
     */
    orderBy?: BatchJobOrderByWithRelationInput | BatchJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchJobs.
     */
    cursor?: BatchJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchJobs.
     */
    distinct?: BatchJobScalarFieldEnum | BatchJobScalarFieldEnum[]
  }

  /**
   * BatchJob findFirstOrThrow
   */
  export type BatchJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
    /**
     * Filter, which BatchJob to fetch.
     */
    where?: BatchJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchJobs to fetch.
     */
    orderBy?: BatchJobOrderByWithRelationInput | BatchJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchJobs.
     */
    cursor?: BatchJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchJobs.
     */
    distinct?: BatchJobScalarFieldEnum | BatchJobScalarFieldEnum[]
  }

  /**
   * BatchJob findMany
   */
  export type BatchJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
    /**
     * Filter, which BatchJobs to fetch.
     */
    where?: BatchJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchJobs to fetch.
     */
    orderBy?: BatchJobOrderByWithRelationInput | BatchJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchJobs.
     */
    cursor?: BatchJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchJobs.
     */
    skip?: number
    distinct?: BatchJobScalarFieldEnum | BatchJobScalarFieldEnum[]
  }

  /**
   * BatchJob create
   */
  export type BatchJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
    /**
     * The data needed to create a BatchJob.
     */
    data: XOR<BatchJobCreateInput, BatchJobUncheckedCreateInput>
  }

  /**
   * BatchJob createMany
   */
  export type BatchJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchJobs.
     */
    data: BatchJobCreateManyInput | BatchJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BatchJob createManyAndReturn
   */
  export type BatchJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * The data used to create many BatchJobs.
     */
    data: BatchJobCreateManyInput | BatchJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchJob update
   */
  export type BatchJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
    /**
     * The data needed to update a BatchJob.
     */
    data: XOR<BatchJobUpdateInput, BatchJobUncheckedUpdateInput>
    /**
     * Choose, which BatchJob to update.
     */
    where: BatchJobWhereUniqueInput
  }

  /**
   * BatchJob updateMany
   */
  export type BatchJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchJobs.
     */
    data: XOR<BatchJobUpdateManyMutationInput, BatchJobUncheckedUpdateManyInput>
    /**
     * Filter which BatchJobs to update
     */
    where?: BatchJobWhereInput
    /**
     * Limit how many BatchJobs to update.
     */
    limit?: number
  }

  /**
   * BatchJob updateManyAndReturn
   */
  export type BatchJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * The data used to update BatchJobs.
     */
    data: XOR<BatchJobUpdateManyMutationInput, BatchJobUncheckedUpdateManyInput>
    /**
     * Filter which BatchJobs to update
     */
    where?: BatchJobWhereInput
    /**
     * Limit how many BatchJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchJob upsert
   */
  export type BatchJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
    /**
     * The filter to search for the BatchJob to update in case it exists.
     */
    where: BatchJobWhereUniqueInput
    /**
     * In case the BatchJob found by the `where` argument doesn't exist, create a new BatchJob with this data.
     */
    create: XOR<BatchJobCreateInput, BatchJobUncheckedCreateInput>
    /**
     * In case the BatchJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchJobUpdateInput, BatchJobUncheckedUpdateInput>
  }

  /**
   * BatchJob delete
   */
  export type BatchJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
    /**
     * Filter which BatchJob to delete.
     */
    where: BatchJobWhereUniqueInput
  }

  /**
   * BatchJob deleteMany
   */
  export type BatchJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchJobs to delete
     */
    where?: BatchJobWhereInput
    /**
     * Limit how many BatchJobs to delete.
     */
    limit?: number
  }

  /**
   * BatchJob without action
   */
  export type BatchJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchJob
     */
    select?: BatchJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchJob
     */
    omit?: BatchJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchJobInclude<ExtArgs> | null
  }


  /**
   * Model PromptLog
   */

  export type AggregatePromptLog = {
    _count: PromptLogCountAggregateOutputType | null
    _avg: PromptLogAvgAggregateOutputType | null
    _sum: PromptLogSumAggregateOutputType | null
    _min: PromptLogMinAggregateOutputType | null
    _max: PromptLogMaxAggregateOutputType | null
  }

  export type PromptLogAvgAggregateOutputType = {
    latencyMs: number | null
  }

  export type PromptLogSumAggregateOutputType = {
    latencyMs: number | null
  }

  export type PromptLogMinAggregateOutputType = {
    id: string | null
    queryText: string | null
    tier: $Enums.PromptLogTier | null
    error: string | null
    latencyMs: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type PromptLogMaxAggregateOutputType = {
    id: string | null
    queryText: string | null
    tier: $Enums.PromptLogTier | null
    error: string | null
    latencyMs: number | null
    userId: string | null
    createdAt: Date | null
  }

  export type PromptLogCountAggregateOutputType = {
    id: number
    queryText: number
    tier: number
    response: number
    error: number
    latencyMs: number
    userId: number
    createdAt: number
    _all: number
  }


  export type PromptLogAvgAggregateInputType = {
    latencyMs?: true
  }

  export type PromptLogSumAggregateInputType = {
    latencyMs?: true
  }

  export type PromptLogMinAggregateInputType = {
    id?: true
    queryText?: true
    tier?: true
    error?: true
    latencyMs?: true
    userId?: true
    createdAt?: true
  }

  export type PromptLogMaxAggregateInputType = {
    id?: true
    queryText?: true
    tier?: true
    error?: true
    latencyMs?: true
    userId?: true
    createdAt?: true
  }

  export type PromptLogCountAggregateInputType = {
    id?: true
    queryText?: true
    tier?: true
    response?: true
    error?: true
    latencyMs?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type PromptLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptLog to aggregate.
     */
    where?: PromptLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptLogs to fetch.
     */
    orderBy?: PromptLogOrderByWithRelationInput | PromptLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromptLogs
    **/
    _count?: true | PromptLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromptLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromptLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptLogMaxAggregateInputType
  }

  export type GetPromptLogAggregateType<T extends PromptLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePromptLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromptLog[P]>
      : GetScalarType<T[P], AggregatePromptLog[P]>
  }




  export type PromptLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptLogWhereInput
    orderBy?: PromptLogOrderByWithAggregationInput | PromptLogOrderByWithAggregationInput[]
    by: PromptLogScalarFieldEnum[] | PromptLogScalarFieldEnum
    having?: PromptLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptLogCountAggregateInputType | true
    _avg?: PromptLogAvgAggregateInputType
    _sum?: PromptLogSumAggregateInputType
    _min?: PromptLogMinAggregateInputType
    _max?: PromptLogMaxAggregateInputType
  }

  export type PromptLogGroupByOutputType = {
    id: string
    queryText: string
    tier: $Enums.PromptLogTier
    response: JsonValue | null
    error: string | null
    latencyMs: number | null
    userId: string | null
    createdAt: Date
    _count: PromptLogCountAggregateOutputType | null
    _avg: PromptLogAvgAggregateOutputType | null
    _sum: PromptLogSumAggregateOutputType | null
    _min: PromptLogMinAggregateOutputType | null
    _max: PromptLogMaxAggregateOutputType | null
  }

  type GetPromptLogGroupByPayload<T extends PromptLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptLogGroupByOutputType[P]>
            : GetScalarType<T[P], PromptLogGroupByOutputType[P]>
        }
      >
    >


  export type PromptLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryText?: boolean
    tier?: boolean
    response?: boolean
    error?: boolean
    latencyMs?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | PromptLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["promptLog"]>

  export type PromptLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryText?: boolean
    tier?: boolean
    response?: boolean
    error?: boolean
    latencyMs?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | PromptLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["promptLog"]>

  export type PromptLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryText?: boolean
    tier?: boolean
    response?: boolean
    error?: boolean
    latencyMs?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | PromptLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["promptLog"]>

  export type PromptLogSelectScalar = {
    id?: boolean
    queryText?: boolean
    tier?: boolean
    response?: boolean
    error?: boolean
    latencyMs?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type PromptLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queryText" | "tier" | "response" | "error" | "latencyMs" | "userId" | "createdAt", ExtArgs["result"]["promptLog"]>
  export type PromptLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PromptLog$userArgs<ExtArgs>
  }
  export type PromptLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PromptLog$userArgs<ExtArgs>
  }
  export type PromptLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PromptLog$userArgs<ExtArgs>
  }

  export type $PromptLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromptLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queryText: string
      tier: $Enums.PromptLogTier
      response: Prisma.JsonValue | null
      error: string | null
      latencyMs: number | null
      userId: string | null
      createdAt: Date
    }, ExtArgs["result"]["promptLog"]>
    composites: {}
  }

  type PromptLogGetPayload<S extends boolean | null | undefined | PromptLogDefaultArgs> = $Result.GetResult<Prisma.$PromptLogPayload, S>

  type PromptLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromptLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromptLogCountAggregateInputType | true
    }

  export interface PromptLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromptLog'], meta: { name: 'PromptLog' } }
    /**
     * Find zero or one PromptLog that matches the filter.
     * @param {PromptLogFindUniqueArgs} args - Arguments to find a PromptLog
     * @example
     * // Get one PromptLog
     * const promptLog = await prisma.promptLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromptLogFindUniqueArgs>(args: SelectSubset<T, PromptLogFindUniqueArgs<ExtArgs>>): Prisma__PromptLogClient<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromptLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromptLogFindUniqueOrThrowArgs} args - Arguments to find a PromptLog
     * @example
     * // Get one PromptLog
     * const promptLog = await prisma.promptLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromptLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PromptLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromptLogClient<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromptLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptLogFindFirstArgs} args - Arguments to find a PromptLog
     * @example
     * // Get one PromptLog
     * const promptLog = await prisma.promptLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromptLogFindFirstArgs>(args?: SelectSubset<T, PromptLogFindFirstArgs<ExtArgs>>): Prisma__PromptLogClient<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromptLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptLogFindFirstOrThrowArgs} args - Arguments to find a PromptLog
     * @example
     * // Get one PromptLog
     * const promptLog = await prisma.promptLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromptLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PromptLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromptLogClient<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromptLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromptLogs
     * const promptLogs = await prisma.promptLog.findMany()
     * 
     * // Get first 10 PromptLogs
     * const promptLogs = await prisma.promptLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptLogWithIdOnly = await prisma.promptLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromptLogFindManyArgs>(args?: SelectSubset<T, PromptLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromptLog.
     * @param {PromptLogCreateArgs} args - Arguments to create a PromptLog.
     * @example
     * // Create one PromptLog
     * const PromptLog = await prisma.promptLog.create({
     *   data: {
     *     // ... data to create a PromptLog
     *   }
     * })
     * 
     */
    create<T extends PromptLogCreateArgs>(args: SelectSubset<T, PromptLogCreateArgs<ExtArgs>>): Prisma__PromptLogClient<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromptLogs.
     * @param {PromptLogCreateManyArgs} args - Arguments to create many PromptLogs.
     * @example
     * // Create many PromptLogs
     * const promptLog = await prisma.promptLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromptLogCreateManyArgs>(args?: SelectSubset<T, PromptLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromptLogs and returns the data saved in the database.
     * @param {PromptLogCreateManyAndReturnArgs} args - Arguments to create many PromptLogs.
     * @example
     * // Create many PromptLogs
     * const promptLog = await prisma.promptLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromptLogs and only return the `id`
     * const promptLogWithIdOnly = await prisma.promptLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromptLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PromptLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromptLog.
     * @param {PromptLogDeleteArgs} args - Arguments to delete one PromptLog.
     * @example
     * // Delete one PromptLog
     * const PromptLog = await prisma.promptLog.delete({
     *   where: {
     *     // ... filter to delete one PromptLog
     *   }
     * })
     * 
     */
    delete<T extends PromptLogDeleteArgs>(args: SelectSubset<T, PromptLogDeleteArgs<ExtArgs>>): Prisma__PromptLogClient<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromptLog.
     * @param {PromptLogUpdateArgs} args - Arguments to update one PromptLog.
     * @example
     * // Update one PromptLog
     * const promptLog = await prisma.promptLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromptLogUpdateArgs>(args: SelectSubset<T, PromptLogUpdateArgs<ExtArgs>>): Prisma__PromptLogClient<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromptLogs.
     * @param {PromptLogDeleteManyArgs} args - Arguments to filter PromptLogs to delete.
     * @example
     * // Delete a few PromptLogs
     * const { count } = await prisma.promptLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromptLogDeleteManyArgs>(args?: SelectSubset<T, PromptLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromptLogs
     * const promptLog = await prisma.promptLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromptLogUpdateManyArgs>(args: SelectSubset<T, PromptLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptLogs and returns the data updated in the database.
     * @param {PromptLogUpdateManyAndReturnArgs} args - Arguments to update many PromptLogs.
     * @example
     * // Update many PromptLogs
     * const promptLog = await prisma.promptLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromptLogs and only return the `id`
     * const promptLogWithIdOnly = await prisma.promptLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromptLogUpdateManyAndReturnArgs>(args: SelectSubset<T, PromptLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromptLog.
     * @param {PromptLogUpsertArgs} args - Arguments to update or create a PromptLog.
     * @example
     * // Update or create a PromptLog
     * const promptLog = await prisma.promptLog.upsert({
     *   create: {
     *     // ... data to create a PromptLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromptLog we want to update
     *   }
     * })
     */
    upsert<T extends PromptLogUpsertArgs>(args: SelectSubset<T, PromptLogUpsertArgs<ExtArgs>>): Prisma__PromptLogClient<$Result.GetResult<Prisma.$PromptLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromptLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptLogCountArgs} args - Arguments to filter PromptLogs to count.
     * @example
     * // Count the number of PromptLogs
     * const count = await prisma.promptLog.count({
     *   where: {
     *     // ... the filter for the PromptLogs we want to count
     *   }
     * })
    **/
    count<T extends PromptLogCountArgs>(
      args?: Subset<T, PromptLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromptLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptLogAggregateArgs>(args: Subset<T, PromptLogAggregateArgs>): Prisma.PrismaPromise<GetPromptLogAggregateType<T>>

    /**
     * Group by PromptLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptLogGroupByArgs['orderBy'] }
        : { orderBy?: PromptLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromptLog model
   */
  readonly fields: PromptLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromptLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromptLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends PromptLog$userArgs<ExtArgs> = {}>(args?: Subset<T, PromptLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromptLog model
   */
  interface PromptLogFieldRefs {
    readonly id: FieldRef<"PromptLog", 'String'>
    readonly queryText: FieldRef<"PromptLog", 'String'>
    readonly tier: FieldRef<"PromptLog", 'PromptLogTier'>
    readonly response: FieldRef<"PromptLog", 'Json'>
    readonly error: FieldRef<"PromptLog", 'String'>
    readonly latencyMs: FieldRef<"PromptLog", 'Int'>
    readonly userId: FieldRef<"PromptLog", 'String'>
    readonly createdAt: FieldRef<"PromptLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromptLog findUnique
   */
  export type PromptLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
    /**
     * Filter, which PromptLog to fetch.
     */
    where: PromptLogWhereUniqueInput
  }

  /**
   * PromptLog findUniqueOrThrow
   */
  export type PromptLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
    /**
     * Filter, which PromptLog to fetch.
     */
    where: PromptLogWhereUniqueInput
  }

  /**
   * PromptLog findFirst
   */
  export type PromptLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
    /**
     * Filter, which PromptLog to fetch.
     */
    where?: PromptLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptLogs to fetch.
     */
    orderBy?: PromptLogOrderByWithRelationInput | PromptLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptLogs.
     */
    cursor?: PromptLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptLogs.
     */
    distinct?: PromptLogScalarFieldEnum | PromptLogScalarFieldEnum[]
  }

  /**
   * PromptLog findFirstOrThrow
   */
  export type PromptLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
    /**
     * Filter, which PromptLog to fetch.
     */
    where?: PromptLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptLogs to fetch.
     */
    orderBy?: PromptLogOrderByWithRelationInput | PromptLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptLogs.
     */
    cursor?: PromptLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptLogs.
     */
    distinct?: PromptLogScalarFieldEnum | PromptLogScalarFieldEnum[]
  }

  /**
   * PromptLog findMany
   */
  export type PromptLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
    /**
     * Filter, which PromptLogs to fetch.
     */
    where?: PromptLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptLogs to fetch.
     */
    orderBy?: PromptLogOrderByWithRelationInput | PromptLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromptLogs.
     */
    cursor?: PromptLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptLogs.
     */
    skip?: number
    distinct?: PromptLogScalarFieldEnum | PromptLogScalarFieldEnum[]
  }

  /**
   * PromptLog create
   */
  export type PromptLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
    /**
     * The data needed to create a PromptLog.
     */
    data: XOR<PromptLogCreateInput, PromptLogUncheckedCreateInput>
  }

  /**
   * PromptLog createMany
   */
  export type PromptLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromptLogs.
     */
    data: PromptLogCreateManyInput | PromptLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromptLog createManyAndReturn
   */
  export type PromptLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * The data used to create many PromptLogs.
     */
    data: PromptLogCreateManyInput | PromptLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromptLog update
   */
  export type PromptLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
    /**
     * The data needed to update a PromptLog.
     */
    data: XOR<PromptLogUpdateInput, PromptLogUncheckedUpdateInput>
    /**
     * Choose, which PromptLog to update.
     */
    where: PromptLogWhereUniqueInput
  }

  /**
   * PromptLog updateMany
   */
  export type PromptLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromptLogs.
     */
    data: XOR<PromptLogUpdateManyMutationInput, PromptLogUncheckedUpdateManyInput>
    /**
     * Filter which PromptLogs to update
     */
    where?: PromptLogWhereInput
    /**
     * Limit how many PromptLogs to update.
     */
    limit?: number
  }

  /**
   * PromptLog updateManyAndReturn
   */
  export type PromptLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * The data used to update PromptLogs.
     */
    data: XOR<PromptLogUpdateManyMutationInput, PromptLogUncheckedUpdateManyInput>
    /**
     * Filter which PromptLogs to update
     */
    where?: PromptLogWhereInput
    /**
     * Limit how many PromptLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromptLog upsert
   */
  export type PromptLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
    /**
     * The filter to search for the PromptLog to update in case it exists.
     */
    where: PromptLogWhereUniqueInput
    /**
     * In case the PromptLog found by the `where` argument doesn't exist, create a new PromptLog with this data.
     */
    create: XOR<PromptLogCreateInput, PromptLogUncheckedCreateInput>
    /**
     * In case the PromptLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptLogUpdateInput, PromptLogUncheckedUpdateInput>
  }

  /**
   * PromptLog delete
   */
  export type PromptLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
    /**
     * Filter which PromptLog to delete.
     */
    where: PromptLogWhereUniqueInput
  }

  /**
   * PromptLog deleteMany
   */
  export type PromptLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptLogs to delete
     */
    where?: PromptLogWhereInput
    /**
     * Limit how many PromptLogs to delete.
     */
    limit?: number
  }

  /**
   * PromptLog.user
   */
  export type PromptLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PromptLog without action
   */
  export type PromptLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptLog
     */
    select?: PromptLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromptLog
     */
    omit?: PromptLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptLogInclude<ExtArgs> | null
  }


  /**
   * Model ChangeLog
   */

  export type AggregateChangeLog = {
    _count: ChangeLogCountAggregateOutputType | null
    _min: ChangeLogMinAggregateOutputType | null
    _max: ChangeLogMaxAggregateOutputType | null
  }

  export type ChangeLogMinAggregateOutputType = {
    id: string | null
    changeType: string | null
    userId: string | null
    changedAt: Date | null
  }

  export type ChangeLogMaxAggregateOutputType = {
    id: string | null
    changeType: string | null
    userId: string | null
    changedAt: Date | null
  }

  export type ChangeLogCountAggregateOutputType = {
    id: number
    changeType: number
    changeDetails: number
    userId: number
    changedAt: number
    _all: number
  }


  export type ChangeLogMinAggregateInputType = {
    id?: true
    changeType?: true
    userId?: true
    changedAt?: true
  }

  export type ChangeLogMaxAggregateInputType = {
    id?: true
    changeType?: true
    userId?: true
    changedAt?: true
  }

  export type ChangeLogCountAggregateInputType = {
    id?: true
    changeType?: true
    changeDetails?: true
    userId?: true
    changedAt?: true
    _all?: true
  }

  export type ChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeLog to aggregate.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangeLogs
    **/
    _count?: true | ChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeLogMaxAggregateInputType
  }

  export type GetChangeLogAggregateType<T extends ChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeLog[P]>
      : GetScalarType<T[P], AggregateChangeLog[P]>
  }




  export type ChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeLogWhereInput
    orderBy?: ChangeLogOrderByWithAggregationInput | ChangeLogOrderByWithAggregationInput[]
    by: ChangeLogScalarFieldEnum[] | ChangeLogScalarFieldEnum
    having?: ChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeLogCountAggregateInputType | true
    _min?: ChangeLogMinAggregateInputType
    _max?: ChangeLogMaxAggregateInputType
  }

  export type ChangeLogGroupByOutputType = {
    id: string
    changeType: string
    changeDetails: JsonValue
    userId: string | null
    changedAt: Date
    _count: ChangeLogCountAggregateOutputType | null
    _min: ChangeLogMinAggregateOutputType | null
    _max: ChangeLogMaxAggregateOutputType | null
  }

  type GetChangeLogGroupByPayload<T extends ChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type ChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeType?: boolean
    changeDetails?: boolean
    userId?: boolean
    changedAt?: boolean
    user?: boolean | ChangeLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["changeLog"]>

  export type ChangeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeType?: boolean
    changeDetails?: boolean
    userId?: boolean
    changedAt?: boolean
    user?: boolean | ChangeLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["changeLog"]>

  export type ChangeLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeType?: boolean
    changeDetails?: boolean
    userId?: boolean
    changedAt?: boolean
    user?: boolean | ChangeLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["changeLog"]>

  export type ChangeLogSelectScalar = {
    id?: boolean
    changeType?: boolean
    changeDetails?: boolean
    userId?: boolean
    changedAt?: boolean
  }

  export type ChangeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "changeType" | "changeDetails" | "userId" | "changedAt", ExtArgs["result"]["changeLog"]>
  export type ChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ChangeLog$userArgs<ExtArgs>
  }
  export type ChangeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ChangeLog$userArgs<ExtArgs>
  }
  export type ChangeLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ChangeLog$userArgs<ExtArgs>
  }

  export type $ChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChangeLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      changeType: string
      changeDetails: Prisma.JsonValue
      userId: string | null
      changedAt: Date
    }, ExtArgs["result"]["changeLog"]>
    composites: {}
  }

  type ChangeLogGetPayload<S extends boolean | null | undefined | ChangeLogDefaultArgs> = $Result.GetResult<Prisma.$ChangeLogPayload, S>

  type ChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChangeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChangeLogCountAggregateInputType | true
    }

  export interface ChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChangeLog'], meta: { name: 'ChangeLog' } }
    /**
     * Find zero or one ChangeLog that matches the filter.
     * @param {ChangeLogFindUniqueArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangeLogFindUniqueArgs>(args: SelectSubset<T, ChangeLogFindUniqueArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChangeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChangeLogFindUniqueOrThrowArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindFirstArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangeLogFindFirstArgs>(args?: SelectSubset<T, ChangeLogFindFirstArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindFirstOrThrowArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangeLogs
     * const changeLogs = await prisma.changeLog.findMany()
     * 
     * // Get first 10 ChangeLogs
     * const changeLogs = await prisma.changeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeLogWithIdOnly = await prisma.changeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChangeLogFindManyArgs>(args?: SelectSubset<T, ChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChangeLog.
     * @param {ChangeLogCreateArgs} args - Arguments to create a ChangeLog.
     * @example
     * // Create one ChangeLog
     * const ChangeLog = await prisma.changeLog.create({
     *   data: {
     *     // ... data to create a ChangeLog
     *   }
     * })
     * 
     */
    create<T extends ChangeLogCreateArgs>(args: SelectSubset<T, ChangeLogCreateArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChangeLogs.
     * @param {ChangeLogCreateManyArgs} args - Arguments to create many ChangeLogs.
     * @example
     * // Create many ChangeLogs
     * const changeLog = await prisma.changeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangeLogCreateManyArgs>(args?: SelectSubset<T, ChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChangeLogs and returns the data saved in the database.
     * @param {ChangeLogCreateManyAndReturnArgs} args - Arguments to create many ChangeLogs.
     * @example
     * // Create many ChangeLogs
     * const changeLog = await prisma.changeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChangeLogs and only return the `id`
     * const changeLogWithIdOnly = await prisma.changeLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChangeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ChangeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChangeLog.
     * @param {ChangeLogDeleteArgs} args - Arguments to delete one ChangeLog.
     * @example
     * // Delete one ChangeLog
     * const ChangeLog = await prisma.changeLog.delete({
     *   where: {
     *     // ... filter to delete one ChangeLog
     *   }
     * })
     * 
     */
    delete<T extends ChangeLogDeleteArgs>(args: SelectSubset<T, ChangeLogDeleteArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChangeLog.
     * @param {ChangeLogUpdateArgs} args - Arguments to update one ChangeLog.
     * @example
     * // Update one ChangeLog
     * const changeLog = await prisma.changeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangeLogUpdateArgs>(args: SelectSubset<T, ChangeLogUpdateArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChangeLogs.
     * @param {ChangeLogDeleteManyArgs} args - Arguments to filter ChangeLogs to delete.
     * @example
     * // Delete a few ChangeLogs
     * const { count } = await prisma.changeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangeLogDeleteManyArgs>(args?: SelectSubset<T, ChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangeLogs
     * const changeLog = await prisma.changeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangeLogUpdateManyArgs>(args: SelectSubset<T, ChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeLogs and returns the data updated in the database.
     * @param {ChangeLogUpdateManyAndReturnArgs} args - Arguments to update many ChangeLogs.
     * @example
     * // Update many ChangeLogs
     * const changeLog = await prisma.changeLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChangeLogs and only return the `id`
     * const changeLogWithIdOnly = await prisma.changeLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChangeLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ChangeLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChangeLog.
     * @param {ChangeLogUpsertArgs} args - Arguments to update or create a ChangeLog.
     * @example
     * // Update or create a ChangeLog
     * const changeLog = await prisma.changeLog.upsert({
     *   create: {
     *     // ... data to create a ChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends ChangeLogUpsertArgs>(args: SelectSubset<T, ChangeLogUpsertArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogCountArgs} args - Arguments to filter ChangeLogs to count.
     * @example
     * // Count the number of ChangeLogs
     * const count = await prisma.changeLog.count({
     *   where: {
     *     // ... the filter for the ChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends ChangeLogCountArgs>(
      args?: Subset<T, ChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeLogAggregateArgs>(args: Subset<T, ChangeLogAggregateArgs>): Prisma.PrismaPromise<GetChangeLogAggregateType<T>>

    /**
     * Group by ChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: ChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChangeLog model
   */
  readonly fields: ChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ChangeLog$userArgs<ExtArgs> = {}>(args?: Subset<T, ChangeLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChangeLog model
   */
  interface ChangeLogFieldRefs {
    readonly id: FieldRef<"ChangeLog", 'String'>
    readonly changeType: FieldRef<"ChangeLog", 'String'>
    readonly changeDetails: FieldRef<"ChangeLog", 'Json'>
    readonly userId: FieldRef<"ChangeLog", 'String'>
    readonly changedAt: FieldRef<"ChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChangeLog findUnique
   */
  export type ChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where: ChangeLogWhereUniqueInput
  }

  /**
   * ChangeLog findUniqueOrThrow
   */
  export type ChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where: ChangeLogWhereUniqueInput
  }

  /**
   * ChangeLog findFirst
   */
  export type ChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeLogs.
     */
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }

  /**
   * ChangeLog findFirstOrThrow
   */
  export type ChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeLogs.
     */
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }

  /**
   * ChangeLog findMany
   */
  export type ChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLogs to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }

  /**
   * ChangeLog create
   */
  export type ChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ChangeLog.
     */
    data: XOR<ChangeLogCreateInput, ChangeLogUncheckedCreateInput>
  }

  /**
   * ChangeLog createMany
   */
  export type ChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChangeLogs.
     */
    data: ChangeLogCreateManyInput | ChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChangeLog createManyAndReturn
   */
  export type ChangeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * The data used to create many ChangeLogs.
     */
    data: ChangeLogCreateManyInput | ChangeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeLog update
   */
  export type ChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ChangeLog.
     */
    data: XOR<ChangeLogUpdateInput, ChangeLogUncheckedUpdateInput>
    /**
     * Choose, which ChangeLog to update.
     */
    where: ChangeLogWhereUniqueInput
  }

  /**
   * ChangeLog updateMany
   */
  export type ChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChangeLogs.
     */
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which ChangeLogs to update
     */
    where?: ChangeLogWhereInput
    /**
     * Limit how many ChangeLogs to update.
     */
    limit?: number
  }

  /**
   * ChangeLog updateManyAndReturn
   */
  export type ChangeLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * The data used to update ChangeLogs.
     */
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which ChangeLogs to update
     */
    where?: ChangeLogWhereInput
    /**
     * Limit how many ChangeLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeLog upsert
   */
  export type ChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ChangeLog to update in case it exists.
     */
    where: ChangeLogWhereUniqueInput
    /**
     * In case the ChangeLog found by the `where` argument doesn't exist, create a new ChangeLog with this data.
     */
    create: XOR<ChangeLogCreateInput, ChangeLogUncheckedCreateInput>
    /**
     * In case the ChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeLogUpdateInput, ChangeLogUncheckedUpdateInput>
  }

  /**
   * ChangeLog delete
   */
  export type ChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter which ChangeLog to delete.
     */
    where: ChangeLogWhereUniqueInput
  }

  /**
   * ChangeLog deleteMany
   */
  export type ChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeLogs to delete
     */
    where?: ChangeLogWhereInput
    /**
     * Limit how many ChangeLogs to delete.
     */
    limit?: number
  }

  /**
   * ChangeLog.user
   */
  export type ChangeLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ChangeLog without action
   */
  export type ChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    email: 'email',
    fullName: 'fullName',
    avatarUrl: 'avatarUrl',
    preferences: 'preferences',
    totalProcessedContent: 'totalProcessedContent',
    totalEmbeddings: 'totalEmbeddings',
    monthlyQuotaUsed: 'monthlyQuotaUsed',
    lastActiveDate: 'lastActiveDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const SpaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    color: 'color',
    domain: 'domain',
    isDefault: 'isDefault',
    contentCount: 'contentCount',
    lastAccessed: 'lastAccessed',
    pineconeNamespace: 'pineconeNamespace',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SpaceScalarFieldEnum = (typeof SpaceScalarFieldEnum)[keyof typeof SpaceScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    url: 'url',
    type: 'type',
    content: 'content',
    tags: 'tags',
    domain: 'domain',
    language: 'language',
    metadata: 'metadata',
    complexityLevel: 'complexityLevel',
    estimatedReadTimeMinutes: 'estimatedReadTimeMinutes',
    wordCount: 'wordCount',
    processingStatus: 'processingStatus',
    processedAt: 'processedAt',
    actionDensity: 'actionDensity',
    noveltyScore: 'noveltyScore',
    practicalApplicability: 'practicalApplicability',
    userId: 'userId',
    spaceId: 'spaceId',
    classificationId: 'classificationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const ResourceVersionScalarFieldEnum: {
    id: 'id',
    versionNumber: 'versionNumber',
    title: 'title',
    content: 'content',
    tags: 'tags',
    metadata: 'metadata',
    resourceId: 'resourceId',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type ResourceVersionScalarFieldEnum = (typeof ResourceVersionScalarFieldEnum)[keyof typeof ResourceVersionScalarFieldEnum]


  export const ClassificationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    domain: 'domain',
    usageCount: 'usageCount',
    isSystemDefault: 'isSystemDefault',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ClassificationScalarFieldEnum = (typeof ClassificationScalarFieldEnum)[keyof typeof ClassificationScalarFieldEnum]


  export const ContentSummaryScalarFieldEnum: {
    id: 'id',
    executiveSummary: 'executiveSummary',
    keyInsights: 'keyInsights',
    immediateActions: 'immediateActions',
    criticalWarnings: 'criticalWarnings',
    keyMetrics: 'keyMetrics',
    toolsResources: 'toolsResources',
    peopleCompanies: 'peopleCompanies',
    primaryKeywords: 'primaryKeywords',
    semanticTags: 'semanticTags',
    questionBasedTags: 'questionBasedTags',
    totalChunks: 'totalChunks',
    embeddingModel: 'embeddingModel',
    avgChunkTokens: 'avgChunkTokens',
    resourceId: 'resourceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ContentSummaryScalarFieldEnum = (typeof ContentSummaryScalarFieldEnum)[keyof typeof ContentSummaryScalarFieldEnum]


  export const VectorChunkScalarFieldEnum: {
    id: 'id',
    chunkIndex: 'chunkIndex',
    chunkType: 'chunkType',
    content: 'content',
    tokenCount: 'tokenCount',
    pineconeId: 'pineconeId',
    pineconeNamespace: 'pineconeNamespace',
    embeddingModel: 'embeddingModel',
    vectorDimension: 'vectorDimension',
    overlappingChunks: 'overlappingChunks',
    semanticDensity: 'semanticDensity',
    retrievalFrequency: 'retrievalFrequency',
    lastRetrieved: 'lastRetrieved',
    resourceId: 'resourceId',
    summaryId: 'summaryId',
    parentChunkId: 'parentChunkId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type VectorChunkScalarFieldEnum = (typeof VectorChunkScalarFieldEnum)[keyof typeof VectorChunkScalarFieldEnum]


  export const ContentRelationshipScalarFieldEnum: {
    id: 'id',
    relationshipType: 'relationshipType',
    confidenceScore: 'confidenceScore',
    relationshipReason: 'relationshipReason',
    isAutoGenerated: 'isAutoGenerated',
    sourceResourceId: 'sourceResourceId',
    targetResourceId: 'targetResourceId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type ContentRelationshipScalarFieldEnum = (typeof ContentRelationshipScalarFieldEnum)[keyof typeof ContentRelationshipScalarFieldEnum]


  export const KnowledgeNodeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    domain: 'domain',
    importanceScore: 'importanceScore',
    mentionFrequency: 'mentionFrequency',
    mentionedInResources: 'mentionedInResources',
    firstMentionedDate: 'firstMentionedDate',
    lastMentionedDate: 'lastMentionedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type KnowledgeNodeScalarFieldEnum = (typeof KnowledgeNodeScalarFieldEnum)[keyof typeof KnowledgeNodeScalarFieldEnum]


  export const KnowledgeEdgeScalarFieldEnum: {
    id: 'id',
    relationshipType: 'relationshipType',
    strength: 'strength',
    evidenceResources: 'evidenceResources',
    isAutoGenerated: 'isAutoGenerated',
    sourceNodeId: 'sourceNodeId',
    targetNodeId: 'targetNodeId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type KnowledgeEdgeScalarFieldEnum = (typeof KnowledgeEdgeScalarFieldEnum)[keyof typeof KnowledgeEdgeScalarFieldEnum]


  export const SearchQueryScalarFieldEnum: {
    id: 'id',
    query: 'query',
    queryType: 'queryType',
    resultsCount: 'resultsCount',
    avgRelevanceScore: 'avgRelevanceScore',
    clickedResults: 'clickedResults',
    extractedIntent: 'extractedIntent',
    domainClassification: 'domainClassification',
    complexityDetected: 'complexityDetected',
    responseTimeMs: 'responseTimeMs',
    userSatisfaction: 'userSatisfaction',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type SearchQueryScalarFieldEnum = (typeof SearchQueryScalarFieldEnum)[keyof typeof SearchQueryScalarFieldEnum]


  export const LearningAnalyticScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    eventDetails: 'eventDetails',
    sessionId: 'sessionId',
    comprehensionLevel: 'comprehensionLevel',
    implementationStatus: 'implementationStatus',
    deviceType: 'deviceType',
    timeSpentSeconds: 'timeSpentSeconds',
    referralSource: 'referralSource',
    userId: 'userId',
    resourceId: 'resourceId',
    createdAt: 'createdAt'
  };

  export type LearningAnalyticScalarFieldEnum = (typeof LearningAnalyticScalarFieldEnum)[keyof typeof LearningAnalyticScalarFieldEnum]


  export const BatchJobScalarFieldEnum: {
    id: 'id',
    status: 'status',
    progress: 'progress',
    totalItems: 'totalItems',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchJobScalarFieldEnum = (typeof BatchJobScalarFieldEnum)[keyof typeof BatchJobScalarFieldEnum]


  export const PromptLogScalarFieldEnum: {
    id: 'id',
    queryText: 'queryText',
    tier: 'tier',
    response: 'response',
    error: 'error',
    latencyMs: 'latencyMs',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type PromptLogScalarFieldEnum = (typeof PromptLogScalarFieldEnum)[keyof typeof PromptLogScalarFieldEnum]


  export const ChangeLogScalarFieldEnum: {
    id: 'id',
    changeType: 'changeType',
    changeDetails: 'changeDetails',
    userId: 'userId',
    changedAt: 'changedAt'
  };

  export type ChangeLogScalarFieldEnum = (typeof ChangeLogScalarFieldEnum)[keyof typeof ChangeLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ContentDomain'
   */
  export type EnumContentDomainFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentDomain'>
    


  /**
   * Reference to a field of type 'ContentDomain[]'
   */
  export type ListEnumContentDomainFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentDomain[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'ResourceType[]'
   */
  export type ListEnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType[]'>
    


  /**
   * Reference to a field of type 'ComplexityLevel'
   */
  export type EnumComplexityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplexityLevel'>
    


  /**
   * Reference to a field of type 'ComplexityLevel[]'
   */
  export type ListEnumComplexityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplexityLevel[]'>
    


  /**
   * Reference to a field of type 'ProcessingStatus'
   */
  export type EnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus'>
    


  /**
   * Reference to a field of type 'ProcessingStatus[]'
   */
  export type ListEnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus[]'>
    


  /**
   * Reference to a field of type 'ActionDensity'
   */
  export type EnumActionDensityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionDensity'>
    


  /**
   * Reference to a field of type 'ActionDensity[]'
   */
  export type ListEnumActionDensityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionDensity[]'>
    


  /**
   * Reference to a field of type 'PracticalApplicability'
   */
  export type EnumPracticalApplicabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PracticalApplicability'>
    


  /**
   * Reference to a field of type 'PracticalApplicability[]'
   */
  export type ListEnumPracticalApplicabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PracticalApplicability[]'>
    


  /**
   * Reference to a field of type 'ChunkType'
   */
  export type EnumChunkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChunkType'>
    


  /**
   * Reference to a field of type 'ChunkType[]'
   */
  export type ListEnumChunkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChunkType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'RelationshipType'
   */
  export type EnumRelationshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipType'>
    


  /**
   * Reference to a field of type 'RelationshipType[]'
   */
  export type ListEnumRelationshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipType[]'>
    


  /**
   * Reference to a field of type 'ImplementationStatus'
   */
  export type EnumImplementationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImplementationStatus'>
    


  /**
   * Reference to a field of type 'ImplementationStatus[]'
   */
  export type ListEnumImplementationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImplementationStatus[]'>
    


  /**
   * Reference to a field of type 'BatchJobStatus'
   */
  export type EnumBatchJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchJobStatus'>
    


  /**
   * Reference to a field of type 'BatchJobStatus[]'
   */
  export type ListEnumBatchJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchJobStatus[]'>
    


  /**
   * Reference to a field of type 'PromptLogTier'
   */
  export type EnumPromptLogTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromptLogTier'>
    


  /**
   * Reference to a field of type 'PromptLogTier[]'
   */
  export type ListEnumPromptLogTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromptLogTier[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    user_profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    spaces?: SpaceListRelationFilter
    resources?: ResourceListRelationFilter
    search_queries?: SearchQueryListRelationFilter
    learning_analytics?: LearningAnalyticListRelationFilter
    content_relationships?: ContentRelationshipListRelationFilter
    knowledge_edges_created?: KnowledgeEdgeListRelationFilter
    batch_jobs?: BatchJobListRelationFilter
    prompt_logs?: PromptLogListRelationFilter
    change_logs?: ChangeLogListRelationFilter
    resource_versions?: ResourceVersionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    user_profile?: UserProfileOrderByWithRelationInput
    spaces?: SpaceOrderByRelationAggregateInput
    resources?: ResourceOrderByRelationAggregateInput
    search_queries?: SearchQueryOrderByRelationAggregateInput
    learning_analytics?: LearningAnalyticOrderByRelationAggregateInput
    content_relationships?: ContentRelationshipOrderByRelationAggregateInput
    knowledge_edges_created?: KnowledgeEdgeOrderByRelationAggregateInput
    batch_jobs?: BatchJobOrderByRelationAggregateInput
    prompt_logs?: PromptLogOrderByRelationAggregateInput
    change_logs?: ChangeLogOrderByRelationAggregateInput
    resource_versions?: ResourceVersionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    user_profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    spaces?: SpaceListRelationFilter
    resources?: ResourceListRelationFilter
    search_queries?: SearchQueryListRelationFilter
    learning_analytics?: LearningAnalyticListRelationFilter
    content_relationships?: ContentRelationshipListRelationFilter
    knowledge_edges_created?: KnowledgeEdgeListRelationFilter
    batch_jobs?: BatchJobListRelationFilter
    prompt_logs?: PromptLogListRelationFilter
    change_logs?: ChangeLogListRelationFilter
    resource_versions?: ResourceVersionListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: UuidFilter<"UserProfile"> | string
    email?: StringFilter<"UserProfile"> | string
    fullName?: StringNullableFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableFilter<"UserProfile"> | string | null
    preferences?: JsonFilter<"UserProfile">
    totalProcessedContent?: IntFilter<"UserProfile"> | number
    totalEmbeddings?: IntFilter<"UserProfile"> | number
    monthlyQuotaUsed?: IntFilter<"UserProfile"> | number
    lastActiveDate?: DateTimeFilter<"UserProfile"> | Date | string
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    preferences?: SortOrder
    totalProcessedContent?: SortOrder
    totalEmbeddings?: SortOrder
    monthlyQuotaUsed?: SortOrder
    lastActiveDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    fullName?: StringNullableFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableFilter<"UserProfile"> | string | null
    preferences?: JsonFilter<"UserProfile">
    totalProcessedContent?: IntFilter<"UserProfile"> | number
    totalEmbeddings?: IntFilter<"UserProfile"> | number
    monthlyQuotaUsed?: IntFilter<"UserProfile"> | number
    lastActiveDate?: DateTimeFilter<"UserProfile"> | Date | string
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "email">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    preferences?: SortOrder
    totalProcessedContent?: SortOrder
    totalEmbeddings?: SortOrder
    monthlyQuotaUsed?: SortOrder
    lastActiveDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserProfile"> | string
    email?: StringWithAggregatesFilter<"UserProfile"> | string
    fullName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    preferences?: JsonWithAggregatesFilter<"UserProfile">
    totalProcessedContent?: IntWithAggregatesFilter<"UserProfile"> | number
    totalEmbeddings?: IntWithAggregatesFilter<"UserProfile"> | number
    monthlyQuotaUsed?: IntWithAggregatesFilter<"UserProfile"> | number
    lastActiveDate?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
  }

  export type SpaceWhereInput = {
    AND?: SpaceWhereInput | SpaceWhereInput[]
    OR?: SpaceWhereInput[]
    NOT?: SpaceWhereInput | SpaceWhereInput[]
    id?: UuidFilter<"Space"> | string
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    color?: StringFilter<"Space"> | string
    domain?: EnumContentDomainFilter<"Space"> | $Enums.ContentDomain
    isDefault?: BoolFilter<"Space"> | boolean
    contentCount?: IntFilter<"Space"> | number
    lastAccessed?: DateTimeFilter<"Space"> | Date | string
    pineconeNamespace?: StringNullableFilter<"Space"> | string | null
    userId?: UuidFilter<"Space"> | string
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Space"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resources?: ResourceListRelationFilter
  }

  export type SpaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    domain?: SortOrder
    isDefault?: SortOrder
    contentCount?: SortOrder
    lastAccessed?: SortOrder
    pineconeNamespace?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    resources?: ResourceOrderByRelationAggregateInput
  }

  export type SpaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pineconeNamespace?: string
    AND?: SpaceWhereInput | SpaceWhereInput[]
    OR?: SpaceWhereInput[]
    NOT?: SpaceWhereInput | SpaceWhereInput[]
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    color?: StringFilter<"Space"> | string
    domain?: EnumContentDomainFilter<"Space"> | $Enums.ContentDomain
    isDefault?: BoolFilter<"Space"> | boolean
    contentCount?: IntFilter<"Space"> | number
    lastAccessed?: DateTimeFilter<"Space"> | Date | string
    userId?: UuidFilter<"Space"> | string
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Space"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resources?: ResourceListRelationFilter
  }, "id" | "pineconeNamespace">

  export type SpaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    domain?: SortOrder
    isDefault?: SortOrder
    contentCount?: SortOrder
    lastAccessed?: SortOrder
    pineconeNamespace?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SpaceCountOrderByAggregateInput
    _avg?: SpaceAvgOrderByAggregateInput
    _max?: SpaceMaxOrderByAggregateInput
    _min?: SpaceMinOrderByAggregateInput
    _sum?: SpaceSumOrderByAggregateInput
  }

  export type SpaceScalarWhereWithAggregatesInput = {
    AND?: SpaceScalarWhereWithAggregatesInput | SpaceScalarWhereWithAggregatesInput[]
    OR?: SpaceScalarWhereWithAggregatesInput[]
    NOT?: SpaceScalarWhereWithAggregatesInput | SpaceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Space"> | string
    name?: StringWithAggregatesFilter<"Space"> | string
    description?: StringNullableWithAggregatesFilter<"Space"> | string | null
    color?: StringWithAggregatesFilter<"Space"> | string
    domain?: EnumContentDomainWithAggregatesFilter<"Space"> | $Enums.ContentDomain
    isDefault?: BoolWithAggregatesFilter<"Space"> | boolean
    contentCount?: IntWithAggregatesFilter<"Space"> | number
    lastAccessed?: DateTimeWithAggregatesFilter<"Space"> | Date | string
    pineconeNamespace?: StringNullableWithAggregatesFilter<"Space"> | string | null
    userId?: UuidWithAggregatesFilter<"Space"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Space"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Space"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Space"> | Date | string | null
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: UuidFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    url?: StringNullableFilter<"Resource"> | string | null
    type?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    content?: StringNullableFilter<"Resource"> | string | null
    tags?: StringNullableListFilter<"Resource">
    domain?: EnumContentDomainFilter<"Resource"> | $Enums.ContentDomain
    language?: StringFilter<"Resource"> | string
    metadata?: JsonFilter<"Resource">
    complexityLevel?: EnumComplexityLevelFilter<"Resource"> | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: IntNullableFilter<"Resource"> | number | null
    wordCount?: IntNullableFilter<"Resource"> | number | null
    processingStatus?: EnumProcessingStatusFilter<"Resource"> | $Enums.ProcessingStatus
    processedAt?: DateTimeNullableFilter<"Resource"> | Date | string | null
    actionDensity?: EnumActionDensityFilter<"Resource"> | $Enums.ActionDensity
    noveltyScore?: IntNullableFilter<"Resource"> | number | null
    practicalApplicability?: EnumPracticalApplicabilityNullableFilter<"Resource"> | $Enums.PracticalApplicability | null
    userId?: UuidFilter<"Resource"> | string
    spaceId?: UuidNullableFilter<"Resource"> | string | null
    classificationId?: UuidNullableFilter<"Resource"> | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Resource"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    space?: XOR<SpaceNullableScalarRelationFilter, SpaceWhereInput> | null
    classification?: XOR<ClassificationNullableScalarRelationFilter, ClassificationWhereInput> | null
    contentSummaries?: ContentSummaryListRelationFilter
    vectorChunks?: VectorChunkListRelationFilter
    sourceOfRelationships?: ContentRelationshipListRelationFilter
    targetOfRelationships?: ContentRelationshipListRelationFilter
    learningAnalytics?: LearningAnalyticListRelationFilter
    versions?: ResourceVersionListRelationFilter
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    tags?: SortOrder
    domain?: SortOrder
    language?: SortOrder
    metadata?: SortOrder
    complexityLevel?: SortOrder
    estimatedReadTimeMinutes?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    processingStatus?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    actionDensity?: SortOrder
    noveltyScore?: SortOrderInput | SortOrder
    practicalApplicability?: SortOrderInput | SortOrder
    userId?: SortOrder
    spaceId?: SortOrderInput | SortOrder
    classificationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    space?: SpaceOrderByWithRelationInput
    classification?: ClassificationOrderByWithRelationInput
    contentSummaries?: ContentSummaryOrderByRelationAggregateInput
    vectorChunks?: VectorChunkOrderByRelationAggregateInput
    sourceOfRelationships?: ContentRelationshipOrderByRelationAggregateInput
    targetOfRelationships?: ContentRelationshipOrderByRelationAggregateInput
    learningAnalytics?: LearningAnalyticOrderByRelationAggregateInput
    versions?: ResourceVersionOrderByRelationAggregateInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    url?: StringNullableFilter<"Resource"> | string | null
    type?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    content?: StringNullableFilter<"Resource"> | string | null
    tags?: StringNullableListFilter<"Resource">
    domain?: EnumContentDomainFilter<"Resource"> | $Enums.ContentDomain
    language?: StringFilter<"Resource"> | string
    metadata?: JsonFilter<"Resource">
    complexityLevel?: EnumComplexityLevelFilter<"Resource"> | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: IntNullableFilter<"Resource"> | number | null
    wordCount?: IntNullableFilter<"Resource"> | number | null
    processingStatus?: EnumProcessingStatusFilter<"Resource"> | $Enums.ProcessingStatus
    processedAt?: DateTimeNullableFilter<"Resource"> | Date | string | null
    actionDensity?: EnumActionDensityFilter<"Resource"> | $Enums.ActionDensity
    noveltyScore?: IntNullableFilter<"Resource"> | number | null
    practicalApplicability?: EnumPracticalApplicabilityNullableFilter<"Resource"> | $Enums.PracticalApplicability | null
    userId?: UuidFilter<"Resource"> | string
    spaceId?: UuidNullableFilter<"Resource"> | string | null
    classificationId?: UuidNullableFilter<"Resource"> | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Resource"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    space?: XOR<SpaceNullableScalarRelationFilter, SpaceWhereInput> | null
    classification?: XOR<ClassificationNullableScalarRelationFilter, ClassificationWhereInput> | null
    contentSummaries?: ContentSummaryListRelationFilter
    vectorChunks?: VectorChunkListRelationFilter
    sourceOfRelationships?: ContentRelationshipListRelationFilter
    targetOfRelationships?: ContentRelationshipListRelationFilter
    learningAnalytics?: LearningAnalyticListRelationFilter
    versions?: ResourceVersionListRelationFilter
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    tags?: SortOrder
    domain?: SortOrder
    language?: SortOrder
    metadata?: SortOrder
    complexityLevel?: SortOrder
    estimatedReadTimeMinutes?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    processingStatus?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    actionDensity?: SortOrder
    noveltyScore?: SortOrderInput | SortOrder
    practicalApplicability?: SortOrderInput | SortOrder
    userId?: SortOrder
    spaceId?: SortOrderInput | SortOrder
    classificationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Resource"> | string
    title?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    url?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    type?: EnumResourceTypeWithAggregatesFilter<"Resource"> | $Enums.ResourceType
    content?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    tags?: StringNullableListFilter<"Resource">
    domain?: EnumContentDomainWithAggregatesFilter<"Resource"> | $Enums.ContentDomain
    language?: StringWithAggregatesFilter<"Resource"> | string
    metadata?: JsonWithAggregatesFilter<"Resource">
    complexityLevel?: EnumComplexityLevelWithAggregatesFilter<"Resource"> | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: IntNullableWithAggregatesFilter<"Resource"> | number | null
    wordCount?: IntNullableWithAggregatesFilter<"Resource"> | number | null
    processingStatus?: EnumProcessingStatusWithAggregatesFilter<"Resource"> | $Enums.ProcessingStatus
    processedAt?: DateTimeNullableWithAggregatesFilter<"Resource"> | Date | string | null
    actionDensity?: EnumActionDensityWithAggregatesFilter<"Resource"> | $Enums.ActionDensity
    noveltyScore?: IntNullableWithAggregatesFilter<"Resource"> | number | null
    practicalApplicability?: EnumPracticalApplicabilityNullableWithAggregatesFilter<"Resource"> | $Enums.PracticalApplicability | null
    userId?: UuidWithAggregatesFilter<"Resource"> | string
    spaceId?: UuidNullableWithAggregatesFilter<"Resource"> | string | null
    classificationId?: UuidNullableWithAggregatesFilter<"Resource"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Resource"> | Date | string | null
  }

  export type ResourceVersionWhereInput = {
    AND?: ResourceVersionWhereInput | ResourceVersionWhereInput[]
    OR?: ResourceVersionWhereInput[]
    NOT?: ResourceVersionWhereInput | ResourceVersionWhereInput[]
    id?: UuidFilter<"ResourceVersion"> | string
    versionNumber?: IntFilter<"ResourceVersion"> | number
    title?: StringFilter<"ResourceVersion"> | string
    content?: StringNullableFilter<"ResourceVersion"> | string | null
    tags?: StringNullableListFilter<"ResourceVersion">
    metadata?: JsonFilter<"ResourceVersion">
    resourceId?: UuidFilter<"ResourceVersion"> | string
    createdBy?: UuidNullableFilter<"ResourceVersion"> | string | null
    createdAt?: DateTimeFilter<"ResourceVersion"> | Date | string
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ResourceVersionOrderByWithRelationInput = {
    id?: SortOrder
    versionNumber?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    resourceId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resource?: ResourceOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type ResourceVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    resourceId_versionNumber?: ResourceVersionResourceIdVersionNumberCompoundUniqueInput
    AND?: ResourceVersionWhereInput | ResourceVersionWhereInput[]
    OR?: ResourceVersionWhereInput[]
    NOT?: ResourceVersionWhereInput | ResourceVersionWhereInput[]
    versionNumber?: IntFilter<"ResourceVersion"> | number
    title?: StringFilter<"ResourceVersion"> | string
    content?: StringNullableFilter<"ResourceVersion"> | string | null
    tags?: StringNullableListFilter<"ResourceVersion">
    metadata?: JsonFilter<"ResourceVersion">
    resourceId?: UuidFilter<"ResourceVersion"> | string
    createdBy?: UuidNullableFilter<"ResourceVersion"> | string | null
    createdAt?: DateTimeFilter<"ResourceVersion"> | Date | string
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "resourceId_versionNumber">

  export type ResourceVersionOrderByWithAggregationInput = {
    id?: SortOrder
    versionNumber?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    resourceId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ResourceVersionCountOrderByAggregateInput
    _avg?: ResourceVersionAvgOrderByAggregateInput
    _max?: ResourceVersionMaxOrderByAggregateInput
    _min?: ResourceVersionMinOrderByAggregateInput
    _sum?: ResourceVersionSumOrderByAggregateInput
  }

  export type ResourceVersionScalarWhereWithAggregatesInput = {
    AND?: ResourceVersionScalarWhereWithAggregatesInput | ResourceVersionScalarWhereWithAggregatesInput[]
    OR?: ResourceVersionScalarWhereWithAggregatesInput[]
    NOT?: ResourceVersionScalarWhereWithAggregatesInput | ResourceVersionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ResourceVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"ResourceVersion"> | number
    title?: StringWithAggregatesFilter<"ResourceVersion"> | string
    content?: StringNullableWithAggregatesFilter<"ResourceVersion"> | string | null
    tags?: StringNullableListFilter<"ResourceVersion">
    metadata?: JsonWithAggregatesFilter<"ResourceVersion">
    resourceId?: UuidWithAggregatesFilter<"ResourceVersion"> | string
    createdBy?: UuidNullableWithAggregatesFilter<"ResourceVersion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ResourceVersion"> | Date | string
  }

  export type ClassificationWhereInput = {
    AND?: ClassificationWhereInput | ClassificationWhereInput[]
    OR?: ClassificationWhereInput[]
    NOT?: ClassificationWhereInput | ClassificationWhereInput[]
    id?: UuidFilter<"Classification"> | string
    name?: StringFilter<"Classification"> | string
    code?: StringFilter<"Classification"> | string
    description?: StringNullableFilter<"Classification"> | string | null
    domain?: EnumContentDomainFilter<"Classification"> | $Enums.ContentDomain
    usageCount?: IntFilter<"Classification"> | number
    isSystemDefault?: BoolFilter<"Classification"> | boolean
    parentId?: UuidNullableFilter<"Classification"> | string | null
    createdAt?: DateTimeFilter<"Classification"> | Date | string
    updatedAt?: DateTimeFilter<"Classification"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Classification"> | Date | string | null
    parent?: XOR<ClassificationNullableScalarRelationFilter, ClassificationWhereInput> | null
    children?: ClassificationListRelationFilter
    resources?: ResourceListRelationFilter
  }

  export type ClassificationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    domain?: SortOrder
    usageCount?: SortOrder
    isSystemDefault?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    parent?: ClassificationOrderByWithRelationInput
    children?: ClassificationOrderByRelationAggregateInput
    resources?: ResourceOrderByRelationAggregateInput
  }

  export type ClassificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ClassificationWhereInput | ClassificationWhereInput[]
    OR?: ClassificationWhereInput[]
    NOT?: ClassificationWhereInput | ClassificationWhereInput[]
    name?: StringFilter<"Classification"> | string
    description?: StringNullableFilter<"Classification"> | string | null
    domain?: EnumContentDomainFilter<"Classification"> | $Enums.ContentDomain
    usageCount?: IntFilter<"Classification"> | number
    isSystemDefault?: BoolFilter<"Classification"> | boolean
    parentId?: UuidNullableFilter<"Classification"> | string | null
    createdAt?: DateTimeFilter<"Classification"> | Date | string
    updatedAt?: DateTimeFilter<"Classification"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Classification"> | Date | string | null
    parent?: XOR<ClassificationNullableScalarRelationFilter, ClassificationWhereInput> | null
    children?: ClassificationListRelationFilter
    resources?: ResourceListRelationFilter
  }, "id" | "code">

  export type ClassificationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    domain?: SortOrder
    usageCount?: SortOrder
    isSystemDefault?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ClassificationCountOrderByAggregateInput
    _avg?: ClassificationAvgOrderByAggregateInput
    _max?: ClassificationMaxOrderByAggregateInput
    _min?: ClassificationMinOrderByAggregateInput
    _sum?: ClassificationSumOrderByAggregateInput
  }

  export type ClassificationScalarWhereWithAggregatesInput = {
    AND?: ClassificationScalarWhereWithAggregatesInput | ClassificationScalarWhereWithAggregatesInput[]
    OR?: ClassificationScalarWhereWithAggregatesInput[]
    NOT?: ClassificationScalarWhereWithAggregatesInput | ClassificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Classification"> | string
    name?: StringWithAggregatesFilter<"Classification"> | string
    code?: StringWithAggregatesFilter<"Classification"> | string
    description?: StringNullableWithAggregatesFilter<"Classification"> | string | null
    domain?: EnumContentDomainWithAggregatesFilter<"Classification"> | $Enums.ContentDomain
    usageCount?: IntWithAggregatesFilter<"Classification"> | number
    isSystemDefault?: BoolWithAggregatesFilter<"Classification"> | boolean
    parentId?: UuidNullableWithAggregatesFilter<"Classification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Classification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Classification"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Classification"> | Date | string | null
  }

  export type ContentSummaryWhereInput = {
    AND?: ContentSummaryWhereInput | ContentSummaryWhereInput[]
    OR?: ContentSummaryWhereInput[]
    NOT?: ContentSummaryWhereInput | ContentSummaryWhereInput[]
    id?: UuidFilter<"ContentSummary"> | string
    executiveSummary?: StringFilter<"ContentSummary"> | string
    keyInsights?: StringNullableFilter<"ContentSummary"> | string | null
    immediateActions?: StringNullableFilter<"ContentSummary"> | string | null
    criticalWarnings?: StringNullableFilter<"ContentSummary"> | string | null
    keyMetrics?: JsonFilter<"ContentSummary">
    toolsResources?: JsonFilter<"ContentSummary">
    peopleCompanies?: StringNullableListFilter<"ContentSummary">
    primaryKeywords?: StringNullableListFilter<"ContentSummary">
    semanticTags?: StringNullableListFilter<"ContentSummary">
    questionBasedTags?: StringNullableListFilter<"ContentSummary">
    totalChunks?: IntFilter<"ContentSummary"> | number
    embeddingModel?: StringFilter<"ContentSummary"> | string
    avgChunkTokens?: IntNullableFilter<"ContentSummary"> | number | null
    resourceId?: UuidFilter<"ContentSummary"> | string
    createdAt?: DateTimeFilter<"ContentSummary"> | Date | string
    updatedAt?: DateTimeFilter<"ContentSummary"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ContentSummary"> | Date | string | null
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    vectorChunks?: VectorChunkListRelationFilter
  }

  export type ContentSummaryOrderByWithRelationInput = {
    id?: SortOrder
    executiveSummary?: SortOrder
    keyInsights?: SortOrderInput | SortOrder
    immediateActions?: SortOrderInput | SortOrder
    criticalWarnings?: SortOrderInput | SortOrder
    keyMetrics?: SortOrder
    toolsResources?: SortOrder
    peopleCompanies?: SortOrder
    primaryKeywords?: SortOrder
    semanticTags?: SortOrder
    questionBasedTags?: SortOrder
    totalChunks?: SortOrder
    embeddingModel?: SortOrder
    avgChunkTokens?: SortOrderInput | SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    resource?: ResourceOrderByWithRelationInput
    vectorChunks?: VectorChunkOrderByRelationAggregateInput
  }

  export type ContentSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentSummaryWhereInput | ContentSummaryWhereInput[]
    OR?: ContentSummaryWhereInput[]
    NOT?: ContentSummaryWhereInput | ContentSummaryWhereInput[]
    executiveSummary?: StringFilter<"ContentSummary"> | string
    keyInsights?: StringNullableFilter<"ContentSummary"> | string | null
    immediateActions?: StringNullableFilter<"ContentSummary"> | string | null
    criticalWarnings?: StringNullableFilter<"ContentSummary"> | string | null
    keyMetrics?: JsonFilter<"ContentSummary">
    toolsResources?: JsonFilter<"ContentSummary">
    peopleCompanies?: StringNullableListFilter<"ContentSummary">
    primaryKeywords?: StringNullableListFilter<"ContentSummary">
    semanticTags?: StringNullableListFilter<"ContentSummary">
    questionBasedTags?: StringNullableListFilter<"ContentSummary">
    totalChunks?: IntFilter<"ContentSummary"> | number
    embeddingModel?: StringFilter<"ContentSummary"> | string
    avgChunkTokens?: IntNullableFilter<"ContentSummary"> | number | null
    resourceId?: UuidFilter<"ContentSummary"> | string
    createdAt?: DateTimeFilter<"ContentSummary"> | Date | string
    updatedAt?: DateTimeFilter<"ContentSummary"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ContentSummary"> | Date | string | null
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    vectorChunks?: VectorChunkListRelationFilter
  }, "id">

  export type ContentSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    executiveSummary?: SortOrder
    keyInsights?: SortOrderInput | SortOrder
    immediateActions?: SortOrderInput | SortOrder
    criticalWarnings?: SortOrderInput | SortOrder
    keyMetrics?: SortOrder
    toolsResources?: SortOrder
    peopleCompanies?: SortOrder
    primaryKeywords?: SortOrder
    semanticTags?: SortOrder
    questionBasedTags?: SortOrder
    totalChunks?: SortOrder
    embeddingModel?: SortOrder
    avgChunkTokens?: SortOrderInput | SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ContentSummaryCountOrderByAggregateInput
    _avg?: ContentSummaryAvgOrderByAggregateInput
    _max?: ContentSummaryMaxOrderByAggregateInput
    _min?: ContentSummaryMinOrderByAggregateInput
    _sum?: ContentSummarySumOrderByAggregateInput
  }

  export type ContentSummaryScalarWhereWithAggregatesInput = {
    AND?: ContentSummaryScalarWhereWithAggregatesInput | ContentSummaryScalarWhereWithAggregatesInput[]
    OR?: ContentSummaryScalarWhereWithAggregatesInput[]
    NOT?: ContentSummaryScalarWhereWithAggregatesInput | ContentSummaryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ContentSummary"> | string
    executiveSummary?: StringWithAggregatesFilter<"ContentSummary"> | string
    keyInsights?: StringNullableWithAggregatesFilter<"ContentSummary"> | string | null
    immediateActions?: StringNullableWithAggregatesFilter<"ContentSummary"> | string | null
    criticalWarnings?: StringNullableWithAggregatesFilter<"ContentSummary"> | string | null
    keyMetrics?: JsonWithAggregatesFilter<"ContentSummary">
    toolsResources?: JsonWithAggregatesFilter<"ContentSummary">
    peopleCompanies?: StringNullableListFilter<"ContentSummary">
    primaryKeywords?: StringNullableListFilter<"ContentSummary">
    semanticTags?: StringNullableListFilter<"ContentSummary">
    questionBasedTags?: StringNullableListFilter<"ContentSummary">
    totalChunks?: IntWithAggregatesFilter<"ContentSummary"> | number
    embeddingModel?: StringWithAggregatesFilter<"ContentSummary"> | string
    avgChunkTokens?: IntNullableWithAggregatesFilter<"ContentSummary"> | number | null
    resourceId?: UuidWithAggregatesFilter<"ContentSummary"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContentSummary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentSummary"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ContentSummary"> | Date | string | null
  }

  export type VectorChunkWhereInput = {
    AND?: VectorChunkWhereInput | VectorChunkWhereInput[]
    OR?: VectorChunkWhereInput[]
    NOT?: VectorChunkWhereInput | VectorChunkWhereInput[]
    id?: UuidFilter<"VectorChunk"> | string
    chunkIndex?: IntFilter<"VectorChunk"> | number
    chunkType?: EnumChunkTypeFilter<"VectorChunk"> | $Enums.ChunkType
    content?: StringFilter<"VectorChunk"> | string
    tokenCount?: IntFilter<"VectorChunk"> | number
    pineconeId?: StringNullableFilter<"VectorChunk"> | string | null
    pineconeNamespace?: StringNullableFilter<"VectorChunk"> | string | null
    embeddingModel?: StringFilter<"VectorChunk"> | string
    vectorDimension?: IntFilter<"VectorChunk"> | number
    overlappingChunks?: StringNullableListFilter<"VectorChunk">
    semanticDensity?: DecimalNullableFilter<"VectorChunk"> | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFilter<"VectorChunk"> | number
    lastRetrieved?: DateTimeNullableFilter<"VectorChunk"> | Date | string | null
    resourceId?: UuidFilter<"VectorChunk"> | string
    summaryId?: UuidFilter<"VectorChunk"> | string
    parentChunkId?: UuidNullableFilter<"VectorChunk"> | string | null
    createdAt?: DateTimeFilter<"VectorChunk"> | Date | string
    updatedAt?: DateTimeFilter<"VectorChunk"> | Date | string
    deletedAt?: DateTimeNullableFilter<"VectorChunk"> | Date | string | null
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    summary?: XOR<ContentSummaryScalarRelationFilter, ContentSummaryWhereInput>
    parentChunk?: XOR<VectorChunkNullableScalarRelationFilter, VectorChunkWhereInput> | null
    childChunks?: VectorChunkListRelationFilter
  }

  export type VectorChunkOrderByWithRelationInput = {
    id?: SortOrder
    chunkIndex?: SortOrder
    chunkType?: SortOrder
    content?: SortOrder
    tokenCount?: SortOrder
    pineconeId?: SortOrderInput | SortOrder
    pineconeNamespace?: SortOrderInput | SortOrder
    embeddingModel?: SortOrder
    vectorDimension?: SortOrder
    overlappingChunks?: SortOrder
    semanticDensity?: SortOrderInput | SortOrder
    retrievalFrequency?: SortOrder
    lastRetrieved?: SortOrderInput | SortOrder
    resourceId?: SortOrder
    summaryId?: SortOrder
    parentChunkId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    resource?: ResourceOrderByWithRelationInput
    summary?: ContentSummaryOrderByWithRelationInput
    parentChunk?: VectorChunkOrderByWithRelationInput
    childChunks?: VectorChunkOrderByRelationAggregateInput
  }

  export type VectorChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pineconeId?: string
    AND?: VectorChunkWhereInput | VectorChunkWhereInput[]
    OR?: VectorChunkWhereInput[]
    NOT?: VectorChunkWhereInput | VectorChunkWhereInput[]
    chunkIndex?: IntFilter<"VectorChunk"> | number
    chunkType?: EnumChunkTypeFilter<"VectorChunk"> | $Enums.ChunkType
    content?: StringFilter<"VectorChunk"> | string
    tokenCount?: IntFilter<"VectorChunk"> | number
    pineconeNamespace?: StringNullableFilter<"VectorChunk"> | string | null
    embeddingModel?: StringFilter<"VectorChunk"> | string
    vectorDimension?: IntFilter<"VectorChunk"> | number
    overlappingChunks?: StringNullableListFilter<"VectorChunk">
    semanticDensity?: DecimalNullableFilter<"VectorChunk"> | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFilter<"VectorChunk"> | number
    lastRetrieved?: DateTimeNullableFilter<"VectorChunk"> | Date | string | null
    resourceId?: UuidFilter<"VectorChunk"> | string
    summaryId?: UuidFilter<"VectorChunk"> | string
    parentChunkId?: UuidNullableFilter<"VectorChunk"> | string | null
    createdAt?: DateTimeFilter<"VectorChunk"> | Date | string
    updatedAt?: DateTimeFilter<"VectorChunk"> | Date | string
    deletedAt?: DateTimeNullableFilter<"VectorChunk"> | Date | string | null
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    summary?: XOR<ContentSummaryScalarRelationFilter, ContentSummaryWhereInput>
    parentChunk?: XOR<VectorChunkNullableScalarRelationFilter, VectorChunkWhereInput> | null
    childChunks?: VectorChunkListRelationFilter
  }, "id" | "pineconeId">

  export type VectorChunkOrderByWithAggregationInput = {
    id?: SortOrder
    chunkIndex?: SortOrder
    chunkType?: SortOrder
    content?: SortOrder
    tokenCount?: SortOrder
    pineconeId?: SortOrderInput | SortOrder
    pineconeNamespace?: SortOrderInput | SortOrder
    embeddingModel?: SortOrder
    vectorDimension?: SortOrder
    overlappingChunks?: SortOrder
    semanticDensity?: SortOrderInput | SortOrder
    retrievalFrequency?: SortOrder
    lastRetrieved?: SortOrderInput | SortOrder
    resourceId?: SortOrder
    summaryId?: SortOrder
    parentChunkId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: VectorChunkCountOrderByAggregateInput
    _avg?: VectorChunkAvgOrderByAggregateInput
    _max?: VectorChunkMaxOrderByAggregateInput
    _min?: VectorChunkMinOrderByAggregateInput
    _sum?: VectorChunkSumOrderByAggregateInput
  }

  export type VectorChunkScalarWhereWithAggregatesInput = {
    AND?: VectorChunkScalarWhereWithAggregatesInput | VectorChunkScalarWhereWithAggregatesInput[]
    OR?: VectorChunkScalarWhereWithAggregatesInput[]
    NOT?: VectorChunkScalarWhereWithAggregatesInput | VectorChunkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VectorChunk"> | string
    chunkIndex?: IntWithAggregatesFilter<"VectorChunk"> | number
    chunkType?: EnumChunkTypeWithAggregatesFilter<"VectorChunk"> | $Enums.ChunkType
    content?: StringWithAggregatesFilter<"VectorChunk"> | string
    tokenCount?: IntWithAggregatesFilter<"VectorChunk"> | number
    pineconeId?: StringNullableWithAggregatesFilter<"VectorChunk"> | string | null
    pineconeNamespace?: StringNullableWithAggregatesFilter<"VectorChunk"> | string | null
    embeddingModel?: StringWithAggregatesFilter<"VectorChunk"> | string
    vectorDimension?: IntWithAggregatesFilter<"VectorChunk"> | number
    overlappingChunks?: StringNullableListFilter<"VectorChunk">
    semanticDensity?: DecimalNullableWithAggregatesFilter<"VectorChunk"> | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntWithAggregatesFilter<"VectorChunk"> | number
    lastRetrieved?: DateTimeNullableWithAggregatesFilter<"VectorChunk"> | Date | string | null
    resourceId?: UuidWithAggregatesFilter<"VectorChunk"> | string
    summaryId?: UuidWithAggregatesFilter<"VectorChunk"> | string
    parentChunkId?: UuidNullableWithAggregatesFilter<"VectorChunk"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VectorChunk"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VectorChunk"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"VectorChunk"> | Date | string | null
  }

  export type ContentRelationshipWhereInput = {
    AND?: ContentRelationshipWhereInput | ContentRelationshipWhereInput[]
    OR?: ContentRelationshipWhereInput[]
    NOT?: ContentRelationshipWhereInput | ContentRelationshipWhereInput[]
    id?: UuidFilter<"ContentRelationship"> | string
    relationshipType?: EnumRelationshipTypeFilter<"ContentRelationship"> | $Enums.RelationshipType
    confidenceScore?: DecimalFilter<"ContentRelationship"> | Decimal | DecimalJsLike | number | string
    relationshipReason?: StringNullableFilter<"ContentRelationship"> | string | null
    isAutoGenerated?: BoolFilter<"ContentRelationship"> | boolean
    sourceResourceId?: UuidFilter<"ContentRelationship"> | string
    targetResourceId?: UuidFilter<"ContentRelationship"> | string
    createdBy?: UuidNullableFilter<"ContentRelationship"> | string | null
    createdAt?: DateTimeFilter<"ContentRelationship"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ContentRelationship"> | Date | string | null
    sourceResource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    targetResource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ContentRelationshipOrderByWithRelationInput = {
    id?: SortOrder
    relationshipType?: SortOrder
    confidenceScore?: SortOrder
    relationshipReason?: SortOrderInput | SortOrder
    isAutoGenerated?: SortOrder
    sourceResourceId?: SortOrder
    targetResourceId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    sourceResource?: ResourceOrderByWithRelationInput
    targetResource?: ResourceOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type ContentRelationshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentRelationshipWhereInput | ContentRelationshipWhereInput[]
    OR?: ContentRelationshipWhereInput[]
    NOT?: ContentRelationshipWhereInput | ContentRelationshipWhereInput[]
    relationshipType?: EnumRelationshipTypeFilter<"ContentRelationship"> | $Enums.RelationshipType
    confidenceScore?: DecimalFilter<"ContentRelationship"> | Decimal | DecimalJsLike | number | string
    relationshipReason?: StringNullableFilter<"ContentRelationship"> | string | null
    isAutoGenerated?: BoolFilter<"ContentRelationship"> | boolean
    sourceResourceId?: UuidFilter<"ContentRelationship"> | string
    targetResourceId?: UuidFilter<"ContentRelationship"> | string
    createdBy?: UuidNullableFilter<"ContentRelationship"> | string | null
    createdAt?: DateTimeFilter<"ContentRelationship"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ContentRelationship"> | Date | string | null
    sourceResource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    targetResource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ContentRelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    relationshipType?: SortOrder
    confidenceScore?: SortOrder
    relationshipReason?: SortOrderInput | SortOrder
    isAutoGenerated?: SortOrder
    sourceResourceId?: SortOrder
    targetResourceId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ContentRelationshipCountOrderByAggregateInput
    _avg?: ContentRelationshipAvgOrderByAggregateInput
    _max?: ContentRelationshipMaxOrderByAggregateInput
    _min?: ContentRelationshipMinOrderByAggregateInput
    _sum?: ContentRelationshipSumOrderByAggregateInput
  }

  export type ContentRelationshipScalarWhereWithAggregatesInput = {
    AND?: ContentRelationshipScalarWhereWithAggregatesInput | ContentRelationshipScalarWhereWithAggregatesInput[]
    OR?: ContentRelationshipScalarWhereWithAggregatesInput[]
    NOT?: ContentRelationshipScalarWhereWithAggregatesInput | ContentRelationshipScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ContentRelationship"> | string
    relationshipType?: EnumRelationshipTypeWithAggregatesFilter<"ContentRelationship"> | $Enums.RelationshipType
    confidenceScore?: DecimalWithAggregatesFilter<"ContentRelationship"> | Decimal | DecimalJsLike | number | string
    relationshipReason?: StringNullableWithAggregatesFilter<"ContentRelationship"> | string | null
    isAutoGenerated?: BoolWithAggregatesFilter<"ContentRelationship"> | boolean
    sourceResourceId?: UuidWithAggregatesFilter<"ContentRelationship"> | string
    targetResourceId?: UuidWithAggregatesFilter<"ContentRelationship"> | string
    createdBy?: UuidNullableWithAggregatesFilter<"ContentRelationship"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContentRelationship"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ContentRelationship"> | Date | string | null
  }

  export type KnowledgeNodeWhereInput = {
    AND?: KnowledgeNodeWhereInput | KnowledgeNodeWhereInput[]
    OR?: KnowledgeNodeWhereInput[]
    NOT?: KnowledgeNodeWhereInput | KnowledgeNodeWhereInput[]
    id?: UuidFilter<"KnowledgeNode"> | string
    name?: StringFilter<"KnowledgeNode"> | string
    type?: StringFilter<"KnowledgeNode"> | string
    description?: StringNullableFilter<"KnowledgeNode"> | string | null
    domain?: EnumContentDomainNullableFilter<"KnowledgeNode"> | $Enums.ContentDomain | null
    importanceScore?: IntFilter<"KnowledgeNode"> | number
    mentionFrequency?: IntFilter<"KnowledgeNode"> | number
    mentionedInResources?: StringNullableListFilter<"KnowledgeNode">
    firstMentionedDate?: DateTimeFilter<"KnowledgeNode"> | Date | string
    lastMentionedDate?: DateTimeFilter<"KnowledgeNode"> | Date | string
    createdAt?: DateTimeFilter<"KnowledgeNode"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeNode"> | Date | string
    deletedAt?: DateTimeNullableFilter<"KnowledgeNode"> | Date | string | null
    sourceKnowledgeEdges?: KnowledgeEdgeListRelationFilter
    targetKnowledgeEdges?: KnowledgeEdgeListRelationFilter
  }

  export type KnowledgeNodeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    domain?: SortOrderInput | SortOrder
    importanceScore?: SortOrder
    mentionFrequency?: SortOrder
    mentionedInResources?: SortOrder
    firstMentionedDate?: SortOrder
    lastMentionedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    sourceKnowledgeEdges?: KnowledgeEdgeOrderByRelationAggregateInput
    targetKnowledgeEdges?: KnowledgeEdgeOrderByRelationAggregateInput
  }

  export type KnowledgeNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: KnowledgeNodeWhereInput | KnowledgeNodeWhereInput[]
    OR?: KnowledgeNodeWhereInput[]
    NOT?: KnowledgeNodeWhereInput | KnowledgeNodeWhereInput[]
    type?: StringFilter<"KnowledgeNode"> | string
    description?: StringNullableFilter<"KnowledgeNode"> | string | null
    domain?: EnumContentDomainNullableFilter<"KnowledgeNode"> | $Enums.ContentDomain | null
    importanceScore?: IntFilter<"KnowledgeNode"> | number
    mentionFrequency?: IntFilter<"KnowledgeNode"> | number
    mentionedInResources?: StringNullableListFilter<"KnowledgeNode">
    firstMentionedDate?: DateTimeFilter<"KnowledgeNode"> | Date | string
    lastMentionedDate?: DateTimeFilter<"KnowledgeNode"> | Date | string
    createdAt?: DateTimeFilter<"KnowledgeNode"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeNode"> | Date | string
    deletedAt?: DateTimeNullableFilter<"KnowledgeNode"> | Date | string | null
    sourceKnowledgeEdges?: KnowledgeEdgeListRelationFilter
    targetKnowledgeEdges?: KnowledgeEdgeListRelationFilter
  }, "id" | "name">

  export type KnowledgeNodeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    domain?: SortOrderInput | SortOrder
    importanceScore?: SortOrder
    mentionFrequency?: SortOrder
    mentionedInResources?: SortOrder
    firstMentionedDate?: SortOrder
    lastMentionedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: KnowledgeNodeCountOrderByAggregateInput
    _avg?: KnowledgeNodeAvgOrderByAggregateInput
    _max?: KnowledgeNodeMaxOrderByAggregateInput
    _min?: KnowledgeNodeMinOrderByAggregateInput
    _sum?: KnowledgeNodeSumOrderByAggregateInput
  }

  export type KnowledgeNodeScalarWhereWithAggregatesInput = {
    AND?: KnowledgeNodeScalarWhereWithAggregatesInput | KnowledgeNodeScalarWhereWithAggregatesInput[]
    OR?: KnowledgeNodeScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeNodeScalarWhereWithAggregatesInput | KnowledgeNodeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"KnowledgeNode"> | string
    name?: StringWithAggregatesFilter<"KnowledgeNode"> | string
    type?: StringWithAggregatesFilter<"KnowledgeNode"> | string
    description?: StringNullableWithAggregatesFilter<"KnowledgeNode"> | string | null
    domain?: EnumContentDomainNullableWithAggregatesFilter<"KnowledgeNode"> | $Enums.ContentDomain | null
    importanceScore?: IntWithAggregatesFilter<"KnowledgeNode"> | number
    mentionFrequency?: IntWithAggregatesFilter<"KnowledgeNode"> | number
    mentionedInResources?: StringNullableListFilter<"KnowledgeNode">
    firstMentionedDate?: DateTimeWithAggregatesFilter<"KnowledgeNode"> | Date | string
    lastMentionedDate?: DateTimeWithAggregatesFilter<"KnowledgeNode"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeNode"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"KnowledgeNode"> | Date | string | null
  }

  export type KnowledgeEdgeWhereInput = {
    AND?: KnowledgeEdgeWhereInput | KnowledgeEdgeWhereInput[]
    OR?: KnowledgeEdgeWhereInput[]
    NOT?: KnowledgeEdgeWhereInput | KnowledgeEdgeWhereInput[]
    id?: UuidFilter<"KnowledgeEdge"> | string
    relationshipType?: EnumRelationshipTypeFilter<"KnowledgeEdge"> | $Enums.RelationshipType
    strength?: DecimalFilter<"KnowledgeEdge"> | Decimal | DecimalJsLike | number | string
    evidenceResources?: StringNullableListFilter<"KnowledgeEdge">
    isAutoGenerated?: BoolFilter<"KnowledgeEdge"> | boolean
    sourceNodeId?: UuidFilter<"KnowledgeEdge"> | string
    targetNodeId?: UuidFilter<"KnowledgeEdge"> | string
    createdBy?: UuidNullableFilter<"KnowledgeEdge"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeEdge"> | Date | string
    deletedAt?: DateTimeNullableFilter<"KnowledgeEdge"> | Date | string | null
    sourceNode?: XOR<KnowledgeNodeScalarRelationFilter, KnowledgeNodeWhereInput>
    targetNode?: XOR<KnowledgeNodeScalarRelationFilter, KnowledgeNodeWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type KnowledgeEdgeOrderByWithRelationInput = {
    id?: SortOrder
    relationshipType?: SortOrder
    strength?: SortOrder
    evidenceResources?: SortOrder
    isAutoGenerated?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    sourceNode?: KnowledgeNodeOrderByWithRelationInput
    targetNode?: KnowledgeNodeOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type KnowledgeEdgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeEdgeWhereInput | KnowledgeEdgeWhereInput[]
    OR?: KnowledgeEdgeWhereInput[]
    NOT?: KnowledgeEdgeWhereInput | KnowledgeEdgeWhereInput[]
    relationshipType?: EnumRelationshipTypeFilter<"KnowledgeEdge"> | $Enums.RelationshipType
    strength?: DecimalFilter<"KnowledgeEdge"> | Decimal | DecimalJsLike | number | string
    evidenceResources?: StringNullableListFilter<"KnowledgeEdge">
    isAutoGenerated?: BoolFilter<"KnowledgeEdge"> | boolean
    sourceNodeId?: UuidFilter<"KnowledgeEdge"> | string
    targetNodeId?: UuidFilter<"KnowledgeEdge"> | string
    createdBy?: UuidNullableFilter<"KnowledgeEdge"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeEdge"> | Date | string
    deletedAt?: DateTimeNullableFilter<"KnowledgeEdge"> | Date | string | null
    sourceNode?: XOR<KnowledgeNodeScalarRelationFilter, KnowledgeNodeWhereInput>
    targetNode?: XOR<KnowledgeNodeScalarRelationFilter, KnowledgeNodeWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type KnowledgeEdgeOrderByWithAggregationInput = {
    id?: SortOrder
    relationshipType?: SortOrder
    strength?: SortOrder
    evidenceResources?: SortOrder
    isAutoGenerated?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: KnowledgeEdgeCountOrderByAggregateInput
    _avg?: KnowledgeEdgeAvgOrderByAggregateInput
    _max?: KnowledgeEdgeMaxOrderByAggregateInput
    _min?: KnowledgeEdgeMinOrderByAggregateInput
    _sum?: KnowledgeEdgeSumOrderByAggregateInput
  }

  export type KnowledgeEdgeScalarWhereWithAggregatesInput = {
    AND?: KnowledgeEdgeScalarWhereWithAggregatesInput | KnowledgeEdgeScalarWhereWithAggregatesInput[]
    OR?: KnowledgeEdgeScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeEdgeScalarWhereWithAggregatesInput | KnowledgeEdgeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"KnowledgeEdge"> | string
    relationshipType?: EnumRelationshipTypeWithAggregatesFilter<"KnowledgeEdge"> | $Enums.RelationshipType
    strength?: DecimalWithAggregatesFilter<"KnowledgeEdge"> | Decimal | DecimalJsLike | number | string
    evidenceResources?: StringNullableListFilter<"KnowledgeEdge">
    isAutoGenerated?: BoolWithAggregatesFilter<"KnowledgeEdge"> | boolean
    sourceNodeId?: UuidWithAggregatesFilter<"KnowledgeEdge"> | string
    targetNodeId?: UuidWithAggregatesFilter<"KnowledgeEdge"> | string
    createdBy?: UuidNullableWithAggregatesFilter<"KnowledgeEdge"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeEdge"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"KnowledgeEdge"> | Date | string | null
  }

  export type SearchQueryWhereInput = {
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    id?: UuidFilter<"SearchQuery"> | string
    query?: StringFilter<"SearchQuery"> | string
    queryType?: StringFilter<"SearchQuery"> | string
    resultsCount?: IntFilter<"SearchQuery"> | number
    avgRelevanceScore?: DecimalNullableFilter<"SearchQuery"> | Decimal | DecimalJsLike | number | string | null
    clickedResults?: StringNullableListFilter<"SearchQuery">
    extractedIntent?: StringNullableFilter<"SearchQuery"> | string | null
    domainClassification?: EnumContentDomainNullableFilter<"SearchQuery"> | $Enums.ContentDomain | null
    complexityDetected?: EnumComplexityLevelNullableFilter<"SearchQuery"> | $Enums.ComplexityLevel | null
    responseTimeMs?: IntNullableFilter<"SearchQuery"> | number | null
    userSatisfaction?: IntNullableFilter<"SearchQuery"> | number | null
    userId?: UuidFilter<"SearchQuery"> | string
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SearchQueryOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    queryType?: SortOrder
    resultsCount?: SortOrder
    avgRelevanceScore?: SortOrderInput | SortOrder
    clickedResults?: SortOrder
    extractedIntent?: SortOrderInput | SortOrder
    domainClassification?: SortOrderInput | SortOrder
    complexityDetected?: SortOrderInput | SortOrder
    responseTimeMs?: SortOrderInput | SortOrder
    userSatisfaction?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SearchQueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    query?: StringFilter<"SearchQuery"> | string
    queryType?: StringFilter<"SearchQuery"> | string
    resultsCount?: IntFilter<"SearchQuery"> | number
    avgRelevanceScore?: DecimalNullableFilter<"SearchQuery"> | Decimal | DecimalJsLike | number | string | null
    clickedResults?: StringNullableListFilter<"SearchQuery">
    extractedIntent?: StringNullableFilter<"SearchQuery"> | string | null
    domainClassification?: EnumContentDomainNullableFilter<"SearchQuery"> | $Enums.ContentDomain | null
    complexityDetected?: EnumComplexityLevelNullableFilter<"SearchQuery"> | $Enums.ComplexityLevel | null
    responseTimeMs?: IntNullableFilter<"SearchQuery"> | number | null
    userSatisfaction?: IntNullableFilter<"SearchQuery"> | number | null
    userId?: UuidFilter<"SearchQuery"> | string
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SearchQueryOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    queryType?: SortOrder
    resultsCount?: SortOrder
    avgRelevanceScore?: SortOrderInput | SortOrder
    clickedResults?: SortOrder
    extractedIntent?: SortOrderInput | SortOrder
    domainClassification?: SortOrderInput | SortOrder
    complexityDetected?: SortOrderInput | SortOrder
    responseTimeMs?: SortOrderInput | SortOrder
    userSatisfaction?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: SearchQueryCountOrderByAggregateInput
    _avg?: SearchQueryAvgOrderByAggregateInput
    _max?: SearchQueryMaxOrderByAggregateInput
    _min?: SearchQueryMinOrderByAggregateInput
    _sum?: SearchQuerySumOrderByAggregateInput
  }

  export type SearchQueryScalarWhereWithAggregatesInput = {
    AND?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    OR?: SearchQueryScalarWhereWithAggregatesInput[]
    NOT?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SearchQuery"> | string
    query?: StringWithAggregatesFilter<"SearchQuery"> | string
    queryType?: StringWithAggregatesFilter<"SearchQuery"> | string
    resultsCount?: IntWithAggregatesFilter<"SearchQuery"> | number
    avgRelevanceScore?: DecimalNullableWithAggregatesFilter<"SearchQuery"> | Decimal | DecimalJsLike | number | string | null
    clickedResults?: StringNullableListFilter<"SearchQuery">
    extractedIntent?: StringNullableWithAggregatesFilter<"SearchQuery"> | string | null
    domainClassification?: EnumContentDomainNullableWithAggregatesFilter<"SearchQuery"> | $Enums.ContentDomain | null
    complexityDetected?: EnumComplexityLevelNullableWithAggregatesFilter<"SearchQuery"> | $Enums.ComplexityLevel | null
    responseTimeMs?: IntNullableWithAggregatesFilter<"SearchQuery"> | number | null
    userSatisfaction?: IntNullableWithAggregatesFilter<"SearchQuery"> | number | null
    userId?: UuidWithAggregatesFilter<"SearchQuery"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SearchQuery"> | Date | string
  }

  export type LearningAnalyticWhereInput = {
    AND?: LearningAnalyticWhereInput | LearningAnalyticWhereInput[]
    OR?: LearningAnalyticWhereInput[]
    NOT?: LearningAnalyticWhereInput | LearningAnalyticWhereInput[]
    id?: UuidFilter<"LearningAnalytic"> | string
    eventType?: StringFilter<"LearningAnalytic"> | string
    eventDetails?: JsonFilter<"LearningAnalytic">
    sessionId?: StringNullableFilter<"LearningAnalytic"> | string | null
    comprehensionLevel?: IntNullableFilter<"LearningAnalytic"> | number | null
    implementationStatus?: EnumImplementationStatusNullableFilter<"LearningAnalytic"> | $Enums.ImplementationStatus | null
    deviceType?: StringNullableFilter<"LearningAnalytic"> | string | null
    timeSpentSeconds?: IntNullableFilter<"LearningAnalytic"> | number | null
    referralSource?: StringNullableFilter<"LearningAnalytic"> | string | null
    userId?: UuidFilter<"LearningAnalytic"> | string
    resourceId?: UuidNullableFilter<"LearningAnalytic"> | string | null
    createdAt?: DateTimeFilter<"LearningAnalytic"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resource?: XOR<ResourceNullableScalarRelationFilter, ResourceWhereInput> | null
  }

  export type LearningAnalyticOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    eventDetails?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    comprehensionLevel?: SortOrderInput | SortOrder
    implementationStatus?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    timeSpentSeconds?: SortOrderInput | SortOrder
    referralSource?: SortOrderInput | SortOrder
    userId?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type LearningAnalyticWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningAnalyticWhereInput | LearningAnalyticWhereInput[]
    OR?: LearningAnalyticWhereInput[]
    NOT?: LearningAnalyticWhereInput | LearningAnalyticWhereInput[]
    eventType?: StringFilter<"LearningAnalytic"> | string
    eventDetails?: JsonFilter<"LearningAnalytic">
    sessionId?: StringNullableFilter<"LearningAnalytic"> | string | null
    comprehensionLevel?: IntNullableFilter<"LearningAnalytic"> | number | null
    implementationStatus?: EnumImplementationStatusNullableFilter<"LearningAnalytic"> | $Enums.ImplementationStatus | null
    deviceType?: StringNullableFilter<"LearningAnalytic"> | string | null
    timeSpentSeconds?: IntNullableFilter<"LearningAnalytic"> | number | null
    referralSource?: StringNullableFilter<"LearningAnalytic"> | string | null
    userId?: UuidFilter<"LearningAnalytic"> | string
    resourceId?: UuidNullableFilter<"LearningAnalytic"> | string | null
    createdAt?: DateTimeFilter<"LearningAnalytic"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    resource?: XOR<ResourceNullableScalarRelationFilter, ResourceWhereInput> | null
  }, "id">

  export type LearningAnalyticOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    eventDetails?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    comprehensionLevel?: SortOrderInput | SortOrder
    implementationStatus?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    timeSpentSeconds?: SortOrderInput | SortOrder
    referralSource?: SortOrderInput | SortOrder
    userId?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LearningAnalyticCountOrderByAggregateInput
    _avg?: LearningAnalyticAvgOrderByAggregateInput
    _max?: LearningAnalyticMaxOrderByAggregateInput
    _min?: LearningAnalyticMinOrderByAggregateInput
    _sum?: LearningAnalyticSumOrderByAggregateInput
  }

  export type LearningAnalyticScalarWhereWithAggregatesInput = {
    AND?: LearningAnalyticScalarWhereWithAggregatesInput | LearningAnalyticScalarWhereWithAggregatesInput[]
    OR?: LearningAnalyticScalarWhereWithAggregatesInput[]
    NOT?: LearningAnalyticScalarWhereWithAggregatesInput | LearningAnalyticScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LearningAnalytic"> | string
    eventType?: StringWithAggregatesFilter<"LearningAnalytic"> | string
    eventDetails?: JsonWithAggregatesFilter<"LearningAnalytic">
    sessionId?: StringNullableWithAggregatesFilter<"LearningAnalytic"> | string | null
    comprehensionLevel?: IntNullableWithAggregatesFilter<"LearningAnalytic"> | number | null
    implementationStatus?: EnumImplementationStatusNullableWithAggregatesFilter<"LearningAnalytic"> | $Enums.ImplementationStatus | null
    deviceType?: StringNullableWithAggregatesFilter<"LearningAnalytic"> | string | null
    timeSpentSeconds?: IntNullableWithAggregatesFilter<"LearningAnalytic"> | number | null
    referralSource?: StringNullableWithAggregatesFilter<"LearningAnalytic"> | string | null
    userId?: UuidWithAggregatesFilter<"LearningAnalytic"> | string
    resourceId?: UuidNullableWithAggregatesFilter<"LearningAnalytic"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LearningAnalytic"> | Date | string
  }

  export type BatchJobWhereInput = {
    AND?: BatchJobWhereInput | BatchJobWhereInput[]
    OR?: BatchJobWhereInput[]
    NOT?: BatchJobWhereInput | BatchJobWhereInput[]
    id?: UuidFilter<"BatchJob"> | string
    status?: EnumBatchJobStatusFilter<"BatchJob"> | $Enums.BatchJobStatus
    progress?: IntFilter<"BatchJob"> | number
    totalItems?: IntFilter<"BatchJob"> | number
    userId?: UuidFilter<"BatchJob"> | string
    createdAt?: DateTimeFilter<"BatchJob"> | Date | string
    updatedAt?: DateTimeFilter<"BatchJob"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BatchJobOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    totalItems?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BatchJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchJobWhereInput | BatchJobWhereInput[]
    OR?: BatchJobWhereInput[]
    NOT?: BatchJobWhereInput | BatchJobWhereInput[]
    status?: EnumBatchJobStatusFilter<"BatchJob"> | $Enums.BatchJobStatus
    progress?: IntFilter<"BatchJob"> | number
    totalItems?: IntFilter<"BatchJob"> | number
    userId?: UuidFilter<"BatchJob"> | string
    createdAt?: DateTimeFilter<"BatchJob"> | Date | string
    updatedAt?: DateTimeFilter<"BatchJob"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BatchJobOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    totalItems?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchJobCountOrderByAggregateInput
    _avg?: BatchJobAvgOrderByAggregateInput
    _max?: BatchJobMaxOrderByAggregateInput
    _min?: BatchJobMinOrderByAggregateInput
    _sum?: BatchJobSumOrderByAggregateInput
  }

  export type BatchJobScalarWhereWithAggregatesInput = {
    AND?: BatchJobScalarWhereWithAggregatesInput | BatchJobScalarWhereWithAggregatesInput[]
    OR?: BatchJobScalarWhereWithAggregatesInput[]
    NOT?: BatchJobScalarWhereWithAggregatesInput | BatchJobScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BatchJob"> | string
    status?: EnumBatchJobStatusWithAggregatesFilter<"BatchJob"> | $Enums.BatchJobStatus
    progress?: IntWithAggregatesFilter<"BatchJob"> | number
    totalItems?: IntWithAggregatesFilter<"BatchJob"> | number
    userId?: UuidWithAggregatesFilter<"BatchJob"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BatchJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BatchJob"> | Date | string
  }

  export type PromptLogWhereInput = {
    AND?: PromptLogWhereInput | PromptLogWhereInput[]
    OR?: PromptLogWhereInput[]
    NOT?: PromptLogWhereInput | PromptLogWhereInput[]
    id?: UuidFilter<"PromptLog"> | string
    queryText?: StringFilter<"PromptLog"> | string
    tier?: EnumPromptLogTierFilter<"PromptLog"> | $Enums.PromptLogTier
    response?: JsonNullableFilter<"PromptLog">
    error?: StringNullableFilter<"PromptLog"> | string | null
    latencyMs?: IntNullableFilter<"PromptLog"> | number | null
    userId?: UuidNullableFilter<"PromptLog"> | string | null
    createdAt?: DateTimeFilter<"PromptLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PromptLogOrderByWithRelationInput = {
    id?: SortOrder
    queryText?: SortOrder
    tier?: SortOrder
    response?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PromptLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromptLogWhereInput | PromptLogWhereInput[]
    OR?: PromptLogWhereInput[]
    NOT?: PromptLogWhereInput | PromptLogWhereInput[]
    queryText?: StringFilter<"PromptLog"> | string
    tier?: EnumPromptLogTierFilter<"PromptLog"> | $Enums.PromptLogTier
    response?: JsonNullableFilter<"PromptLog">
    error?: StringNullableFilter<"PromptLog"> | string | null
    latencyMs?: IntNullableFilter<"PromptLog"> | number | null
    userId?: UuidNullableFilter<"PromptLog"> | string | null
    createdAt?: DateTimeFilter<"PromptLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PromptLogOrderByWithAggregationInput = {
    id?: SortOrder
    queryText?: SortOrder
    tier?: SortOrder
    response?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    latencyMs?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PromptLogCountOrderByAggregateInput
    _avg?: PromptLogAvgOrderByAggregateInput
    _max?: PromptLogMaxOrderByAggregateInput
    _min?: PromptLogMinOrderByAggregateInput
    _sum?: PromptLogSumOrderByAggregateInput
  }

  export type PromptLogScalarWhereWithAggregatesInput = {
    AND?: PromptLogScalarWhereWithAggregatesInput | PromptLogScalarWhereWithAggregatesInput[]
    OR?: PromptLogScalarWhereWithAggregatesInput[]
    NOT?: PromptLogScalarWhereWithAggregatesInput | PromptLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PromptLog"> | string
    queryText?: StringWithAggregatesFilter<"PromptLog"> | string
    tier?: EnumPromptLogTierWithAggregatesFilter<"PromptLog"> | $Enums.PromptLogTier
    response?: JsonNullableWithAggregatesFilter<"PromptLog">
    error?: StringNullableWithAggregatesFilter<"PromptLog"> | string | null
    latencyMs?: IntNullableWithAggregatesFilter<"PromptLog"> | number | null
    userId?: UuidNullableWithAggregatesFilter<"PromptLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PromptLog"> | Date | string
  }

  export type ChangeLogWhereInput = {
    AND?: ChangeLogWhereInput | ChangeLogWhereInput[]
    OR?: ChangeLogWhereInput[]
    NOT?: ChangeLogWhereInput | ChangeLogWhereInput[]
    id?: UuidFilter<"ChangeLog"> | string
    changeType?: StringFilter<"ChangeLog"> | string
    changeDetails?: JsonFilter<"ChangeLog">
    userId?: UuidNullableFilter<"ChangeLog"> | string | null
    changedAt?: DateTimeFilter<"ChangeLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    changeType?: SortOrder
    changeDetails?: SortOrder
    userId?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChangeLogWhereInput | ChangeLogWhereInput[]
    OR?: ChangeLogWhereInput[]
    NOT?: ChangeLogWhereInput | ChangeLogWhereInput[]
    changeType?: StringFilter<"ChangeLog"> | string
    changeDetails?: JsonFilter<"ChangeLog">
    userId?: UuidNullableFilter<"ChangeLog"> | string | null
    changedAt?: DateTimeFilter<"ChangeLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    changeType?: SortOrder
    changeDetails?: SortOrder
    userId?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    _count?: ChangeLogCountOrderByAggregateInput
    _max?: ChangeLogMaxOrderByAggregateInput
    _min?: ChangeLogMinOrderByAggregateInput
  }

  export type ChangeLogScalarWhereWithAggregatesInput = {
    AND?: ChangeLogScalarWhereWithAggregatesInput | ChangeLogScalarWhereWithAggregatesInput[]
    OR?: ChangeLogScalarWhereWithAggregatesInput[]
    NOT?: ChangeLogScalarWhereWithAggregatesInput | ChangeLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ChangeLog"> | string
    changeType?: StringWithAggregatesFilter<"ChangeLog"> | string
    changeDetails?: JsonWithAggregatesFilter<"ChangeLog">
    userId?: UuidNullableWithAggregatesFilter<"ChangeLog"> | string | null
    changedAt?: DateTimeWithAggregatesFilter<"ChangeLog"> | Date | string
  }

  export type UserCreateInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    spaces?: SpaceCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileCreateInput = {
    email: string
    fullName?: string | null
    avatarUrl?: string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: number
    totalEmbeddings?: number
    monthlyQuotaUsed?: number
    lastActiveDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUser_profileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id: string
    email: string
    fullName?: string | null
    avatarUrl?: string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: number
    totalEmbeddings?: number
    monthlyQuotaUsed?: number
    lastActiveDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserProfileUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: IntFieldUpdateOperationsInput | number
    totalEmbeddings?: IntFieldUpdateOperationsInput | number
    monthlyQuotaUsed?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUser_profileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: IntFieldUpdateOperationsInput | number
    totalEmbeddings?: IntFieldUpdateOperationsInput | number
    monthlyQuotaUsed?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileCreateManyInput = {
    id: string
    email: string
    fullName?: string | null
    avatarUrl?: string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: number
    totalEmbeddings?: number
    monthlyQuotaUsed?: number
    lastActiveDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserProfileUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: IntFieldUpdateOperationsInput | number
    totalEmbeddings?: IntFieldUpdateOperationsInput | number
    monthlyQuotaUsed?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: IntFieldUpdateOperationsInput | number
    totalEmbeddings?: IntFieldUpdateOperationsInput | number
    monthlyQuotaUsed?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    domain: $Enums.ContentDomain
    isDefault?: boolean
    contentCount?: number
    lastAccessed?: Date | string
    pineconeNamespace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSpacesInput
    resources?: ResourceCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    domain: $Enums.ContentDomain
    isDefault?: boolean
    contentCount?: number
    lastAccessed?: Date | string
    pineconeNamespace?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resources?: ResourceUncheckedCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    contentCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSpacesNestedInput
    resources?: ResourceUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    contentCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resources?: ResourceUncheckedUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    domain: $Enums.ContentDomain
    isDefault?: boolean
    contentCount?: number
    lastAccessed?: Date | string
    pineconeNamespace?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SpaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    contentCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    contentCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResourceCreateInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutResourcesInput
    space?: SpaceCreateNestedOneWithoutResourcesInput
    classification?: ClassificationCreateNestedOneWithoutResourcesInput
    contentSummaries?: ContentSummaryCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    spaceId?: string | null
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contentSummaries?: ContentSummaryUncheckedCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticUncheckedCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutResourcesNestedInput
    space?: SpaceUpdateOneWithoutResourcesNestedInput
    classification?: ClassificationUpdateOneWithoutResourcesNestedInput
    contentSummaries?: ContentSummaryUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentSummaries?: ContentSummaryUncheckedUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUncheckedUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    spaceId?: string | null
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResourceVersionCreateInput = {
    id?: string
    versionNumber: number
    title: string
    content?: string | null
    tags?: ResourceVersionCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resource: ResourceCreateNestedOneWithoutVersionsInput
    creator?: UserCreateNestedOneWithoutResource_versionsInput
  }

  export type ResourceVersionUncheckedCreateInput = {
    id?: string
    versionNumber: number
    title: string
    content?: string | null
    tags?: ResourceVersionCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    resourceId: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type ResourceVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceVersionUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resource?: ResourceUpdateOneRequiredWithoutVersionsNestedInput
    creator?: UserUpdateOneWithoutResource_versionsNestedInput
  }

  export type ResourceVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceVersionUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    resourceId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceVersionCreateManyInput = {
    id?: string
    versionNumber: number
    title: string
    content?: string | null
    tags?: ResourceVersionCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    resourceId: string
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type ResourceVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceVersionUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceVersionUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    resourceId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassificationCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    domain: $Enums.ContentDomain
    usageCount?: number
    isSystemDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    parent?: ClassificationCreateNestedOneWithoutChildrenInput
    children?: ClassificationCreateNestedManyWithoutParentInput
    resources?: ResourceCreateNestedManyWithoutClassificationInput
  }

  export type ClassificationUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    domain: $Enums.ContentDomain
    usageCount?: number
    isSystemDefault?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: ClassificationUncheckedCreateNestedManyWithoutParentInput
    resources?: ResourceUncheckedCreateNestedManyWithoutClassificationInput
  }

  export type ClassificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ClassificationUpdateOneWithoutChildrenNestedInput
    children?: ClassificationUpdateManyWithoutParentNestedInput
    resources?: ResourceUpdateManyWithoutClassificationNestedInput
  }

  export type ClassificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ClassificationUncheckedUpdateManyWithoutParentNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutClassificationNestedInput
  }

  export type ClassificationCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    domain: $Enums.ContentDomain
    usageCount?: number
    isSystemDefault?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ClassificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentSummaryCreateInput = {
    id?: string
    executiveSummary: string
    keyInsights?: string | null
    immediateActions?: string | null
    criticalWarnings?: string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryCreatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryCreateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryCreatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryCreatequestionBasedTagsInput | string[]
    totalChunks?: number
    embeddingModel?: string
    avgChunkTokens?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resource: ResourceCreateNestedOneWithoutContentSummariesInput
    vectorChunks?: VectorChunkCreateNestedManyWithoutSummaryInput
  }

  export type ContentSummaryUncheckedCreateInput = {
    id?: string
    executiveSummary: string
    keyInsights?: string | null
    immediateActions?: string | null
    criticalWarnings?: string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryCreatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryCreateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryCreatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryCreatequestionBasedTagsInput | string[]
    totalChunks?: number
    embeddingModel?: string
    avgChunkTokens?: number | null
    resourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutSummaryInput
  }

  export type ContentSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    keyInsights?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryUpdatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryUpdateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryUpdatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryUpdatequestionBasedTagsInput | string[]
    totalChunks?: IntFieldUpdateOperationsInput | number
    embeddingModel?: StringFieldUpdateOperationsInput | string
    avgChunkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resource?: ResourceUpdateOneRequiredWithoutContentSummariesNestedInput
    vectorChunks?: VectorChunkUpdateManyWithoutSummaryNestedInput
  }

  export type ContentSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    keyInsights?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryUpdatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryUpdateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryUpdatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryUpdatequestionBasedTagsInput | string[]
    totalChunks?: IntFieldUpdateOperationsInput | number
    embeddingModel?: StringFieldUpdateOperationsInput | string
    avgChunkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutSummaryNestedInput
  }

  export type ContentSummaryCreateManyInput = {
    id?: string
    executiveSummary: string
    keyInsights?: string | null
    immediateActions?: string | null
    criticalWarnings?: string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryCreatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryCreateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryCreatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryCreatequestionBasedTagsInput | string[]
    totalChunks?: number
    embeddingModel?: string
    avgChunkTokens?: number | null
    resourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContentSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    keyInsights?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryUpdatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryUpdateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryUpdatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryUpdatequestionBasedTagsInput | string[]
    totalChunks?: IntFieldUpdateOperationsInput | number
    embeddingModel?: StringFieldUpdateOperationsInput | string
    avgChunkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    keyInsights?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryUpdatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryUpdateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryUpdatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryUpdatequestionBasedTagsInput | string[]
    totalChunks?: IntFieldUpdateOperationsInput | number
    embeddingModel?: StringFieldUpdateOperationsInput | string
    avgChunkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VectorChunkCreateInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resource: ResourceCreateNestedOneWithoutVectorChunksInput
    summary: ContentSummaryCreateNestedOneWithoutVectorChunksInput
    parentChunk?: VectorChunkCreateNestedOneWithoutChildChunksInput
    childChunks?: VectorChunkCreateNestedManyWithoutParentChunkInput
  }

  export type VectorChunkUncheckedCreateInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    resourceId: string
    summaryId: string
    parentChunkId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    childChunks?: VectorChunkUncheckedCreateNestedManyWithoutParentChunkInput
  }

  export type VectorChunkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resource?: ResourceUpdateOneRequiredWithoutVectorChunksNestedInput
    summary?: ContentSummaryUpdateOneRequiredWithoutVectorChunksNestedInput
    parentChunk?: VectorChunkUpdateOneWithoutChildChunksNestedInput
    childChunks?: VectorChunkUpdateManyWithoutParentChunkNestedInput
  }

  export type VectorChunkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resourceId?: StringFieldUpdateOperationsInput | string
    summaryId?: StringFieldUpdateOperationsInput | string
    parentChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childChunks?: VectorChunkUncheckedUpdateManyWithoutParentChunkNestedInput
  }

  export type VectorChunkCreateManyInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    resourceId: string
    summaryId: string
    parentChunkId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VectorChunkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VectorChunkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resourceId?: StringFieldUpdateOperationsInput | string
    summaryId?: StringFieldUpdateOperationsInput | string
    parentChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentRelationshipCreateInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sourceResource: ResourceCreateNestedOneWithoutSourceOfRelationshipsInput
    targetResource: ResourceCreateNestedOneWithoutTargetOfRelationshipsInput
    creator?: UserCreateNestedOneWithoutContent_relationshipsInput
  }

  export type ContentRelationshipUncheckedCreateInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    sourceResourceId: string
    targetResourceId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContentRelationshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceResource?: ResourceUpdateOneRequiredWithoutSourceOfRelationshipsNestedInput
    targetResource?: ResourceUpdateOneRequiredWithoutTargetOfRelationshipsNestedInput
    creator?: UserUpdateOneWithoutContent_relationshipsNestedInput
  }

  export type ContentRelationshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceResourceId?: StringFieldUpdateOperationsInput | string
    targetResourceId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentRelationshipCreateManyInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    sourceResourceId: string
    targetResourceId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContentRelationshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentRelationshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceResourceId?: StringFieldUpdateOperationsInput | string
    targetResourceId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeNodeCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    domain?: $Enums.ContentDomain | null
    importanceScore?: number
    mentionFrequency?: number
    mentionedInResources?: KnowledgeNodeCreatementionedInResourcesInput | string[]
    firstMentionedDate?: Date | string
    lastMentionedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sourceKnowledgeEdges?: KnowledgeEdgeCreateNestedManyWithoutSourceNodeInput
    targetKnowledgeEdges?: KnowledgeEdgeCreateNestedManyWithoutTargetNodeInput
  }

  export type KnowledgeNodeUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    domain?: $Enums.ContentDomain | null
    importanceScore?: number
    mentionFrequency?: number
    mentionedInResources?: KnowledgeNodeCreatementionedInResourcesInput | string[]
    firstMentionedDate?: Date | string
    lastMentionedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sourceKnowledgeEdges?: KnowledgeEdgeUncheckedCreateNestedManyWithoutSourceNodeInput
    targetKnowledgeEdges?: KnowledgeEdgeUncheckedCreateNestedManyWithoutTargetNodeInput
  }

  export type KnowledgeNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    importanceScore?: IntFieldUpdateOperationsInput | number
    mentionFrequency?: IntFieldUpdateOperationsInput | number
    mentionedInResources?: KnowledgeNodeUpdatementionedInResourcesInput | string[]
    firstMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceKnowledgeEdges?: KnowledgeEdgeUpdateManyWithoutSourceNodeNestedInput
    targetKnowledgeEdges?: KnowledgeEdgeUpdateManyWithoutTargetNodeNestedInput
  }

  export type KnowledgeNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    importanceScore?: IntFieldUpdateOperationsInput | number
    mentionFrequency?: IntFieldUpdateOperationsInput | number
    mentionedInResources?: KnowledgeNodeUpdatementionedInResourcesInput | string[]
    firstMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceKnowledgeEdges?: KnowledgeEdgeUncheckedUpdateManyWithoutSourceNodeNestedInput
    targetKnowledgeEdges?: KnowledgeEdgeUncheckedUpdateManyWithoutTargetNodeNestedInput
  }

  export type KnowledgeNodeCreateManyInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    domain?: $Enums.ContentDomain | null
    importanceScore?: number
    mentionFrequency?: number
    mentionedInResources?: KnowledgeNodeCreatementionedInResourcesInput | string[]
    firstMentionedDate?: Date | string
    lastMentionedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KnowledgeNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    importanceScore?: IntFieldUpdateOperationsInput | number
    mentionFrequency?: IntFieldUpdateOperationsInput | number
    mentionedInResources?: KnowledgeNodeUpdatementionedInResourcesInput | string[]
    firstMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    importanceScore?: IntFieldUpdateOperationsInput | number
    mentionFrequency?: IntFieldUpdateOperationsInput | number
    mentionedInResources?: KnowledgeNodeUpdatementionedInResourcesInput | string[]
    firstMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeEdgeCreateInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sourceNode: KnowledgeNodeCreateNestedOneWithoutSourceKnowledgeEdgesInput
    targetNode: KnowledgeNodeCreateNestedOneWithoutTargetKnowledgeEdgesInput
    creator?: UserCreateNestedOneWithoutKnowledge_edges_createdInput
  }

  export type KnowledgeEdgeUncheckedCreateInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    sourceNodeId: string
    targetNodeId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KnowledgeEdgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNode?: KnowledgeNodeUpdateOneRequiredWithoutSourceKnowledgeEdgesNestedInput
    targetNode?: KnowledgeNodeUpdateOneRequiredWithoutTargetKnowledgeEdgesNestedInput
    creator?: UserUpdateOneWithoutKnowledge_edges_createdNestedInput
  }

  export type KnowledgeEdgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeEdgeCreateManyInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    sourceNodeId: string
    targetNodeId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KnowledgeEdgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeEdgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchQueryCreateInput = {
    id?: string
    query: string
    queryType?: string
    resultsCount?: number
    avgRelevanceScore?: Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryCreateclickedResultsInput | string[]
    extractedIntent?: string | null
    domainClassification?: $Enums.ContentDomain | null
    complexityDetected?: $Enums.ComplexityLevel | null
    responseTimeMs?: number | null
    userSatisfaction?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSearch_queriesInput
  }

  export type SearchQueryUncheckedCreateInput = {
    id?: string
    query: string
    queryType?: string
    resultsCount?: number
    avgRelevanceScore?: Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryCreateclickedResultsInput | string[]
    extractedIntent?: string | null
    domainClassification?: $Enums.ContentDomain | null
    complexityDetected?: $Enums.ComplexityLevel | null
    responseTimeMs?: number | null
    userSatisfaction?: number | null
    userId: string
    createdAt?: Date | string
  }

  export type SearchQueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    queryType?: StringFieldUpdateOperationsInput | string
    resultsCount?: IntFieldUpdateOperationsInput | number
    avgRelevanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryUpdateclickedResultsInput | string[]
    extractedIntent?: NullableStringFieldUpdateOperationsInput | string | null
    domainClassification?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    complexityDetected?: NullableEnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSearch_queriesNestedInput
  }

  export type SearchQueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    queryType?: StringFieldUpdateOperationsInput | string
    resultsCount?: IntFieldUpdateOperationsInput | number
    avgRelevanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryUpdateclickedResultsInput | string[]
    extractedIntent?: NullableStringFieldUpdateOperationsInput | string | null
    domainClassification?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    complexityDetected?: NullableEnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryCreateManyInput = {
    id?: string
    query: string
    queryType?: string
    resultsCount?: number
    avgRelevanceScore?: Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryCreateclickedResultsInput | string[]
    extractedIntent?: string | null
    domainClassification?: $Enums.ContentDomain | null
    complexityDetected?: $Enums.ComplexityLevel | null
    responseTimeMs?: number | null
    userSatisfaction?: number | null
    userId: string
    createdAt?: Date | string
  }

  export type SearchQueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    queryType?: StringFieldUpdateOperationsInput | string
    resultsCount?: IntFieldUpdateOperationsInput | number
    avgRelevanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryUpdateclickedResultsInput | string[]
    extractedIntent?: NullableStringFieldUpdateOperationsInput | string | null
    domainClassification?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    complexityDetected?: NullableEnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    queryType?: StringFieldUpdateOperationsInput | string
    resultsCount?: IntFieldUpdateOperationsInput | number
    avgRelevanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryUpdateclickedResultsInput | string[]
    extractedIntent?: NullableStringFieldUpdateOperationsInput | string | null
    domainClassification?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    complexityDetected?: NullableEnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningAnalyticCreateInput = {
    id?: string
    eventType: string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: string | null
    comprehensionLevel?: number | null
    implementationStatus?: $Enums.ImplementationStatus | null
    deviceType?: string | null
    timeSpentSeconds?: number | null
    referralSource?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLearning_analyticsInput
    resource?: ResourceCreateNestedOneWithoutLearningAnalyticsInput
  }

  export type LearningAnalyticUncheckedCreateInput = {
    id?: string
    eventType: string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: string | null
    comprehensionLevel?: number | null
    implementationStatus?: $Enums.ImplementationStatus | null
    deviceType?: string | null
    timeSpentSeconds?: number | null
    referralSource?: string | null
    userId: string
    resourceId?: string | null
    createdAt?: Date | string
  }

  export type LearningAnalyticUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    comprehensionLevel?: NullableIntFieldUpdateOperationsInput | number | null
    implementationStatus?: NullableEnumImplementationStatusFieldUpdateOperationsInput | $Enums.ImplementationStatus | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLearning_analyticsNestedInput
    resource?: ResourceUpdateOneWithoutLearningAnalyticsNestedInput
  }

  export type LearningAnalyticUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    comprehensionLevel?: NullableIntFieldUpdateOperationsInput | number | null
    implementationStatus?: NullableEnumImplementationStatusFieldUpdateOperationsInput | $Enums.ImplementationStatus | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningAnalyticCreateManyInput = {
    id?: string
    eventType: string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: string | null
    comprehensionLevel?: number | null
    implementationStatus?: $Enums.ImplementationStatus | null
    deviceType?: string | null
    timeSpentSeconds?: number | null
    referralSource?: string | null
    userId: string
    resourceId?: string | null
    createdAt?: Date | string
  }

  export type LearningAnalyticUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    comprehensionLevel?: NullableIntFieldUpdateOperationsInput | number | null
    implementationStatus?: NullableEnumImplementationStatusFieldUpdateOperationsInput | $Enums.ImplementationStatus | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningAnalyticUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    comprehensionLevel?: NullableIntFieldUpdateOperationsInput | number | null
    implementationStatus?: NullableEnumImplementationStatusFieldUpdateOperationsInput | $Enums.ImplementationStatus | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchJobCreateInput = {
    id?: string
    status: $Enums.BatchJobStatus
    progress?: number
    totalItems: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBatch_jobsInput
  }

  export type BatchJobUncheckedCreateInput = {
    id?: string
    status: $Enums.BatchJobStatus
    progress?: number
    totalItems: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchJobStatusFieldUpdateOperationsInput | $Enums.BatchJobStatus
    progress?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBatch_jobsNestedInput
  }

  export type BatchJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchJobStatusFieldUpdateOperationsInput | $Enums.BatchJobStatus
    progress?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchJobCreateManyInput = {
    id?: string
    status: $Enums.BatchJobStatus
    progress?: number
    totalItems: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchJobStatusFieldUpdateOperationsInput | $Enums.BatchJobStatus
    progress?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchJobStatusFieldUpdateOperationsInput | $Enums.BatchJobStatus
    progress?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptLogCreateInput = {
    id?: string
    queryText: string
    tier: $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    latencyMs?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutPrompt_logsInput
  }

  export type PromptLogUncheckedCreateInput = {
    id?: string
    queryText: string
    tier: $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    latencyMs?: number | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type PromptLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    tier?: EnumPromptLogTierFieldUpdateOperationsInput | $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPrompt_logsNestedInput
  }

  export type PromptLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    tier?: EnumPromptLogTierFieldUpdateOperationsInput | $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptLogCreateManyInput = {
    id?: string
    queryText: string
    tier: $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    latencyMs?: number | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type PromptLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    tier?: EnumPromptLogTierFieldUpdateOperationsInput | $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    tier?: EnumPromptLogTierFieldUpdateOperationsInput | $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeLogCreateInput = {
    id?: string
    changeType: string
    changeDetails?: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    user?: UserCreateNestedOneWithoutChange_logsInput
  }

  export type ChangeLogUncheckedCreateInput = {
    id?: string
    changeType: string
    changeDetails?: JsonNullValueInput | InputJsonValue
    userId?: string | null
    changedAt?: Date | string
  }

  export type ChangeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDetails?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutChange_logsNestedInput
  }

  export type ChangeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDetails?: JsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeLogCreateManyInput = {
    id?: string
    changeType: string
    changeDetails?: JsonNullValueInput | InputJsonValue
    userId?: string | null
    changedAt?: Date | string
  }

  export type ChangeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDetails?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDetails?: JsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type SpaceListRelationFilter = {
    every?: SpaceWhereInput
    some?: SpaceWhereInput
    none?: SpaceWhereInput
  }

  export type ResourceListRelationFilter = {
    every?: ResourceWhereInput
    some?: ResourceWhereInput
    none?: ResourceWhereInput
  }

  export type SearchQueryListRelationFilter = {
    every?: SearchQueryWhereInput
    some?: SearchQueryWhereInput
    none?: SearchQueryWhereInput
  }

  export type LearningAnalyticListRelationFilter = {
    every?: LearningAnalyticWhereInput
    some?: LearningAnalyticWhereInput
    none?: LearningAnalyticWhereInput
  }

  export type ContentRelationshipListRelationFilter = {
    every?: ContentRelationshipWhereInput
    some?: ContentRelationshipWhereInput
    none?: ContentRelationshipWhereInput
  }

  export type KnowledgeEdgeListRelationFilter = {
    every?: KnowledgeEdgeWhereInput
    some?: KnowledgeEdgeWhereInput
    none?: KnowledgeEdgeWhereInput
  }

  export type BatchJobListRelationFilter = {
    every?: BatchJobWhereInput
    some?: BatchJobWhereInput
    none?: BatchJobWhereInput
  }

  export type PromptLogListRelationFilter = {
    every?: PromptLogWhereInput
    some?: PromptLogWhereInput
    none?: PromptLogWhereInput
  }

  export type ChangeLogListRelationFilter = {
    every?: ChangeLogWhereInput
    some?: ChangeLogWhereInput
    none?: ChangeLogWhereInput
  }

  export type ResourceVersionListRelationFilter = {
    every?: ResourceVersionWhereInput
    some?: ResourceVersionWhereInput
    none?: ResourceVersionWhereInput
  }

  export type SpaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchQueryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningAnalyticOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentRelationshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeEdgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromptLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    preferences?: SortOrder
    totalProcessedContent?: SortOrder
    totalEmbeddings?: SortOrder
    monthlyQuotaUsed?: SortOrder
    lastActiveDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    totalProcessedContent?: SortOrder
    totalEmbeddings?: SortOrder
    monthlyQuotaUsed?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    totalProcessedContent?: SortOrder
    totalEmbeddings?: SortOrder
    monthlyQuotaUsed?: SortOrder
    lastActiveDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    totalProcessedContent?: SortOrder
    totalEmbeddings?: SortOrder
    monthlyQuotaUsed?: SortOrder
    lastActiveDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    totalProcessedContent?: SortOrder
    totalEmbeddings?: SortOrder
    monthlyQuotaUsed?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumContentDomainFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentDomain | EnumContentDomainFieldRefInput<$PrismaModel>
    in?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel>
    not?: NestedEnumContentDomainFilter<$PrismaModel> | $Enums.ContentDomain
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SpaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    domain?: SortOrder
    isDefault?: SortOrder
    contentCount?: SortOrder
    lastAccessed?: SortOrder
    pineconeNamespace?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SpaceAvgOrderByAggregateInput = {
    contentCount?: SortOrder
  }

  export type SpaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    domain?: SortOrder
    isDefault?: SortOrder
    contentCount?: SortOrder
    lastAccessed?: SortOrder
    pineconeNamespace?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SpaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    domain?: SortOrder
    isDefault?: SortOrder
    contentCount?: SortOrder
    lastAccessed?: SortOrder
    pineconeNamespace?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SpaceSumOrderByAggregateInput = {
    contentCount?: SortOrder
  }

  export type EnumContentDomainWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentDomain | EnumContentDomainFieldRefInput<$PrismaModel>
    in?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel>
    not?: NestedEnumContentDomainWithAggregatesFilter<$PrismaModel> | $Enums.ContentDomain
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentDomainFilter<$PrismaModel>
    _max?: NestedEnumContentDomainFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumComplexityLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplexityLevel | EnumComplexityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumComplexityLevelFilter<$PrismaModel> | $Enums.ComplexityLevel
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type EnumActionDensityFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionDensity | EnumActionDensityFieldRefInput<$PrismaModel>
    in?: $Enums.ActionDensity[] | ListEnumActionDensityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionDensity[] | ListEnumActionDensityFieldRefInput<$PrismaModel>
    not?: NestedEnumActionDensityFilter<$PrismaModel> | $Enums.ActionDensity
  }

  export type EnumPracticalApplicabilityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PracticalApplicability | EnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.PracticalApplicability[] | ListEnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PracticalApplicability[] | ListEnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPracticalApplicabilityNullableFilter<$PrismaModel> | $Enums.PracticalApplicability | null
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type SpaceNullableScalarRelationFilter = {
    is?: SpaceWhereInput | null
    isNot?: SpaceWhereInput | null
  }

  export type ClassificationNullableScalarRelationFilter = {
    is?: ClassificationWhereInput | null
    isNot?: ClassificationWhereInput | null
  }

  export type ContentSummaryListRelationFilter = {
    every?: ContentSummaryWhereInput
    some?: ContentSummaryWhereInput
    none?: ContentSummaryWhereInput
  }

  export type VectorChunkListRelationFilter = {
    every?: VectorChunkWhereInput
    some?: VectorChunkWhereInput
    none?: VectorChunkWhereInput
  }

  export type ContentSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VectorChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    domain?: SortOrder
    language?: SortOrder
    metadata?: SortOrder
    complexityLevel?: SortOrder
    estimatedReadTimeMinutes?: SortOrder
    wordCount?: SortOrder
    processingStatus?: SortOrder
    processedAt?: SortOrder
    actionDensity?: SortOrder
    noveltyScore?: SortOrder
    practicalApplicability?: SortOrder
    userId?: SortOrder
    spaceId?: SortOrder
    classificationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    estimatedReadTimeMinutes?: SortOrder
    wordCount?: SortOrder
    noveltyScore?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    content?: SortOrder
    domain?: SortOrder
    language?: SortOrder
    complexityLevel?: SortOrder
    estimatedReadTimeMinutes?: SortOrder
    wordCount?: SortOrder
    processingStatus?: SortOrder
    processedAt?: SortOrder
    actionDensity?: SortOrder
    noveltyScore?: SortOrder
    practicalApplicability?: SortOrder
    userId?: SortOrder
    spaceId?: SortOrder
    classificationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    content?: SortOrder
    domain?: SortOrder
    language?: SortOrder
    complexityLevel?: SortOrder
    estimatedReadTimeMinutes?: SortOrder
    wordCount?: SortOrder
    processingStatus?: SortOrder
    processedAt?: SortOrder
    actionDensity?: SortOrder
    noveltyScore?: SortOrder
    practicalApplicability?: SortOrder
    userId?: SortOrder
    spaceId?: SortOrder
    classificationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    estimatedReadTimeMinutes?: SortOrder
    wordCount?: SortOrder
    noveltyScore?: SortOrder
  }

  export type EnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type EnumComplexityLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplexityLevel | EnumComplexityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumComplexityLevelWithAggregatesFilter<$PrismaModel> | $Enums.ComplexityLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplexityLevelFilter<$PrismaModel>
    _max?: NestedEnumComplexityLevelFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }

  export type EnumActionDensityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionDensity | EnumActionDensityFieldRefInput<$PrismaModel>
    in?: $Enums.ActionDensity[] | ListEnumActionDensityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionDensity[] | ListEnumActionDensityFieldRefInput<$PrismaModel>
    not?: NestedEnumActionDensityWithAggregatesFilter<$PrismaModel> | $Enums.ActionDensity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionDensityFilter<$PrismaModel>
    _max?: NestedEnumActionDensityFilter<$PrismaModel>
  }

  export type EnumPracticalApplicabilityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PracticalApplicability | EnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.PracticalApplicability[] | ListEnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PracticalApplicability[] | ListEnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPracticalApplicabilityNullableWithAggregatesFilter<$PrismaModel> | $Enums.PracticalApplicability | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPracticalApplicabilityNullableFilter<$PrismaModel>
    _max?: NestedEnumPracticalApplicabilityNullableFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ResourceScalarRelationFilter = {
    is?: ResourceWhereInput
    isNot?: ResourceWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ResourceVersionResourceIdVersionNumberCompoundUniqueInput = {
    resourceId: string
    versionNumber: number
  }

  export type ResourceVersionCountOrderByAggregateInput = {
    id?: SortOrder
    versionNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    resourceId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type ResourceVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    versionNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    resourceId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceVersionMinOrderByAggregateInput = {
    id?: SortOrder
    versionNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    resourceId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type ClassificationListRelationFilter = {
    every?: ClassificationWhereInput
    some?: ClassificationWhereInput
    none?: ClassificationWhereInput
  }

  export type ClassificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassificationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    usageCount?: SortOrder
    isSystemDefault?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ClassificationAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ClassificationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    usageCount?: SortOrder
    isSystemDefault?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ClassificationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    usageCount?: SortOrder
    isSystemDefault?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ClassificationSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ContentSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    executiveSummary?: SortOrder
    keyInsights?: SortOrder
    immediateActions?: SortOrder
    criticalWarnings?: SortOrder
    keyMetrics?: SortOrder
    toolsResources?: SortOrder
    peopleCompanies?: SortOrder
    primaryKeywords?: SortOrder
    semanticTags?: SortOrder
    questionBasedTags?: SortOrder
    totalChunks?: SortOrder
    embeddingModel?: SortOrder
    avgChunkTokens?: SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContentSummaryAvgOrderByAggregateInput = {
    totalChunks?: SortOrder
    avgChunkTokens?: SortOrder
  }

  export type ContentSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    executiveSummary?: SortOrder
    keyInsights?: SortOrder
    immediateActions?: SortOrder
    criticalWarnings?: SortOrder
    totalChunks?: SortOrder
    embeddingModel?: SortOrder
    avgChunkTokens?: SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContentSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    executiveSummary?: SortOrder
    keyInsights?: SortOrder
    immediateActions?: SortOrder
    criticalWarnings?: SortOrder
    totalChunks?: SortOrder
    embeddingModel?: SortOrder
    avgChunkTokens?: SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContentSummarySumOrderByAggregateInput = {
    totalChunks?: SortOrder
    avgChunkTokens?: SortOrder
  }

  export type EnumChunkTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChunkType | EnumChunkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChunkType[] | ListEnumChunkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChunkType[] | ListEnumChunkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChunkTypeFilter<$PrismaModel> | $Enums.ChunkType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ContentSummaryScalarRelationFilter = {
    is?: ContentSummaryWhereInput
    isNot?: ContentSummaryWhereInput
  }

  export type VectorChunkNullableScalarRelationFilter = {
    is?: VectorChunkWhereInput | null
    isNot?: VectorChunkWhereInput | null
  }

  export type VectorChunkCountOrderByAggregateInput = {
    id?: SortOrder
    chunkIndex?: SortOrder
    chunkType?: SortOrder
    content?: SortOrder
    tokenCount?: SortOrder
    pineconeId?: SortOrder
    pineconeNamespace?: SortOrder
    embeddingModel?: SortOrder
    vectorDimension?: SortOrder
    overlappingChunks?: SortOrder
    semanticDensity?: SortOrder
    retrievalFrequency?: SortOrder
    lastRetrieved?: SortOrder
    resourceId?: SortOrder
    summaryId?: SortOrder
    parentChunkId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VectorChunkAvgOrderByAggregateInput = {
    chunkIndex?: SortOrder
    tokenCount?: SortOrder
    vectorDimension?: SortOrder
    semanticDensity?: SortOrder
    retrievalFrequency?: SortOrder
  }

  export type VectorChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    chunkIndex?: SortOrder
    chunkType?: SortOrder
    content?: SortOrder
    tokenCount?: SortOrder
    pineconeId?: SortOrder
    pineconeNamespace?: SortOrder
    embeddingModel?: SortOrder
    vectorDimension?: SortOrder
    semanticDensity?: SortOrder
    retrievalFrequency?: SortOrder
    lastRetrieved?: SortOrder
    resourceId?: SortOrder
    summaryId?: SortOrder
    parentChunkId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VectorChunkMinOrderByAggregateInput = {
    id?: SortOrder
    chunkIndex?: SortOrder
    chunkType?: SortOrder
    content?: SortOrder
    tokenCount?: SortOrder
    pineconeId?: SortOrder
    pineconeNamespace?: SortOrder
    embeddingModel?: SortOrder
    vectorDimension?: SortOrder
    semanticDensity?: SortOrder
    retrievalFrequency?: SortOrder
    lastRetrieved?: SortOrder
    resourceId?: SortOrder
    summaryId?: SortOrder
    parentChunkId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type VectorChunkSumOrderByAggregateInput = {
    chunkIndex?: SortOrder
    tokenCount?: SortOrder
    vectorDimension?: SortOrder
    semanticDensity?: SortOrder
    retrievalFrequency?: SortOrder
  }

  export type EnumChunkTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChunkType | EnumChunkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChunkType[] | ListEnumChunkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChunkType[] | ListEnumChunkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChunkTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChunkType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChunkTypeFilter<$PrismaModel>
    _max?: NestedEnumChunkTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumRelationshipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipType | EnumRelationshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipTypeFilter<$PrismaModel> | $Enums.RelationshipType
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ContentRelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    relationshipType?: SortOrder
    confidenceScore?: SortOrder
    relationshipReason?: SortOrder
    isAutoGenerated?: SortOrder
    sourceResourceId?: SortOrder
    targetResourceId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContentRelationshipAvgOrderByAggregateInput = {
    confidenceScore?: SortOrder
  }

  export type ContentRelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    relationshipType?: SortOrder
    confidenceScore?: SortOrder
    relationshipReason?: SortOrder
    isAutoGenerated?: SortOrder
    sourceResourceId?: SortOrder
    targetResourceId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContentRelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    relationshipType?: SortOrder
    confidenceScore?: SortOrder
    relationshipReason?: SortOrder
    isAutoGenerated?: SortOrder
    sourceResourceId?: SortOrder
    targetResourceId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContentRelationshipSumOrderByAggregateInput = {
    confidenceScore?: SortOrder
  }

  export type EnumRelationshipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipType | EnumRelationshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationshipTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationshipTypeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumContentDomainNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentDomain | EnumContentDomainFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentDomainNullableFilter<$PrismaModel> | $Enums.ContentDomain | null
  }

  export type KnowledgeNodeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    importanceScore?: SortOrder
    mentionFrequency?: SortOrder
    mentionedInResources?: SortOrder
    firstMentionedDate?: SortOrder
    lastMentionedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KnowledgeNodeAvgOrderByAggregateInput = {
    importanceScore?: SortOrder
    mentionFrequency?: SortOrder
  }

  export type KnowledgeNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    importanceScore?: SortOrder
    mentionFrequency?: SortOrder
    firstMentionedDate?: SortOrder
    lastMentionedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KnowledgeNodeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    importanceScore?: SortOrder
    mentionFrequency?: SortOrder
    firstMentionedDate?: SortOrder
    lastMentionedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KnowledgeNodeSumOrderByAggregateInput = {
    importanceScore?: SortOrder
    mentionFrequency?: SortOrder
  }

  export type EnumContentDomainNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentDomain | EnumContentDomainFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentDomainNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContentDomain | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContentDomainNullableFilter<$PrismaModel>
    _max?: NestedEnumContentDomainNullableFilter<$PrismaModel>
  }

  export type KnowledgeNodeScalarRelationFilter = {
    is?: KnowledgeNodeWhereInput
    isNot?: KnowledgeNodeWhereInput
  }

  export type KnowledgeEdgeCountOrderByAggregateInput = {
    id?: SortOrder
    relationshipType?: SortOrder
    strength?: SortOrder
    evidenceResources?: SortOrder
    isAutoGenerated?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KnowledgeEdgeAvgOrderByAggregateInput = {
    strength?: SortOrder
  }

  export type KnowledgeEdgeMaxOrderByAggregateInput = {
    id?: SortOrder
    relationshipType?: SortOrder
    strength?: SortOrder
    isAutoGenerated?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KnowledgeEdgeMinOrderByAggregateInput = {
    id?: SortOrder
    relationshipType?: SortOrder
    strength?: SortOrder
    isAutoGenerated?: SortOrder
    sourceNodeId?: SortOrder
    targetNodeId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KnowledgeEdgeSumOrderByAggregateInput = {
    strength?: SortOrder
  }

  export type EnumComplexityLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplexityLevel | EnumComplexityLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumComplexityLevelNullableFilter<$PrismaModel> | $Enums.ComplexityLevel | null
  }

  export type SearchQueryCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    queryType?: SortOrder
    resultsCount?: SortOrder
    avgRelevanceScore?: SortOrder
    clickedResults?: SortOrder
    extractedIntent?: SortOrder
    domainClassification?: SortOrder
    complexityDetected?: SortOrder
    responseTimeMs?: SortOrder
    userSatisfaction?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchQueryAvgOrderByAggregateInput = {
    resultsCount?: SortOrder
    avgRelevanceScore?: SortOrder
    responseTimeMs?: SortOrder
    userSatisfaction?: SortOrder
  }

  export type SearchQueryMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    queryType?: SortOrder
    resultsCount?: SortOrder
    avgRelevanceScore?: SortOrder
    extractedIntent?: SortOrder
    domainClassification?: SortOrder
    complexityDetected?: SortOrder
    responseTimeMs?: SortOrder
    userSatisfaction?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchQueryMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    queryType?: SortOrder
    resultsCount?: SortOrder
    avgRelevanceScore?: SortOrder
    extractedIntent?: SortOrder
    domainClassification?: SortOrder
    complexityDetected?: SortOrder
    responseTimeMs?: SortOrder
    userSatisfaction?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SearchQuerySumOrderByAggregateInput = {
    resultsCount?: SortOrder
    avgRelevanceScore?: SortOrder
    responseTimeMs?: SortOrder
    userSatisfaction?: SortOrder
  }

  export type EnumComplexityLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplexityLevel | EnumComplexityLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumComplexityLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.ComplexityLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumComplexityLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumComplexityLevelNullableFilter<$PrismaModel>
  }

  export type EnumImplementationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ImplementationStatus | EnumImplementationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ImplementationStatus[] | ListEnumImplementationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ImplementationStatus[] | ListEnumImplementationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumImplementationStatusNullableFilter<$PrismaModel> | $Enums.ImplementationStatus | null
  }

  export type ResourceNullableScalarRelationFilter = {
    is?: ResourceWhereInput | null
    isNot?: ResourceWhereInput | null
  }

  export type LearningAnalyticCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    eventDetails?: SortOrder
    sessionId?: SortOrder
    comprehensionLevel?: SortOrder
    implementationStatus?: SortOrder
    deviceType?: SortOrder
    timeSpentSeconds?: SortOrder
    referralSource?: SortOrder
    userId?: SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
  }

  export type LearningAnalyticAvgOrderByAggregateInput = {
    comprehensionLevel?: SortOrder
    timeSpentSeconds?: SortOrder
  }

  export type LearningAnalyticMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    sessionId?: SortOrder
    comprehensionLevel?: SortOrder
    implementationStatus?: SortOrder
    deviceType?: SortOrder
    timeSpentSeconds?: SortOrder
    referralSource?: SortOrder
    userId?: SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
  }

  export type LearningAnalyticMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    sessionId?: SortOrder
    comprehensionLevel?: SortOrder
    implementationStatus?: SortOrder
    deviceType?: SortOrder
    timeSpentSeconds?: SortOrder
    referralSource?: SortOrder
    userId?: SortOrder
    resourceId?: SortOrder
    createdAt?: SortOrder
  }

  export type LearningAnalyticSumOrderByAggregateInput = {
    comprehensionLevel?: SortOrder
    timeSpentSeconds?: SortOrder
  }

  export type EnumImplementationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImplementationStatus | EnumImplementationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ImplementationStatus[] | ListEnumImplementationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ImplementationStatus[] | ListEnumImplementationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumImplementationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ImplementationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumImplementationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumImplementationStatusNullableFilter<$PrismaModel>
  }

  export type EnumBatchJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchJobStatus | EnumBatchJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchJobStatus[] | ListEnumBatchJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchJobStatus[] | ListEnumBatchJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchJobStatusFilter<$PrismaModel> | $Enums.BatchJobStatus
  }

  export type BatchJobCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    totalItems?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchJobAvgOrderByAggregateInput = {
    progress?: SortOrder
    totalItems?: SortOrder
  }

  export type BatchJobMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    totalItems?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchJobMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    totalItems?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchJobSumOrderByAggregateInput = {
    progress?: SortOrder
    totalItems?: SortOrder
  }

  export type EnumBatchJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchJobStatus | EnumBatchJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchJobStatus[] | ListEnumBatchJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchJobStatus[] | ListEnumBatchJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchJobStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchJobStatusFilter<$PrismaModel>
  }

  export type EnumPromptLogTierFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptLogTier | EnumPromptLogTierFieldRefInput<$PrismaModel>
    in?: $Enums.PromptLogTier[] | ListEnumPromptLogTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptLogTier[] | ListEnumPromptLogTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptLogTierFilter<$PrismaModel> | $Enums.PromptLogTier
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PromptLogCountOrderByAggregateInput = {
    id?: SortOrder
    queryText?: SortOrder
    tier?: SortOrder
    response?: SortOrder
    error?: SortOrder
    latencyMs?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptLogAvgOrderByAggregateInput = {
    latencyMs?: SortOrder
  }

  export type PromptLogMaxOrderByAggregateInput = {
    id?: SortOrder
    queryText?: SortOrder
    tier?: SortOrder
    error?: SortOrder
    latencyMs?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptLogMinOrderByAggregateInput = {
    id?: SortOrder
    queryText?: SortOrder
    tier?: SortOrder
    error?: SortOrder
    latencyMs?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptLogSumOrderByAggregateInput = {
    latencyMs?: SortOrder
  }

  export type EnumPromptLogTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptLogTier | EnumPromptLogTierFieldRefInput<$PrismaModel>
    in?: $Enums.PromptLogTier[] | ListEnumPromptLogTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptLogTier[] | ListEnumPromptLogTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptLogTierWithAggregatesFilter<$PrismaModel> | $Enums.PromptLogTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromptLogTierFilter<$PrismaModel>
    _max?: NestedEnumPromptLogTierFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    changeType?: SortOrder
    changeDetails?: SortOrder
    userId?: SortOrder
    changedAt?: SortOrder
  }

  export type ChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    changeType?: SortOrder
    userId?: SortOrder
    changedAt?: SortOrder
  }

  export type ChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    changeType?: SortOrder
    userId?: SortOrder
    changedAt?: SortOrder
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type SpaceCreateNestedManyWithoutUserInput = {
    create?: XOR<SpaceCreateWithoutUserInput, SpaceUncheckedCreateWithoutUserInput> | SpaceCreateWithoutUserInput[] | SpaceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutUserInput | SpaceCreateOrConnectWithoutUserInput[]
    createMany?: SpaceCreateManyUserInputEnvelope
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutUserInput = {
    create?: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput> | ResourceCreateWithoutUserInput[] | ResourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUserInput | ResourceCreateOrConnectWithoutUserInput[]
    createMany?: ResourceCreateManyUserInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type SearchQueryCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
  }

  export type LearningAnalyticCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningAnalyticCreateWithoutUserInput, LearningAnalyticUncheckedCreateWithoutUserInput> | LearningAnalyticCreateWithoutUserInput[] | LearningAnalyticUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningAnalyticCreateOrConnectWithoutUserInput | LearningAnalyticCreateOrConnectWithoutUserInput[]
    createMany?: LearningAnalyticCreateManyUserInputEnvelope
    connect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
  }

  export type ContentRelationshipCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ContentRelationshipCreateWithoutCreatorInput, ContentRelationshipUncheckedCreateWithoutCreatorInput> | ContentRelationshipCreateWithoutCreatorInput[] | ContentRelationshipUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutCreatorInput | ContentRelationshipCreateOrConnectWithoutCreatorInput[]
    createMany?: ContentRelationshipCreateManyCreatorInputEnvelope
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
  }

  export type KnowledgeEdgeCreateNestedManyWithoutCreatorInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutCreatorInput, KnowledgeEdgeUncheckedCreateWithoutCreatorInput> | KnowledgeEdgeCreateWithoutCreatorInput[] | KnowledgeEdgeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutCreatorInput | KnowledgeEdgeCreateOrConnectWithoutCreatorInput[]
    createMany?: KnowledgeEdgeCreateManyCreatorInputEnvelope
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
  }

  export type BatchJobCreateNestedManyWithoutUserInput = {
    create?: XOR<BatchJobCreateWithoutUserInput, BatchJobUncheckedCreateWithoutUserInput> | BatchJobCreateWithoutUserInput[] | BatchJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BatchJobCreateOrConnectWithoutUserInput | BatchJobCreateOrConnectWithoutUserInput[]
    createMany?: BatchJobCreateManyUserInputEnvelope
    connect?: BatchJobWhereUniqueInput | BatchJobWhereUniqueInput[]
  }

  export type PromptLogCreateNestedManyWithoutUserInput = {
    create?: XOR<PromptLogCreateWithoutUserInput, PromptLogUncheckedCreateWithoutUserInput> | PromptLogCreateWithoutUserInput[] | PromptLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromptLogCreateOrConnectWithoutUserInput | PromptLogCreateOrConnectWithoutUserInput[]
    createMany?: PromptLogCreateManyUserInputEnvelope
    connect?: PromptLogWhereUniqueInput | PromptLogWhereUniqueInput[]
  }

  export type ChangeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput> | ChangeLogCreateWithoutUserInput[] | ChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutUserInput | ChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: ChangeLogCreateManyUserInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type ResourceVersionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ResourceVersionCreateWithoutCreatorInput, ResourceVersionUncheckedCreateWithoutCreatorInput> | ResourceVersionCreateWithoutCreatorInput[] | ResourceVersionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ResourceVersionCreateOrConnectWithoutCreatorInput | ResourceVersionCreateOrConnectWithoutCreatorInput[]
    createMany?: ResourceVersionCreateManyCreatorInputEnvelope
    connect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type SpaceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SpaceCreateWithoutUserInput, SpaceUncheckedCreateWithoutUserInput> | SpaceCreateWithoutUserInput[] | SpaceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutUserInput | SpaceCreateOrConnectWithoutUserInput[]
    createMany?: SpaceCreateManyUserInputEnvelope
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput> | ResourceCreateWithoutUserInput[] | ResourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUserInput | ResourceCreateOrConnectWithoutUserInput[]
    createMany?: ResourceCreateManyUserInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type SearchQueryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
  }

  export type LearningAnalyticUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LearningAnalyticCreateWithoutUserInput, LearningAnalyticUncheckedCreateWithoutUserInput> | LearningAnalyticCreateWithoutUserInput[] | LearningAnalyticUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningAnalyticCreateOrConnectWithoutUserInput | LearningAnalyticCreateOrConnectWithoutUserInput[]
    createMany?: LearningAnalyticCreateManyUserInputEnvelope
    connect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
  }

  export type ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ContentRelationshipCreateWithoutCreatorInput, ContentRelationshipUncheckedCreateWithoutCreatorInput> | ContentRelationshipCreateWithoutCreatorInput[] | ContentRelationshipUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutCreatorInput | ContentRelationshipCreateOrConnectWithoutCreatorInput[]
    createMany?: ContentRelationshipCreateManyCreatorInputEnvelope
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
  }

  export type KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutCreatorInput, KnowledgeEdgeUncheckedCreateWithoutCreatorInput> | KnowledgeEdgeCreateWithoutCreatorInput[] | KnowledgeEdgeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutCreatorInput | KnowledgeEdgeCreateOrConnectWithoutCreatorInput[]
    createMany?: KnowledgeEdgeCreateManyCreatorInputEnvelope
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
  }

  export type BatchJobUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BatchJobCreateWithoutUserInput, BatchJobUncheckedCreateWithoutUserInput> | BatchJobCreateWithoutUserInput[] | BatchJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BatchJobCreateOrConnectWithoutUserInput | BatchJobCreateOrConnectWithoutUserInput[]
    createMany?: BatchJobCreateManyUserInputEnvelope
    connect?: BatchJobWhereUniqueInput | BatchJobWhereUniqueInput[]
  }

  export type PromptLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PromptLogCreateWithoutUserInput, PromptLogUncheckedCreateWithoutUserInput> | PromptLogCreateWithoutUserInput[] | PromptLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromptLogCreateOrConnectWithoutUserInput | PromptLogCreateOrConnectWithoutUserInput[]
    createMany?: PromptLogCreateManyUserInputEnvelope
    connect?: PromptLogWhereUniqueInput | PromptLogWhereUniqueInput[]
  }

  export type ChangeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput> | ChangeLogCreateWithoutUserInput[] | ChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutUserInput | ChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: ChangeLogCreateManyUserInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ResourceVersionCreateWithoutCreatorInput, ResourceVersionUncheckedCreateWithoutCreatorInput> | ResourceVersionCreateWithoutCreatorInput[] | ResourceVersionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ResourceVersionCreateOrConnectWithoutCreatorInput | ResourceVersionCreateOrConnectWithoutCreatorInput[]
    createMany?: ResourceVersionCreateManyCreatorInputEnvelope
    connect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type SpaceUpdateManyWithoutUserNestedInput = {
    create?: XOR<SpaceCreateWithoutUserInput, SpaceUncheckedCreateWithoutUserInput> | SpaceCreateWithoutUserInput[] | SpaceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutUserInput | SpaceCreateOrConnectWithoutUserInput[]
    upsert?: SpaceUpsertWithWhereUniqueWithoutUserInput | SpaceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SpaceCreateManyUserInputEnvelope
    set?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    disconnect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    delete?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    update?: SpaceUpdateWithWhereUniqueWithoutUserInput | SpaceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SpaceUpdateManyWithWhereWithoutUserInput | SpaceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput> | ResourceCreateWithoutUserInput[] | ResourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUserInput | ResourceCreateOrConnectWithoutUserInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUserInput | ResourceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResourceCreateManyUserInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUserInput | ResourceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUserInput | ResourceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type SearchQueryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    upsert?: SearchQueryUpsertWithWhereUniqueWithoutUserInput | SearchQueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    set?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    disconnect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    delete?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    update?: SearchQueryUpdateWithWhereUniqueWithoutUserInput | SearchQueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchQueryUpdateManyWithWhereWithoutUserInput | SearchQueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
  }

  export type LearningAnalyticUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningAnalyticCreateWithoutUserInput, LearningAnalyticUncheckedCreateWithoutUserInput> | LearningAnalyticCreateWithoutUserInput[] | LearningAnalyticUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningAnalyticCreateOrConnectWithoutUserInput | LearningAnalyticCreateOrConnectWithoutUserInput[]
    upsert?: LearningAnalyticUpsertWithWhereUniqueWithoutUserInput | LearningAnalyticUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningAnalyticCreateManyUserInputEnvelope
    set?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    disconnect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    delete?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    connect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    update?: LearningAnalyticUpdateWithWhereUniqueWithoutUserInput | LearningAnalyticUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningAnalyticUpdateManyWithWhereWithoutUserInput | LearningAnalyticUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningAnalyticScalarWhereInput | LearningAnalyticScalarWhereInput[]
  }

  export type ContentRelationshipUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ContentRelationshipCreateWithoutCreatorInput, ContentRelationshipUncheckedCreateWithoutCreatorInput> | ContentRelationshipCreateWithoutCreatorInput[] | ContentRelationshipUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutCreatorInput | ContentRelationshipCreateOrConnectWithoutCreatorInput[]
    upsert?: ContentRelationshipUpsertWithWhereUniqueWithoutCreatorInput | ContentRelationshipUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ContentRelationshipCreateManyCreatorInputEnvelope
    set?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    disconnect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    delete?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    update?: ContentRelationshipUpdateWithWhereUniqueWithoutCreatorInput | ContentRelationshipUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ContentRelationshipUpdateManyWithWhereWithoutCreatorInput | ContentRelationshipUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ContentRelationshipScalarWhereInput | ContentRelationshipScalarWhereInput[]
  }

  export type KnowledgeEdgeUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutCreatorInput, KnowledgeEdgeUncheckedCreateWithoutCreatorInput> | KnowledgeEdgeCreateWithoutCreatorInput[] | KnowledgeEdgeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutCreatorInput | KnowledgeEdgeCreateOrConnectWithoutCreatorInput[]
    upsert?: KnowledgeEdgeUpsertWithWhereUniqueWithoutCreatorInput | KnowledgeEdgeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: KnowledgeEdgeCreateManyCreatorInputEnvelope
    set?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    disconnect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    delete?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    update?: KnowledgeEdgeUpdateWithWhereUniqueWithoutCreatorInput | KnowledgeEdgeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: KnowledgeEdgeUpdateManyWithWhereWithoutCreatorInput | KnowledgeEdgeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: KnowledgeEdgeScalarWhereInput | KnowledgeEdgeScalarWhereInput[]
  }

  export type BatchJobUpdateManyWithoutUserNestedInput = {
    create?: XOR<BatchJobCreateWithoutUserInput, BatchJobUncheckedCreateWithoutUserInput> | BatchJobCreateWithoutUserInput[] | BatchJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BatchJobCreateOrConnectWithoutUserInput | BatchJobCreateOrConnectWithoutUserInput[]
    upsert?: BatchJobUpsertWithWhereUniqueWithoutUserInput | BatchJobUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BatchJobCreateManyUserInputEnvelope
    set?: BatchJobWhereUniqueInput | BatchJobWhereUniqueInput[]
    disconnect?: BatchJobWhereUniqueInput | BatchJobWhereUniqueInput[]
    delete?: BatchJobWhereUniqueInput | BatchJobWhereUniqueInput[]
    connect?: BatchJobWhereUniqueInput | BatchJobWhereUniqueInput[]
    update?: BatchJobUpdateWithWhereUniqueWithoutUserInput | BatchJobUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BatchJobUpdateManyWithWhereWithoutUserInput | BatchJobUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BatchJobScalarWhereInput | BatchJobScalarWhereInput[]
  }

  export type PromptLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromptLogCreateWithoutUserInput, PromptLogUncheckedCreateWithoutUserInput> | PromptLogCreateWithoutUserInput[] | PromptLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromptLogCreateOrConnectWithoutUserInput | PromptLogCreateOrConnectWithoutUserInput[]
    upsert?: PromptLogUpsertWithWhereUniqueWithoutUserInput | PromptLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromptLogCreateManyUserInputEnvelope
    set?: PromptLogWhereUniqueInput | PromptLogWhereUniqueInput[]
    disconnect?: PromptLogWhereUniqueInput | PromptLogWhereUniqueInput[]
    delete?: PromptLogWhereUniqueInput | PromptLogWhereUniqueInput[]
    connect?: PromptLogWhereUniqueInput | PromptLogWhereUniqueInput[]
    update?: PromptLogUpdateWithWhereUniqueWithoutUserInput | PromptLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromptLogUpdateManyWithWhereWithoutUserInput | PromptLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromptLogScalarWhereInput | PromptLogScalarWhereInput[]
  }

  export type ChangeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput> | ChangeLogCreateWithoutUserInput[] | ChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutUserInput | ChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutUserInput | ChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChangeLogCreateManyUserInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutUserInput | ChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutUserInput | ChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type ResourceVersionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ResourceVersionCreateWithoutCreatorInput, ResourceVersionUncheckedCreateWithoutCreatorInput> | ResourceVersionCreateWithoutCreatorInput[] | ResourceVersionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ResourceVersionCreateOrConnectWithoutCreatorInput | ResourceVersionCreateOrConnectWithoutCreatorInput[]
    upsert?: ResourceVersionUpsertWithWhereUniqueWithoutCreatorInput | ResourceVersionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ResourceVersionCreateManyCreatorInputEnvelope
    set?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    disconnect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    delete?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    connect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    update?: ResourceVersionUpdateWithWhereUniqueWithoutCreatorInput | ResourceVersionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ResourceVersionUpdateManyWithWhereWithoutCreatorInput | ResourceVersionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ResourceVersionScalarWhereInput | ResourceVersionScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type SpaceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SpaceCreateWithoutUserInput, SpaceUncheckedCreateWithoutUserInput> | SpaceCreateWithoutUserInput[] | SpaceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutUserInput | SpaceCreateOrConnectWithoutUserInput[]
    upsert?: SpaceUpsertWithWhereUniqueWithoutUserInput | SpaceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SpaceCreateManyUserInputEnvelope
    set?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    disconnect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    delete?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    update?: SpaceUpdateWithWhereUniqueWithoutUserInput | SpaceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SpaceUpdateManyWithWhereWithoutUserInput | SpaceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput> | ResourceCreateWithoutUserInput[] | ResourceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutUserInput | ResourceCreateOrConnectWithoutUserInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutUserInput | ResourceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResourceCreateManyUserInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutUserInput | ResourceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutUserInput | ResourceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type SearchQueryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    upsert?: SearchQueryUpsertWithWhereUniqueWithoutUserInput | SearchQueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    set?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    disconnect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    delete?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    update?: SearchQueryUpdateWithWhereUniqueWithoutUserInput | SearchQueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchQueryUpdateManyWithWhereWithoutUserInput | SearchQueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
  }

  export type LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LearningAnalyticCreateWithoutUserInput, LearningAnalyticUncheckedCreateWithoutUserInput> | LearningAnalyticCreateWithoutUserInput[] | LearningAnalyticUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LearningAnalyticCreateOrConnectWithoutUserInput | LearningAnalyticCreateOrConnectWithoutUserInput[]
    upsert?: LearningAnalyticUpsertWithWhereUniqueWithoutUserInput | LearningAnalyticUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LearningAnalyticCreateManyUserInputEnvelope
    set?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    disconnect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    delete?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    connect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    update?: LearningAnalyticUpdateWithWhereUniqueWithoutUserInput | LearningAnalyticUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LearningAnalyticUpdateManyWithWhereWithoutUserInput | LearningAnalyticUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LearningAnalyticScalarWhereInput | LearningAnalyticScalarWhereInput[]
  }

  export type ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ContentRelationshipCreateWithoutCreatorInput, ContentRelationshipUncheckedCreateWithoutCreatorInput> | ContentRelationshipCreateWithoutCreatorInput[] | ContentRelationshipUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutCreatorInput | ContentRelationshipCreateOrConnectWithoutCreatorInput[]
    upsert?: ContentRelationshipUpsertWithWhereUniqueWithoutCreatorInput | ContentRelationshipUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ContentRelationshipCreateManyCreatorInputEnvelope
    set?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    disconnect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    delete?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    update?: ContentRelationshipUpdateWithWhereUniqueWithoutCreatorInput | ContentRelationshipUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ContentRelationshipUpdateManyWithWhereWithoutCreatorInput | ContentRelationshipUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ContentRelationshipScalarWhereInput | ContentRelationshipScalarWhereInput[]
  }

  export type KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutCreatorInput, KnowledgeEdgeUncheckedCreateWithoutCreatorInput> | KnowledgeEdgeCreateWithoutCreatorInput[] | KnowledgeEdgeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutCreatorInput | KnowledgeEdgeCreateOrConnectWithoutCreatorInput[]
    upsert?: KnowledgeEdgeUpsertWithWhereUniqueWithoutCreatorInput | KnowledgeEdgeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: KnowledgeEdgeCreateManyCreatorInputEnvelope
    set?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    disconnect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    delete?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    update?: KnowledgeEdgeUpdateWithWhereUniqueWithoutCreatorInput | KnowledgeEdgeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: KnowledgeEdgeUpdateManyWithWhereWithoutCreatorInput | KnowledgeEdgeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: KnowledgeEdgeScalarWhereInput | KnowledgeEdgeScalarWhereInput[]
  }

  export type BatchJobUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BatchJobCreateWithoutUserInput, BatchJobUncheckedCreateWithoutUserInput> | BatchJobCreateWithoutUserInput[] | BatchJobUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BatchJobCreateOrConnectWithoutUserInput | BatchJobCreateOrConnectWithoutUserInput[]
    upsert?: BatchJobUpsertWithWhereUniqueWithoutUserInput | BatchJobUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BatchJobCreateManyUserInputEnvelope
    set?: BatchJobWhereUniqueInput | BatchJobWhereUniqueInput[]
    disconnect?: BatchJobWhereUniqueInput | BatchJobWhereUniqueInput[]
    delete?: BatchJobWhereUniqueInput | BatchJobWhereUniqueInput[]
    connect?: BatchJobWhereUniqueInput | BatchJobWhereUniqueInput[]
    update?: BatchJobUpdateWithWhereUniqueWithoutUserInput | BatchJobUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BatchJobUpdateManyWithWhereWithoutUserInput | BatchJobUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BatchJobScalarWhereInput | BatchJobScalarWhereInput[]
  }

  export type PromptLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromptLogCreateWithoutUserInput, PromptLogUncheckedCreateWithoutUserInput> | PromptLogCreateWithoutUserInput[] | PromptLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromptLogCreateOrConnectWithoutUserInput | PromptLogCreateOrConnectWithoutUserInput[]
    upsert?: PromptLogUpsertWithWhereUniqueWithoutUserInput | PromptLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromptLogCreateManyUserInputEnvelope
    set?: PromptLogWhereUniqueInput | PromptLogWhereUniqueInput[]
    disconnect?: PromptLogWhereUniqueInput | PromptLogWhereUniqueInput[]
    delete?: PromptLogWhereUniqueInput | PromptLogWhereUniqueInput[]
    connect?: PromptLogWhereUniqueInput | PromptLogWhereUniqueInput[]
    update?: PromptLogUpdateWithWhereUniqueWithoutUserInput | PromptLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromptLogUpdateManyWithWhereWithoutUserInput | PromptLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromptLogScalarWhereInput | PromptLogScalarWhereInput[]
  }

  export type ChangeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput> | ChangeLogCreateWithoutUserInput[] | ChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutUserInput | ChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutUserInput | ChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChangeLogCreateManyUserInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutUserInput | ChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutUserInput | ChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ResourceVersionCreateWithoutCreatorInput, ResourceVersionUncheckedCreateWithoutCreatorInput> | ResourceVersionCreateWithoutCreatorInput[] | ResourceVersionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ResourceVersionCreateOrConnectWithoutCreatorInput | ResourceVersionCreateOrConnectWithoutCreatorInput[]
    upsert?: ResourceVersionUpsertWithWhereUniqueWithoutCreatorInput | ResourceVersionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ResourceVersionCreateManyCreatorInputEnvelope
    set?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    disconnect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    delete?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    connect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    update?: ResourceVersionUpdateWithWhereUniqueWithoutCreatorInput | ResourceVersionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ResourceVersionUpdateManyWithWhereWithoutCreatorInput | ResourceVersionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ResourceVersionScalarWhereInput | ResourceVersionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUser_profileInput = {
    create?: XOR<UserCreateWithoutUser_profileInput, UserUncheckedCreateWithoutUser_profileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_profileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutUser_profileNestedInput = {
    create?: XOR<UserCreateWithoutUser_profileInput, UserUncheckedCreateWithoutUser_profileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_profileInput
    upsert?: UserUpsertWithoutUser_profileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_profileInput, UserUpdateWithoutUser_profileInput>, UserUncheckedUpdateWithoutUser_profileInput>
  }

  export type UserCreateNestedOneWithoutSpacesInput = {
    create?: XOR<UserCreateWithoutSpacesInput, UserUncheckedCreateWithoutSpacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpacesInput
    connect?: UserWhereUniqueInput
  }

  export type ResourceCreateNestedManyWithoutSpaceInput = {
    create?: XOR<ResourceCreateWithoutSpaceInput, ResourceUncheckedCreateWithoutSpaceInput> | ResourceCreateWithoutSpaceInput[] | ResourceUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSpaceInput | ResourceCreateOrConnectWithoutSpaceInput[]
    createMany?: ResourceCreateManySpaceInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<ResourceCreateWithoutSpaceInput, ResourceUncheckedCreateWithoutSpaceInput> | ResourceCreateWithoutSpaceInput[] | ResourceUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSpaceInput | ResourceCreateOrConnectWithoutSpaceInput[]
    createMany?: ResourceCreateManySpaceInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type EnumContentDomainFieldUpdateOperationsInput = {
    set?: $Enums.ContentDomain
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutSpacesNestedInput = {
    create?: XOR<UserCreateWithoutSpacesInput, UserUncheckedCreateWithoutSpacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpacesInput
    upsert?: UserUpsertWithoutSpacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSpacesInput, UserUpdateWithoutSpacesInput>, UserUncheckedUpdateWithoutSpacesInput>
  }

  export type ResourceUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<ResourceCreateWithoutSpaceInput, ResourceUncheckedCreateWithoutSpaceInput> | ResourceCreateWithoutSpaceInput[] | ResourceUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSpaceInput | ResourceCreateOrConnectWithoutSpaceInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutSpaceInput | ResourceUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: ResourceCreateManySpaceInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutSpaceInput | ResourceUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutSpaceInput | ResourceUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<ResourceCreateWithoutSpaceInput, ResourceUncheckedCreateWithoutSpaceInput> | ResourceCreateWithoutSpaceInput[] | ResourceUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutSpaceInput | ResourceCreateOrConnectWithoutSpaceInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutSpaceInput | ResourceUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: ResourceCreateManySpaceInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutSpaceInput | ResourceUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutSpaceInput | ResourceUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type ResourceCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutResourcesInput = {
    create?: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesInput
    connect?: UserWhereUniqueInput
  }

  export type SpaceCreateNestedOneWithoutResourcesInput = {
    create?: XOR<SpaceCreateWithoutResourcesInput, SpaceUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutResourcesInput
    connect?: SpaceWhereUniqueInput
  }

  export type ClassificationCreateNestedOneWithoutResourcesInput = {
    create?: XOR<ClassificationCreateWithoutResourcesInput, ClassificationUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: ClassificationCreateOrConnectWithoutResourcesInput
    connect?: ClassificationWhereUniqueInput
  }

  export type ContentSummaryCreateNestedManyWithoutResourceInput = {
    create?: XOR<ContentSummaryCreateWithoutResourceInput, ContentSummaryUncheckedCreateWithoutResourceInput> | ContentSummaryCreateWithoutResourceInput[] | ContentSummaryUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ContentSummaryCreateOrConnectWithoutResourceInput | ContentSummaryCreateOrConnectWithoutResourceInput[]
    createMany?: ContentSummaryCreateManyResourceInputEnvelope
    connect?: ContentSummaryWhereUniqueInput | ContentSummaryWhereUniqueInput[]
  }

  export type VectorChunkCreateNestedManyWithoutResourceInput = {
    create?: XOR<VectorChunkCreateWithoutResourceInput, VectorChunkUncheckedCreateWithoutResourceInput> | VectorChunkCreateWithoutResourceInput[] | VectorChunkUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutResourceInput | VectorChunkCreateOrConnectWithoutResourceInput[]
    createMany?: VectorChunkCreateManyResourceInputEnvelope
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
  }

  export type ContentRelationshipCreateNestedManyWithoutSourceResourceInput = {
    create?: XOR<ContentRelationshipCreateWithoutSourceResourceInput, ContentRelationshipUncheckedCreateWithoutSourceResourceInput> | ContentRelationshipCreateWithoutSourceResourceInput[] | ContentRelationshipUncheckedCreateWithoutSourceResourceInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutSourceResourceInput | ContentRelationshipCreateOrConnectWithoutSourceResourceInput[]
    createMany?: ContentRelationshipCreateManySourceResourceInputEnvelope
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
  }

  export type ContentRelationshipCreateNestedManyWithoutTargetResourceInput = {
    create?: XOR<ContentRelationshipCreateWithoutTargetResourceInput, ContentRelationshipUncheckedCreateWithoutTargetResourceInput> | ContentRelationshipCreateWithoutTargetResourceInput[] | ContentRelationshipUncheckedCreateWithoutTargetResourceInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutTargetResourceInput | ContentRelationshipCreateOrConnectWithoutTargetResourceInput[]
    createMany?: ContentRelationshipCreateManyTargetResourceInputEnvelope
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
  }

  export type LearningAnalyticCreateNestedManyWithoutResourceInput = {
    create?: XOR<LearningAnalyticCreateWithoutResourceInput, LearningAnalyticUncheckedCreateWithoutResourceInput> | LearningAnalyticCreateWithoutResourceInput[] | LearningAnalyticUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningAnalyticCreateOrConnectWithoutResourceInput | LearningAnalyticCreateOrConnectWithoutResourceInput[]
    createMany?: LearningAnalyticCreateManyResourceInputEnvelope
    connect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
  }

  export type ResourceVersionCreateNestedManyWithoutResourceInput = {
    create?: XOR<ResourceVersionCreateWithoutResourceInput, ResourceVersionUncheckedCreateWithoutResourceInput> | ResourceVersionCreateWithoutResourceInput[] | ResourceVersionUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceVersionCreateOrConnectWithoutResourceInput | ResourceVersionCreateOrConnectWithoutResourceInput[]
    createMany?: ResourceVersionCreateManyResourceInputEnvelope
    connect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
  }

  export type ContentSummaryUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<ContentSummaryCreateWithoutResourceInput, ContentSummaryUncheckedCreateWithoutResourceInput> | ContentSummaryCreateWithoutResourceInput[] | ContentSummaryUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ContentSummaryCreateOrConnectWithoutResourceInput | ContentSummaryCreateOrConnectWithoutResourceInput[]
    createMany?: ContentSummaryCreateManyResourceInputEnvelope
    connect?: ContentSummaryWhereUniqueInput | ContentSummaryWhereUniqueInput[]
  }

  export type VectorChunkUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<VectorChunkCreateWithoutResourceInput, VectorChunkUncheckedCreateWithoutResourceInput> | VectorChunkCreateWithoutResourceInput[] | VectorChunkUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutResourceInput | VectorChunkCreateOrConnectWithoutResourceInput[]
    createMany?: VectorChunkCreateManyResourceInputEnvelope
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
  }

  export type ContentRelationshipUncheckedCreateNestedManyWithoutSourceResourceInput = {
    create?: XOR<ContentRelationshipCreateWithoutSourceResourceInput, ContentRelationshipUncheckedCreateWithoutSourceResourceInput> | ContentRelationshipCreateWithoutSourceResourceInput[] | ContentRelationshipUncheckedCreateWithoutSourceResourceInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutSourceResourceInput | ContentRelationshipCreateOrConnectWithoutSourceResourceInput[]
    createMany?: ContentRelationshipCreateManySourceResourceInputEnvelope
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
  }

  export type ContentRelationshipUncheckedCreateNestedManyWithoutTargetResourceInput = {
    create?: XOR<ContentRelationshipCreateWithoutTargetResourceInput, ContentRelationshipUncheckedCreateWithoutTargetResourceInput> | ContentRelationshipCreateWithoutTargetResourceInput[] | ContentRelationshipUncheckedCreateWithoutTargetResourceInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutTargetResourceInput | ContentRelationshipCreateOrConnectWithoutTargetResourceInput[]
    createMany?: ContentRelationshipCreateManyTargetResourceInputEnvelope
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
  }

  export type LearningAnalyticUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<LearningAnalyticCreateWithoutResourceInput, LearningAnalyticUncheckedCreateWithoutResourceInput> | LearningAnalyticCreateWithoutResourceInput[] | LearningAnalyticUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningAnalyticCreateOrConnectWithoutResourceInput | LearningAnalyticCreateOrConnectWithoutResourceInput[]
    createMany?: LearningAnalyticCreateManyResourceInputEnvelope
    connect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
  }

  export type ResourceVersionUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<ResourceVersionCreateWithoutResourceInput, ResourceVersionUncheckedCreateWithoutResourceInput> | ResourceVersionCreateWithoutResourceInput[] | ResourceVersionUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceVersionCreateOrConnectWithoutResourceInput | ResourceVersionCreateOrConnectWithoutResourceInput[]
    createMany?: ResourceVersionCreateManyResourceInputEnvelope
    connect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
  }

  export type EnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType
  }

  export type ResourceUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumComplexityLevelFieldUpdateOperationsInput = {
    set?: $Enums.ComplexityLevel
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumProcessingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessingStatus
  }

  export type EnumActionDensityFieldUpdateOperationsInput = {
    set?: $Enums.ActionDensity
  }

  export type NullableEnumPracticalApplicabilityFieldUpdateOperationsInput = {
    set?: $Enums.PracticalApplicability | null
  }

  export type UserUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourcesInput
    upsert?: UserUpsertWithoutResourcesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResourcesInput, UserUpdateWithoutResourcesInput>, UserUncheckedUpdateWithoutResourcesInput>
  }

  export type SpaceUpdateOneWithoutResourcesNestedInput = {
    create?: XOR<SpaceCreateWithoutResourcesInput, SpaceUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutResourcesInput
    upsert?: SpaceUpsertWithoutResourcesInput
    disconnect?: SpaceWhereInput | boolean
    delete?: SpaceWhereInput | boolean
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutResourcesInput, SpaceUpdateWithoutResourcesInput>, SpaceUncheckedUpdateWithoutResourcesInput>
  }

  export type ClassificationUpdateOneWithoutResourcesNestedInput = {
    create?: XOR<ClassificationCreateWithoutResourcesInput, ClassificationUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: ClassificationCreateOrConnectWithoutResourcesInput
    upsert?: ClassificationUpsertWithoutResourcesInput
    disconnect?: ClassificationWhereInput | boolean
    delete?: ClassificationWhereInput | boolean
    connect?: ClassificationWhereUniqueInput
    update?: XOR<XOR<ClassificationUpdateToOneWithWhereWithoutResourcesInput, ClassificationUpdateWithoutResourcesInput>, ClassificationUncheckedUpdateWithoutResourcesInput>
  }

  export type ContentSummaryUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ContentSummaryCreateWithoutResourceInput, ContentSummaryUncheckedCreateWithoutResourceInput> | ContentSummaryCreateWithoutResourceInput[] | ContentSummaryUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ContentSummaryCreateOrConnectWithoutResourceInput | ContentSummaryCreateOrConnectWithoutResourceInput[]
    upsert?: ContentSummaryUpsertWithWhereUniqueWithoutResourceInput | ContentSummaryUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ContentSummaryCreateManyResourceInputEnvelope
    set?: ContentSummaryWhereUniqueInput | ContentSummaryWhereUniqueInput[]
    disconnect?: ContentSummaryWhereUniqueInput | ContentSummaryWhereUniqueInput[]
    delete?: ContentSummaryWhereUniqueInput | ContentSummaryWhereUniqueInput[]
    connect?: ContentSummaryWhereUniqueInput | ContentSummaryWhereUniqueInput[]
    update?: ContentSummaryUpdateWithWhereUniqueWithoutResourceInput | ContentSummaryUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ContentSummaryUpdateManyWithWhereWithoutResourceInput | ContentSummaryUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ContentSummaryScalarWhereInput | ContentSummaryScalarWhereInput[]
  }

  export type VectorChunkUpdateManyWithoutResourceNestedInput = {
    create?: XOR<VectorChunkCreateWithoutResourceInput, VectorChunkUncheckedCreateWithoutResourceInput> | VectorChunkCreateWithoutResourceInput[] | VectorChunkUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutResourceInput | VectorChunkCreateOrConnectWithoutResourceInput[]
    upsert?: VectorChunkUpsertWithWhereUniqueWithoutResourceInput | VectorChunkUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: VectorChunkCreateManyResourceInputEnvelope
    set?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    disconnect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    delete?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    update?: VectorChunkUpdateWithWhereUniqueWithoutResourceInput | VectorChunkUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: VectorChunkUpdateManyWithWhereWithoutResourceInput | VectorChunkUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: VectorChunkScalarWhereInput | VectorChunkScalarWhereInput[]
  }

  export type ContentRelationshipUpdateManyWithoutSourceResourceNestedInput = {
    create?: XOR<ContentRelationshipCreateWithoutSourceResourceInput, ContentRelationshipUncheckedCreateWithoutSourceResourceInput> | ContentRelationshipCreateWithoutSourceResourceInput[] | ContentRelationshipUncheckedCreateWithoutSourceResourceInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutSourceResourceInput | ContentRelationshipCreateOrConnectWithoutSourceResourceInput[]
    upsert?: ContentRelationshipUpsertWithWhereUniqueWithoutSourceResourceInput | ContentRelationshipUpsertWithWhereUniqueWithoutSourceResourceInput[]
    createMany?: ContentRelationshipCreateManySourceResourceInputEnvelope
    set?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    disconnect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    delete?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    update?: ContentRelationshipUpdateWithWhereUniqueWithoutSourceResourceInput | ContentRelationshipUpdateWithWhereUniqueWithoutSourceResourceInput[]
    updateMany?: ContentRelationshipUpdateManyWithWhereWithoutSourceResourceInput | ContentRelationshipUpdateManyWithWhereWithoutSourceResourceInput[]
    deleteMany?: ContentRelationshipScalarWhereInput | ContentRelationshipScalarWhereInput[]
  }

  export type ContentRelationshipUpdateManyWithoutTargetResourceNestedInput = {
    create?: XOR<ContentRelationshipCreateWithoutTargetResourceInput, ContentRelationshipUncheckedCreateWithoutTargetResourceInput> | ContentRelationshipCreateWithoutTargetResourceInput[] | ContentRelationshipUncheckedCreateWithoutTargetResourceInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutTargetResourceInput | ContentRelationshipCreateOrConnectWithoutTargetResourceInput[]
    upsert?: ContentRelationshipUpsertWithWhereUniqueWithoutTargetResourceInput | ContentRelationshipUpsertWithWhereUniqueWithoutTargetResourceInput[]
    createMany?: ContentRelationshipCreateManyTargetResourceInputEnvelope
    set?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    disconnect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    delete?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    update?: ContentRelationshipUpdateWithWhereUniqueWithoutTargetResourceInput | ContentRelationshipUpdateWithWhereUniqueWithoutTargetResourceInput[]
    updateMany?: ContentRelationshipUpdateManyWithWhereWithoutTargetResourceInput | ContentRelationshipUpdateManyWithWhereWithoutTargetResourceInput[]
    deleteMany?: ContentRelationshipScalarWhereInput | ContentRelationshipScalarWhereInput[]
  }

  export type LearningAnalyticUpdateManyWithoutResourceNestedInput = {
    create?: XOR<LearningAnalyticCreateWithoutResourceInput, LearningAnalyticUncheckedCreateWithoutResourceInput> | LearningAnalyticCreateWithoutResourceInput[] | LearningAnalyticUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningAnalyticCreateOrConnectWithoutResourceInput | LearningAnalyticCreateOrConnectWithoutResourceInput[]
    upsert?: LearningAnalyticUpsertWithWhereUniqueWithoutResourceInput | LearningAnalyticUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: LearningAnalyticCreateManyResourceInputEnvelope
    set?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    disconnect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    delete?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    connect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    update?: LearningAnalyticUpdateWithWhereUniqueWithoutResourceInput | LearningAnalyticUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: LearningAnalyticUpdateManyWithWhereWithoutResourceInput | LearningAnalyticUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: LearningAnalyticScalarWhereInput | LearningAnalyticScalarWhereInput[]
  }

  export type ResourceVersionUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ResourceVersionCreateWithoutResourceInput, ResourceVersionUncheckedCreateWithoutResourceInput> | ResourceVersionCreateWithoutResourceInput[] | ResourceVersionUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceVersionCreateOrConnectWithoutResourceInput | ResourceVersionCreateOrConnectWithoutResourceInput[]
    upsert?: ResourceVersionUpsertWithWhereUniqueWithoutResourceInput | ResourceVersionUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ResourceVersionCreateManyResourceInputEnvelope
    set?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    disconnect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    delete?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    connect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    update?: ResourceVersionUpdateWithWhereUniqueWithoutResourceInput | ResourceVersionUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ResourceVersionUpdateManyWithWhereWithoutResourceInput | ResourceVersionUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ResourceVersionScalarWhereInput | ResourceVersionScalarWhereInput[]
  }

  export type ContentSummaryUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ContentSummaryCreateWithoutResourceInput, ContentSummaryUncheckedCreateWithoutResourceInput> | ContentSummaryCreateWithoutResourceInput[] | ContentSummaryUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ContentSummaryCreateOrConnectWithoutResourceInput | ContentSummaryCreateOrConnectWithoutResourceInput[]
    upsert?: ContentSummaryUpsertWithWhereUniqueWithoutResourceInput | ContentSummaryUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ContentSummaryCreateManyResourceInputEnvelope
    set?: ContentSummaryWhereUniqueInput | ContentSummaryWhereUniqueInput[]
    disconnect?: ContentSummaryWhereUniqueInput | ContentSummaryWhereUniqueInput[]
    delete?: ContentSummaryWhereUniqueInput | ContentSummaryWhereUniqueInput[]
    connect?: ContentSummaryWhereUniqueInput | ContentSummaryWhereUniqueInput[]
    update?: ContentSummaryUpdateWithWhereUniqueWithoutResourceInput | ContentSummaryUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ContentSummaryUpdateManyWithWhereWithoutResourceInput | ContentSummaryUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ContentSummaryScalarWhereInput | ContentSummaryScalarWhereInput[]
  }

  export type VectorChunkUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<VectorChunkCreateWithoutResourceInput, VectorChunkUncheckedCreateWithoutResourceInput> | VectorChunkCreateWithoutResourceInput[] | VectorChunkUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutResourceInput | VectorChunkCreateOrConnectWithoutResourceInput[]
    upsert?: VectorChunkUpsertWithWhereUniqueWithoutResourceInput | VectorChunkUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: VectorChunkCreateManyResourceInputEnvelope
    set?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    disconnect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    delete?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    update?: VectorChunkUpdateWithWhereUniqueWithoutResourceInput | VectorChunkUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: VectorChunkUpdateManyWithWhereWithoutResourceInput | VectorChunkUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: VectorChunkScalarWhereInput | VectorChunkScalarWhereInput[]
  }

  export type ContentRelationshipUncheckedUpdateManyWithoutSourceResourceNestedInput = {
    create?: XOR<ContentRelationshipCreateWithoutSourceResourceInput, ContentRelationshipUncheckedCreateWithoutSourceResourceInput> | ContentRelationshipCreateWithoutSourceResourceInput[] | ContentRelationshipUncheckedCreateWithoutSourceResourceInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutSourceResourceInput | ContentRelationshipCreateOrConnectWithoutSourceResourceInput[]
    upsert?: ContentRelationshipUpsertWithWhereUniqueWithoutSourceResourceInput | ContentRelationshipUpsertWithWhereUniqueWithoutSourceResourceInput[]
    createMany?: ContentRelationshipCreateManySourceResourceInputEnvelope
    set?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    disconnect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    delete?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    update?: ContentRelationshipUpdateWithWhereUniqueWithoutSourceResourceInput | ContentRelationshipUpdateWithWhereUniqueWithoutSourceResourceInput[]
    updateMany?: ContentRelationshipUpdateManyWithWhereWithoutSourceResourceInput | ContentRelationshipUpdateManyWithWhereWithoutSourceResourceInput[]
    deleteMany?: ContentRelationshipScalarWhereInput | ContentRelationshipScalarWhereInput[]
  }

  export type ContentRelationshipUncheckedUpdateManyWithoutTargetResourceNestedInput = {
    create?: XOR<ContentRelationshipCreateWithoutTargetResourceInput, ContentRelationshipUncheckedCreateWithoutTargetResourceInput> | ContentRelationshipCreateWithoutTargetResourceInput[] | ContentRelationshipUncheckedCreateWithoutTargetResourceInput[]
    connectOrCreate?: ContentRelationshipCreateOrConnectWithoutTargetResourceInput | ContentRelationshipCreateOrConnectWithoutTargetResourceInput[]
    upsert?: ContentRelationshipUpsertWithWhereUniqueWithoutTargetResourceInput | ContentRelationshipUpsertWithWhereUniqueWithoutTargetResourceInput[]
    createMany?: ContentRelationshipCreateManyTargetResourceInputEnvelope
    set?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    disconnect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    delete?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    connect?: ContentRelationshipWhereUniqueInput | ContentRelationshipWhereUniqueInput[]
    update?: ContentRelationshipUpdateWithWhereUniqueWithoutTargetResourceInput | ContentRelationshipUpdateWithWhereUniqueWithoutTargetResourceInput[]
    updateMany?: ContentRelationshipUpdateManyWithWhereWithoutTargetResourceInput | ContentRelationshipUpdateManyWithWhereWithoutTargetResourceInput[]
    deleteMany?: ContentRelationshipScalarWhereInput | ContentRelationshipScalarWhereInput[]
  }

  export type LearningAnalyticUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<LearningAnalyticCreateWithoutResourceInput, LearningAnalyticUncheckedCreateWithoutResourceInput> | LearningAnalyticCreateWithoutResourceInput[] | LearningAnalyticUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: LearningAnalyticCreateOrConnectWithoutResourceInput | LearningAnalyticCreateOrConnectWithoutResourceInput[]
    upsert?: LearningAnalyticUpsertWithWhereUniqueWithoutResourceInput | LearningAnalyticUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: LearningAnalyticCreateManyResourceInputEnvelope
    set?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    disconnect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    delete?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    connect?: LearningAnalyticWhereUniqueInput | LearningAnalyticWhereUniqueInput[]
    update?: LearningAnalyticUpdateWithWhereUniqueWithoutResourceInput | LearningAnalyticUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: LearningAnalyticUpdateManyWithWhereWithoutResourceInput | LearningAnalyticUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: LearningAnalyticScalarWhereInput | LearningAnalyticScalarWhereInput[]
  }

  export type ResourceVersionUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ResourceVersionCreateWithoutResourceInput, ResourceVersionUncheckedCreateWithoutResourceInput> | ResourceVersionCreateWithoutResourceInput[] | ResourceVersionUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceVersionCreateOrConnectWithoutResourceInput | ResourceVersionCreateOrConnectWithoutResourceInput[]
    upsert?: ResourceVersionUpsertWithWhereUniqueWithoutResourceInput | ResourceVersionUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ResourceVersionCreateManyResourceInputEnvelope
    set?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    disconnect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    delete?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    connect?: ResourceVersionWhereUniqueInput | ResourceVersionWhereUniqueInput[]
    update?: ResourceVersionUpdateWithWhereUniqueWithoutResourceInput | ResourceVersionUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ResourceVersionUpdateManyWithWhereWithoutResourceInput | ResourceVersionUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ResourceVersionScalarWhereInput | ResourceVersionScalarWhereInput[]
  }

  export type ResourceVersionCreatetagsInput = {
    set: string[]
  }

  export type ResourceCreateNestedOneWithoutVersionsInput = {
    create?: XOR<ResourceCreateWithoutVersionsInput, ResourceUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutVersionsInput
    connect?: ResourceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResource_versionsInput = {
    create?: XOR<UserCreateWithoutResource_versionsInput, UserUncheckedCreateWithoutResource_versionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResource_versionsInput
    connect?: UserWhereUniqueInput
  }

  export type ResourceVersionUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResourceUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<ResourceCreateWithoutVersionsInput, ResourceUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutVersionsInput
    upsert?: ResourceUpsertWithoutVersionsInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutVersionsInput, ResourceUpdateWithoutVersionsInput>, ResourceUncheckedUpdateWithoutVersionsInput>
  }

  export type UserUpdateOneWithoutResource_versionsNestedInput = {
    create?: XOR<UserCreateWithoutResource_versionsInput, UserUncheckedCreateWithoutResource_versionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResource_versionsInput
    upsert?: UserUpsertWithoutResource_versionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResource_versionsInput, UserUpdateWithoutResource_versionsInput>, UserUncheckedUpdateWithoutResource_versionsInput>
  }

  export type ClassificationCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ClassificationCreateWithoutChildrenInput, ClassificationUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ClassificationCreateOrConnectWithoutChildrenInput
    connect?: ClassificationWhereUniqueInput
  }

  export type ClassificationCreateNestedManyWithoutParentInput = {
    create?: XOR<ClassificationCreateWithoutParentInput, ClassificationUncheckedCreateWithoutParentInput> | ClassificationCreateWithoutParentInput[] | ClassificationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ClassificationCreateOrConnectWithoutParentInput | ClassificationCreateOrConnectWithoutParentInput[]
    createMany?: ClassificationCreateManyParentInputEnvelope
    connect?: ClassificationWhereUniqueInput | ClassificationWhereUniqueInput[]
  }

  export type ResourceCreateNestedManyWithoutClassificationInput = {
    create?: XOR<ResourceCreateWithoutClassificationInput, ResourceUncheckedCreateWithoutClassificationInput> | ResourceCreateWithoutClassificationInput[] | ResourceUncheckedCreateWithoutClassificationInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutClassificationInput | ResourceCreateOrConnectWithoutClassificationInput[]
    createMany?: ResourceCreateManyClassificationInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type ClassificationUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ClassificationCreateWithoutParentInput, ClassificationUncheckedCreateWithoutParentInput> | ClassificationCreateWithoutParentInput[] | ClassificationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ClassificationCreateOrConnectWithoutParentInput | ClassificationCreateOrConnectWithoutParentInput[]
    createMany?: ClassificationCreateManyParentInputEnvelope
    connect?: ClassificationWhereUniqueInput | ClassificationWhereUniqueInput[]
  }

  export type ResourceUncheckedCreateNestedManyWithoutClassificationInput = {
    create?: XOR<ResourceCreateWithoutClassificationInput, ResourceUncheckedCreateWithoutClassificationInput> | ResourceCreateWithoutClassificationInput[] | ResourceUncheckedCreateWithoutClassificationInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutClassificationInput | ResourceCreateOrConnectWithoutClassificationInput[]
    createMany?: ResourceCreateManyClassificationInputEnvelope
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
  }

  export type ClassificationUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ClassificationCreateWithoutChildrenInput, ClassificationUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ClassificationCreateOrConnectWithoutChildrenInput
    upsert?: ClassificationUpsertWithoutChildrenInput
    disconnect?: ClassificationWhereInput | boolean
    delete?: ClassificationWhereInput | boolean
    connect?: ClassificationWhereUniqueInput
    update?: XOR<XOR<ClassificationUpdateToOneWithWhereWithoutChildrenInput, ClassificationUpdateWithoutChildrenInput>, ClassificationUncheckedUpdateWithoutChildrenInput>
  }

  export type ClassificationUpdateManyWithoutParentNestedInput = {
    create?: XOR<ClassificationCreateWithoutParentInput, ClassificationUncheckedCreateWithoutParentInput> | ClassificationCreateWithoutParentInput[] | ClassificationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ClassificationCreateOrConnectWithoutParentInput | ClassificationCreateOrConnectWithoutParentInput[]
    upsert?: ClassificationUpsertWithWhereUniqueWithoutParentInput | ClassificationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ClassificationCreateManyParentInputEnvelope
    set?: ClassificationWhereUniqueInput | ClassificationWhereUniqueInput[]
    disconnect?: ClassificationWhereUniqueInput | ClassificationWhereUniqueInput[]
    delete?: ClassificationWhereUniqueInput | ClassificationWhereUniqueInput[]
    connect?: ClassificationWhereUniqueInput | ClassificationWhereUniqueInput[]
    update?: ClassificationUpdateWithWhereUniqueWithoutParentInput | ClassificationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ClassificationUpdateManyWithWhereWithoutParentInput | ClassificationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ClassificationScalarWhereInput | ClassificationScalarWhereInput[]
  }

  export type ResourceUpdateManyWithoutClassificationNestedInput = {
    create?: XOR<ResourceCreateWithoutClassificationInput, ResourceUncheckedCreateWithoutClassificationInput> | ResourceCreateWithoutClassificationInput[] | ResourceUncheckedCreateWithoutClassificationInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutClassificationInput | ResourceCreateOrConnectWithoutClassificationInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutClassificationInput | ResourceUpsertWithWhereUniqueWithoutClassificationInput[]
    createMany?: ResourceCreateManyClassificationInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutClassificationInput | ResourceUpdateWithWhereUniqueWithoutClassificationInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutClassificationInput | ResourceUpdateManyWithWhereWithoutClassificationInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type ClassificationUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ClassificationCreateWithoutParentInput, ClassificationUncheckedCreateWithoutParentInput> | ClassificationCreateWithoutParentInput[] | ClassificationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ClassificationCreateOrConnectWithoutParentInput | ClassificationCreateOrConnectWithoutParentInput[]
    upsert?: ClassificationUpsertWithWhereUniqueWithoutParentInput | ClassificationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ClassificationCreateManyParentInputEnvelope
    set?: ClassificationWhereUniqueInput | ClassificationWhereUniqueInput[]
    disconnect?: ClassificationWhereUniqueInput | ClassificationWhereUniqueInput[]
    delete?: ClassificationWhereUniqueInput | ClassificationWhereUniqueInput[]
    connect?: ClassificationWhereUniqueInput | ClassificationWhereUniqueInput[]
    update?: ClassificationUpdateWithWhereUniqueWithoutParentInput | ClassificationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ClassificationUpdateManyWithWhereWithoutParentInput | ClassificationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ClassificationScalarWhereInput | ClassificationScalarWhereInput[]
  }

  export type ResourceUncheckedUpdateManyWithoutClassificationNestedInput = {
    create?: XOR<ResourceCreateWithoutClassificationInput, ResourceUncheckedCreateWithoutClassificationInput> | ResourceCreateWithoutClassificationInput[] | ResourceUncheckedCreateWithoutClassificationInput[]
    connectOrCreate?: ResourceCreateOrConnectWithoutClassificationInput | ResourceCreateOrConnectWithoutClassificationInput[]
    upsert?: ResourceUpsertWithWhereUniqueWithoutClassificationInput | ResourceUpsertWithWhereUniqueWithoutClassificationInput[]
    createMany?: ResourceCreateManyClassificationInputEnvelope
    set?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    disconnect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    delete?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    connect?: ResourceWhereUniqueInput | ResourceWhereUniqueInput[]
    update?: ResourceUpdateWithWhereUniqueWithoutClassificationInput | ResourceUpdateWithWhereUniqueWithoutClassificationInput[]
    updateMany?: ResourceUpdateManyWithWhereWithoutClassificationInput | ResourceUpdateManyWithWhereWithoutClassificationInput[]
    deleteMany?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
  }

  export type ContentSummaryCreatepeopleCompaniesInput = {
    set: string[]
  }

  export type ContentSummaryCreateprimaryKeywordsInput = {
    set: string[]
  }

  export type ContentSummaryCreatesemanticTagsInput = {
    set: string[]
  }

  export type ContentSummaryCreatequestionBasedTagsInput = {
    set: string[]
  }

  export type ResourceCreateNestedOneWithoutContentSummariesInput = {
    create?: XOR<ResourceCreateWithoutContentSummariesInput, ResourceUncheckedCreateWithoutContentSummariesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutContentSummariesInput
    connect?: ResourceWhereUniqueInput
  }

  export type VectorChunkCreateNestedManyWithoutSummaryInput = {
    create?: XOR<VectorChunkCreateWithoutSummaryInput, VectorChunkUncheckedCreateWithoutSummaryInput> | VectorChunkCreateWithoutSummaryInput[] | VectorChunkUncheckedCreateWithoutSummaryInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutSummaryInput | VectorChunkCreateOrConnectWithoutSummaryInput[]
    createMany?: VectorChunkCreateManySummaryInputEnvelope
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
  }

  export type VectorChunkUncheckedCreateNestedManyWithoutSummaryInput = {
    create?: XOR<VectorChunkCreateWithoutSummaryInput, VectorChunkUncheckedCreateWithoutSummaryInput> | VectorChunkCreateWithoutSummaryInput[] | VectorChunkUncheckedCreateWithoutSummaryInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutSummaryInput | VectorChunkCreateOrConnectWithoutSummaryInput[]
    createMany?: VectorChunkCreateManySummaryInputEnvelope
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
  }

  export type ContentSummaryUpdatepeopleCompaniesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContentSummaryUpdateprimaryKeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContentSummaryUpdatesemanticTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContentSummaryUpdatequestionBasedTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResourceUpdateOneRequiredWithoutContentSummariesNestedInput = {
    create?: XOR<ResourceCreateWithoutContentSummariesInput, ResourceUncheckedCreateWithoutContentSummariesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutContentSummariesInput
    upsert?: ResourceUpsertWithoutContentSummariesInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutContentSummariesInput, ResourceUpdateWithoutContentSummariesInput>, ResourceUncheckedUpdateWithoutContentSummariesInput>
  }

  export type VectorChunkUpdateManyWithoutSummaryNestedInput = {
    create?: XOR<VectorChunkCreateWithoutSummaryInput, VectorChunkUncheckedCreateWithoutSummaryInput> | VectorChunkCreateWithoutSummaryInput[] | VectorChunkUncheckedCreateWithoutSummaryInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutSummaryInput | VectorChunkCreateOrConnectWithoutSummaryInput[]
    upsert?: VectorChunkUpsertWithWhereUniqueWithoutSummaryInput | VectorChunkUpsertWithWhereUniqueWithoutSummaryInput[]
    createMany?: VectorChunkCreateManySummaryInputEnvelope
    set?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    disconnect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    delete?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    update?: VectorChunkUpdateWithWhereUniqueWithoutSummaryInput | VectorChunkUpdateWithWhereUniqueWithoutSummaryInput[]
    updateMany?: VectorChunkUpdateManyWithWhereWithoutSummaryInput | VectorChunkUpdateManyWithWhereWithoutSummaryInput[]
    deleteMany?: VectorChunkScalarWhereInput | VectorChunkScalarWhereInput[]
  }

  export type VectorChunkUncheckedUpdateManyWithoutSummaryNestedInput = {
    create?: XOR<VectorChunkCreateWithoutSummaryInput, VectorChunkUncheckedCreateWithoutSummaryInput> | VectorChunkCreateWithoutSummaryInput[] | VectorChunkUncheckedCreateWithoutSummaryInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutSummaryInput | VectorChunkCreateOrConnectWithoutSummaryInput[]
    upsert?: VectorChunkUpsertWithWhereUniqueWithoutSummaryInput | VectorChunkUpsertWithWhereUniqueWithoutSummaryInput[]
    createMany?: VectorChunkCreateManySummaryInputEnvelope
    set?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    disconnect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    delete?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    update?: VectorChunkUpdateWithWhereUniqueWithoutSummaryInput | VectorChunkUpdateWithWhereUniqueWithoutSummaryInput[]
    updateMany?: VectorChunkUpdateManyWithWhereWithoutSummaryInput | VectorChunkUpdateManyWithWhereWithoutSummaryInput[]
    deleteMany?: VectorChunkScalarWhereInput | VectorChunkScalarWhereInput[]
  }

  export type VectorChunkCreateoverlappingChunksInput = {
    set: string[]
  }

  export type ResourceCreateNestedOneWithoutVectorChunksInput = {
    create?: XOR<ResourceCreateWithoutVectorChunksInput, ResourceUncheckedCreateWithoutVectorChunksInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutVectorChunksInput
    connect?: ResourceWhereUniqueInput
  }

  export type ContentSummaryCreateNestedOneWithoutVectorChunksInput = {
    create?: XOR<ContentSummaryCreateWithoutVectorChunksInput, ContentSummaryUncheckedCreateWithoutVectorChunksInput>
    connectOrCreate?: ContentSummaryCreateOrConnectWithoutVectorChunksInput
    connect?: ContentSummaryWhereUniqueInput
  }

  export type VectorChunkCreateNestedOneWithoutChildChunksInput = {
    create?: XOR<VectorChunkCreateWithoutChildChunksInput, VectorChunkUncheckedCreateWithoutChildChunksInput>
    connectOrCreate?: VectorChunkCreateOrConnectWithoutChildChunksInput
    connect?: VectorChunkWhereUniqueInput
  }

  export type VectorChunkCreateNestedManyWithoutParentChunkInput = {
    create?: XOR<VectorChunkCreateWithoutParentChunkInput, VectorChunkUncheckedCreateWithoutParentChunkInput> | VectorChunkCreateWithoutParentChunkInput[] | VectorChunkUncheckedCreateWithoutParentChunkInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutParentChunkInput | VectorChunkCreateOrConnectWithoutParentChunkInput[]
    createMany?: VectorChunkCreateManyParentChunkInputEnvelope
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
  }

  export type VectorChunkUncheckedCreateNestedManyWithoutParentChunkInput = {
    create?: XOR<VectorChunkCreateWithoutParentChunkInput, VectorChunkUncheckedCreateWithoutParentChunkInput> | VectorChunkCreateWithoutParentChunkInput[] | VectorChunkUncheckedCreateWithoutParentChunkInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutParentChunkInput | VectorChunkCreateOrConnectWithoutParentChunkInput[]
    createMany?: VectorChunkCreateManyParentChunkInputEnvelope
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
  }

  export type EnumChunkTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChunkType
  }

  export type VectorChunkUpdateoverlappingChunksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ResourceUpdateOneRequiredWithoutVectorChunksNestedInput = {
    create?: XOR<ResourceCreateWithoutVectorChunksInput, ResourceUncheckedCreateWithoutVectorChunksInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutVectorChunksInput
    upsert?: ResourceUpsertWithoutVectorChunksInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutVectorChunksInput, ResourceUpdateWithoutVectorChunksInput>, ResourceUncheckedUpdateWithoutVectorChunksInput>
  }

  export type ContentSummaryUpdateOneRequiredWithoutVectorChunksNestedInput = {
    create?: XOR<ContentSummaryCreateWithoutVectorChunksInput, ContentSummaryUncheckedCreateWithoutVectorChunksInput>
    connectOrCreate?: ContentSummaryCreateOrConnectWithoutVectorChunksInput
    upsert?: ContentSummaryUpsertWithoutVectorChunksInput
    connect?: ContentSummaryWhereUniqueInput
    update?: XOR<XOR<ContentSummaryUpdateToOneWithWhereWithoutVectorChunksInput, ContentSummaryUpdateWithoutVectorChunksInput>, ContentSummaryUncheckedUpdateWithoutVectorChunksInput>
  }

  export type VectorChunkUpdateOneWithoutChildChunksNestedInput = {
    create?: XOR<VectorChunkCreateWithoutChildChunksInput, VectorChunkUncheckedCreateWithoutChildChunksInput>
    connectOrCreate?: VectorChunkCreateOrConnectWithoutChildChunksInput
    upsert?: VectorChunkUpsertWithoutChildChunksInput
    disconnect?: VectorChunkWhereInput | boolean
    delete?: VectorChunkWhereInput | boolean
    connect?: VectorChunkWhereUniqueInput
    update?: XOR<XOR<VectorChunkUpdateToOneWithWhereWithoutChildChunksInput, VectorChunkUpdateWithoutChildChunksInput>, VectorChunkUncheckedUpdateWithoutChildChunksInput>
  }

  export type VectorChunkUpdateManyWithoutParentChunkNestedInput = {
    create?: XOR<VectorChunkCreateWithoutParentChunkInput, VectorChunkUncheckedCreateWithoutParentChunkInput> | VectorChunkCreateWithoutParentChunkInput[] | VectorChunkUncheckedCreateWithoutParentChunkInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutParentChunkInput | VectorChunkCreateOrConnectWithoutParentChunkInput[]
    upsert?: VectorChunkUpsertWithWhereUniqueWithoutParentChunkInput | VectorChunkUpsertWithWhereUniqueWithoutParentChunkInput[]
    createMany?: VectorChunkCreateManyParentChunkInputEnvelope
    set?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    disconnect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    delete?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    update?: VectorChunkUpdateWithWhereUniqueWithoutParentChunkInput | VectorChunkUpdateWithWhereUniqueWithoutParentChunkInput[]
    updateMany?: VectorChunkUpdateManyWithWhereWithoutParentChunkInput | VectorChunkUpdateManyWithWhereWithoutParentChunkInput[]
    deleteMany?: VectorChunkScalarWhereInput | VectorChunkScalarWhereInput[]
  }

  export type VectorChunkUncheckedUpdateManyWithoutParentChunkNestedInput = {
    create?: XOR<VectorChunkCreateWithoutParentChunkInput, VectorChunkUncheckedCreateWithoutParentChunkInput> | VectorChunkCreateWithoutParentChunkInput[] | VectorChunkUncheckedCreateWithoutParentChunkInput[]
    connectOrCreate?: VectorChunkCreateOrConnectWithoutParentChunkInput | VectorChunkCreateOrConnectWithoutParentChunkInput[]
    upsert?: VectorChunkUpsertWithWhereUniqueWithoutParentChunkInput | VectorChunkUpsertWithWhereUniqueWithoutParentChunkInput[]
    createMany?: VectorChunkCreateManyParentChunkInputEnvelope
    set?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    disconnect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    delete?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    connect?: VectorChunkWhereUniqueInput | VectorChunkWhereUniqueInput[]
    update?: VectorChunkUpdateWithWhereUniqueWithoutParentChunkInput | VectorChunkUpdateWithWhereUniqueWithoutParentChunkInput[]
    updateMany?: VectorChunkUpdateManyWithWhereWithoutParentChunkInput | VectorChunkUpdateManyWithWhereWithoutParentChunkInput[]
    deleteMany?: VectorChunkScalarWhereInput | VectorChunkScalarWhereInput[]
  }

  export type ResourceCreateNestedOneWithoutSourceOfRelationshipsInput = {
    create?: XOR<ResourceCreateWithoutSourceOfRelationshipsInput, ResourceUncheckedCreateWithoutSourceOfRelationshipsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutSourceOfRelationshipsInput
    connect?: ResourceWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutTargetOfRelationshipsInput = {
    create?: XOR<ResourceCreateWithoutTargetOfRelationshipsInput, ResourceUncheckedCreateWithoutTargetOfRelationshipsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutTargetOfRelationshipsInput
    connect?: ResourceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContent_relationshipsInput = {
    create?: XOR<UserCreateWithoutContent_relationshipsInput, UserUncheckedCreateWithoutContent_relationshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContent_relationshipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRelationshipTypeFieldUpdateOperationsInput = {
    set?: $Enums.RelationshipType
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ResourceUpdateOneRequiredWithoutSourceOfRelationshipsNestedInput = {
    create?: XOR<ResourceCreateWithoutSourceOfRelationshipsInput, ResourceUncheckedCreateWithoutSourceOfRelationshipsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutSourceOfRelationshipsInput
    upsert?: ResourceUpsertWithoutSourceOfRelationshipsInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutSourceOfRelationshipsInput, ResourceUpdateWithoutSourceOfRelationshipsInput>, ResourceUncheckedUpdateWithoutSourceOfRelationshipsInput>
  }

  export type ResourceUpdateOneRequiredWithoutTargetOfRelationshipsNestedInput = {
    create?: XOR<ResourceCreateWithoutTargetOfRelationshipsInput, ResourceUncheckedCreateWithoutTargetOfRelationshipsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutTargetOfRelationshipsInput
    upsert?: ResourceUpsertWithoutTargetOfRelationshipsInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutTargetOfRelationshipsInput, ResourceUpdateWithoutTargetOfRelationshipsInput>, ResourceUncheckedUpdateWithoutTargetOfRelationshipsInput>
  }

  export type UserUpdateOneWithoutContent_relationshipsNestedInput = {
    create?: XOR<UserCreateWithoutContent_relationshipsInput, UserUncheckedCreateWithoutContent_relationshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContent_relationshipsInput
    upsert?: UserUpsertWithoutContent_relationshipsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContent_relationshipsInput, UserUpdateWithoutContent_relationshipsInput>, UserUncheckedUpdateWithoutContent_relationshipsInput>
  }

  export type KnowledgeNodeCreatementionedInResourcesInput = {
    set: string[]
  }

  export type KnowledgeEdgeCreateNestedManyWithoutSourceNodeInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutSourceNodeInput, KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput> | KnowledgeEdgeCreateWithoutSourceNodeInput[] | KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutSourceNodeInput | KnowledgeEdgeCreateOrConnectWithoutSourceNodeInput[]
    createMany?: KnowledgeEdgeCreateManySourceNodeInputEnvelope
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
  }

  export type KnowledgeEdgeCreateNestedManyWithoutTargetNodeInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutTargetNodeInput, KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput> | KnowledgeEdgeCreateWithoutTargetNodeInput[] | KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutTargetNodeInput | KnowledgeEdgeCreateOrConnectWithoutTargetNodeInput[]
    createMany?: KnowledgeEdgeCreateManyTargetNodeInputEnvelope
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
  }

  export type KnowledgeEdgeUncheckedCreateNestedManyWithoutSourceNodeInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutSourceNodeInput, KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput> | KnowledgeEdgeCreateWithoutSourceNodeInput[] | KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutSourceNodeInput | KnowledgeEdgeCreateOrConnectWithoutSourceNodeInput[]
    createMany?: KnowledgeEdgeCreateManySourceNodeInputEnvelope
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
  }

  export type KnowledgeEdgeUncheckedCreateNestedManyWithoutTargetNodeInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutTargetNodeInput, KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput> | KnowledgeEdgeCreateWithoutTargetNodeInput[] | KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutTargetNodeInput | KnowledgeEdgeCreateOrConnectWithoutTargetNodeInput[]
    createMany?: KnowledgeEdgeCreateManyTargetNodeInputEnvelope
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
  }

  export type NullableEnumContentDomainFieldUpdateOperationsInput = {
    set?: $Enums.ContentDomain | null
  }

  export type KnowledgeNodeUpdatementionedInResourcesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type KnowledgeEdgeUpdateManyWithoutSourceNodeNestedInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutSourceNodeInput, KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput> | KnowledgeEdgeCreateWithoutSourceNodeInput[] | KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutSourceNodeInput | KnowledgeEdgeCreateOrConnectWithoutSourceNodeInput[]
    upsert?: KnowledgeEdgeUpsertWithWhereUniqueWithoutSourceNodeInput | KnowledgeEdgeUpsertWithWhereUniqueWithoutSourceNodeInput[]
    createMany?: KnowledgeEdgeCreateManySourceNodeInputEnvelope
    set?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    disconnect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    delete?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    update?: KnowledgeEdgeUpdateWithWhereUniqueWithoutSourceNodeInput | KnowledgeEdgeUpdateWithWhereUniqueWithoutSourceNodeInput[]
    updateMany?: KnowledgeEdgeUpdateManyWithWhereWithoutSourceNodeInput | KnowledgeEdgeUpdateManyWithWhereWithoutSourceNodeInput[]
    deleteMany?: KnowledgeEdgeScalarWhereInput | KnowledgeEdgeScalarWhereInput[]
  }

  export type KnowledgeEdgeUpdateManyWithoutTargetNodeNestedInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutTargetNodeInput, KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput> | KnowledgeEdgeCreateWithoutTargetNodeInput[] | KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutTargetNodeInput | KnowledgeEdgeCreateOrConnectWithoutTargetNodeInput[]
    upsert?: KnowledgeEdgeUpsertWithWhereUniqueWithoutTargetNodeInput | KnowledgeEdgeUpsertWithWhereUniqueWithoutTargetNodeInput[]
    createMany?: KnowledgeEdgeCreateManyTargetNodeInputEnvelope
    set?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    disconnect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    delete?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    update?: KnowledgeEdgeUpdateWithWhereUniqueWithoutTargetNodeInput | KnowledgeEdgeUpdateWithWhereUniqueWithoutTargetNodeInput[]
    updateMany?: KnowledgeEdgeUpdateManyWithWhereWithoutTargetNodeInput | KnowledgeEdgeUpdateManyWithWhereWithoutTargetNodeInput[]
    deleteMany?: KnowledgeEdgeScalarWhereInput | KnowledgeEdgeScalarWhereInput[]
  }

  export type KnowledgeEdgeUncheckedUpdateManyWithoutSourceNodeNestedInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutSourceNodeInput, KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput> | KnowledgeEdgeCreateWithoutSourceNodeInput[] | KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutSourceNodeInput | KnowledgeEdgeCreateOrConnectWithoutSourceNodeInput[]
    upsert?: KnowledgeEdgeUpsertWithWhereUniqueWithoutSourceNodeInput | KnowledgeEdgeUpsertWithWhereUniqueWithoutSourceNodeInput[]
    createMany?: KnowledgeEdgeCreateManySourceNodeInputEnvelope
    set?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    disconnect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    delete?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    update?: KnowledgeEdgeUpdateWithWhereUniqueWithoutSourceNodeInput | KnowledgeEdgeUpdateWithWhereUniqueWithoutSourceNodeInput[]
    updateMany?: KnowledgeEdgeUpdateManyWithWhereWithoutSourceNodeInput | KnowledgeEdgeUpdateManyWithWhereWithoutSourceNodeInput[]
    deleteMany?: KnowledgeEdgeScalarWhereInput | KnowledgeEdgeScalarWhereInput[]
  }

  export type KnowledgeEdgeUncheckedUpdateManyWithoutTargetNodeNestedInput = {
    create?: XOR<KnowledgeEdgeCreateWithoutTargetNodeInput, KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput> | KnowledgeEdgeCreateWithoutTargetNodeInput[] | KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput[]
    connectOrCreate?: KnowledgeEdgeCreateOrConnectWithoutTargetNodeInput | KnowledgeEdgeCreateOrConnectWithoutTargetNodeInput[]
    upsert?: KnowledgeEdgeUpsertWithWhereUniqueWithoutTargetNodeInput | KnowledgeEdgeUpsertWithWhereUniqueWithoutTargetNodeInput[]
    createMany?: KnowledgeEdgeCreateManyTargetNodeInputEnvelope
    set?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    disconnect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    delete?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    connect?: KnowledgeEdgeWhereUniqueInput | KnowledgeEdgeWhereUniqueInput[]
    update?: KnowledgeEdgeUpdateWithWhereUniqueWithoutTargetNodeInput | KnowledgeEdgeUpdateWithWhereUniqueWithoutTargetNodeInput[]
    updateMany?: KnowledgeEdgeUpdateManyWithWhereWithoutTargetNodeInput | KnowledgeEdgeUpdateManyWithWhereWithoutTargetNodeInput[]
    deleteMany?: KnowledgeEdgeScalarWhereInput | KnowledgeEdgeScalarWhereInput[]
  }

  export type KnowledgeEdgeCreateevidenceResourcesInput = {
    set: string[]
  }

  export type KnowledgeNodeCreateNestedOneWithoutSourceKnowledgeEdgesInput = {
    create?: XOR<KnowledgeNodeCreateWithoutSourceKnowledgeEdgesInput, KnowledgeNodeUncheckedCreateWithoutSourceKnowledgeEdgesInput>
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutSourceKnowledgeEdgesInput
    connect?: KnowledgeNodeWhereUniqueInput
  }

  export type KnowledgeNodeCreateNestedOneWithoutTargetKnowledgeEdgesInput = {
    create?: XOR<KnowledgeNodeCreateWithoutTargetKnowledgeEdgesInput, KnowledgeNodeUncheckedCreateWithoutTargetKnowledgeEdgesInput>
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutTargetKnowledgeEdgesInput
    connect?: KnowledgeNodeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutKnowledge_edges_createdInput = {
    create?: XOR<UserCreateWithoutKnowledge_edges_createdInput, UserUncheckedCreateWithoutKnowledge_edges_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutKnowledge_edges_createdInput
    connect?: UserWhereUniqueInput
  }

  export type KnowledgeEdgeUpdateevidenceResourcesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type KnowledgeNodeUpdateOneRequiredWithoutSourceKnowledgeEdgesNestedInput = {
    create?: XOR<KnowledgeNodeCreateWithoutSourceKnowledgeEdgesInput, KnowledgeNodeUncheckedCreateWithoutSourceKnowledgeEdgesInput>
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutSourceKnowledgeEdgesInput
    upsert?: KnowledgeNodeUpsertWithoutSourceKnowledgeEdgesInput
    connect?: KnowledgeNodeWhereUniqueInput
    update?: XOR<XOR<KnowledgeNodeUpdateToOneWithWhereWithoutSourceKnowledgeEdgesInput, KnowledgeNodeUpdateWithoutSourceKnowledgeEdgesInput>, KnowledgeNodeUncheckedUpdateWithoutSourceKnowledgeEdgesInput>
  }

  export type KnowledgeNodeUpdateOneRequiredWithoutTargetKnowledgeEdgesNestedInput = {
    create?: XOR<KnowledgeNodeCreateWithoutTargetKnowledgeEdgesInput, KnowledgeNodeUncheckedCreateWithoutTargetKnowledgeEdgesInput>
    connectOrCreate?: KnowledgeNodeCreateOrConnectWithoutTargetKnowledgeEdgesInput
    upsert?: KnowledgeNodeUpsertWithoutTargetKnowledgeEdgesInput
    connect?: KnowledgeNodeWhereUniqueInput
    update?: XOR<XOR<KnowledgeNodeUpdateToOneWithWhereWithoutTargetKnowledgeEdgesInput, KnowledgeNodeUpdateWithoutTargetKnowledgeEdgesInput>, KnowledgeNodeUncheckedUpdateWithoutTargetKnowledgeEdgesInput>
  }

  export type UserUpdateOneWithoutKnowledge_edges_createdNestedInput = {
    create?: XOR<UserCreateWithoutKnowledge_edges_createdInput, UserUncheckedCreateWithoutKnowledge_edges_createdInput>
    connectOrCreate?: UserCreateOrConnectWithoutKnowledge_edges_createdInput
    upsert?: UserUpsertWithoutKnowledge_edges_createdInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKnowledge_edges_createdInput, UserUpdateWithoutKnowledge_edges_createdInput>, UserUncheckedUpdateWithoutKnowledge_edges_createdInput>
  }

  export type SearchQueryCreateclickedResultsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSearch_queriesInput = {
    create?: XOR<UserCreateWithoutSearch_queriesInput, UserUncheckedCreateWithoutSearch_queriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearch_queriesInput
    connect?: UserWhereUniqueInput
  }

  export type SearchQueryUpdateclickedResultsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumComplexityLevelFieldUpdateOperationsInput = {
    set?: $Enums.ComplexityLevel | null
  }

  export type UserUpdateOneRequiredWithoutSearch_queriesNestedInput = {
    create?: XOR<UserCreateWithoutSearch_queriesInput, UserUncheckedCreateWithoutSearch_queriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearch_queriesInput
    upsert?: UserUpsertWithoutSearch_queriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearch_queriesInput, UserUpdateWithoutSearch_queriesInput>, UserUncheckedUpdateWithoutSearch_queriesInput>
  }

  export type UserCreateNestedOneWithoutLearning_analyticsInput = {
    create?: XOR<UserCreateWithoutLearning_analyticsInput, UserUncheckedCreateWithoutLearning_analyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearning_analyticsInput
    connect?: UserWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutLearningAnalyticsInput = {
    create?: XOR<ResourceCreateWithoutLearningAnalyticsInput, ResourceUncheckedCreateWithoutLearningAnalyticsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutLearningAnalyticsInput
    connect?: ResourceWhereUniqueInput
  }

  export type NullableEnumImplementationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImplementationStatus | null
  }

  export type UserUpdateOneRequiredWithoutLearning_analyticsNestedInput = {
    create?: XOR<UserCreateWithoutLearning_analyticsInput, UserUncheckedCreateWithoutLearning_analyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearning_analyticsInput
    upsert?: UserUpsertWithoutLearning_analyticsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLearning_analyticsInput, UserUpdateWithoutLearning_analyticsInput>, UserUncheckedUpdateWithoutLearning_analyticsInput>
  }

  export type ResourceUpdateOneWithoutLearningAnalyticsNestedInput = {
    create?: XOR<ResourceCreateWithoutLearningAnalyticsInput, ResourceUncheckedCreateWithoutLearningAnalyticsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutLearningAnalyticsInput
    upsert?: ResourceUpsertWithoutLearningAnalyticsInput
    disconnect?: ResourceWhereInput | boolean
    delete?: ResourceWhereInput | boolean
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutLearningAnalyticsInput, ResourceUpdateWithoutLearningAnalyticsInput>, ResourceUncheckedUpdateWithoutLearningAnalyticsInput>
  }

  export type UserCreateNestedOneWithoutBatch_jobsInput = {
    create?: XOR<UserCreateWithoutBatch_jobsInput, UserUncheckedCreateWithoutBatch_jobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatch_jobsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumBatchJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.BatchJobStatus
  }

  export type UserUpdateOneRequiredWithoutBatch_jobsNestedInput = {
    create?: XOR<UserCreateWithoutBatch_jobsInput, UserUncheckedCreateWithoutBatch_jobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatch_jobsInput
    upsert?: UserUpsertWithoutBatch_jobsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBatch_jobsInput, UserUpdateWithoutBatch_jobsInput>, UserUncheckedUpdateWithoutBatch_jobsInput>
  }

  export type UserCreateNestedOneWithoutPrompt_logsInput = {
    create?: XOR<UserCreateWithoutPrompt_logsInput, UserUncheckedCreateWithoutPrompt_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrompt_logsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPromptLogTierFieldUpdateOperationsInput = {
    set?: $Enums.PromptLogTier
  }

  export type UserUpdateOneWithoutPrompt_logsNestedInput = {
    create?: XOR<UserCreateWithoutPrompt_logsInput, UserUncheckedCreateWithoutPrompt_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrompt_logsInput
    upsert?: UserUpsertWithoutPrompt_logsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrompt_logsInput, UserUpdateWithoutPrompt_logsInput>, UserUncheckedUpdateWithoutPrompt_logsInput>
  }

  export type UserCreateNestedOneWithoutChange_logsInput = {
    create?: XOR<UserCreateWithoutChange_logsInput, UserUncheckedCreateWithoutChange_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChange_logsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutChange_logsNestedInput = {
    create?: XOR<UserCreateWithoutChange_logsInput, UserUncheckedCreateWithoutChange_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChange_logsInput
    upsert?: UserUpsertWithoutChange_logsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChange_logsInput, UserUpdateWithoutChange_logsInput>, UserUncheckedUpdateWithoutChange_logsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumContentDomainFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentDomain | EnumContentDomainFieldRefInput<$PrismaModel>
    in?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel>
    not?: NestedEnumContentDomainFilter<$PrismaModel> | $Enums.ContentDomain
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumContentDomainWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentDomain | EnumContentDomainFieldRefInput<$PrismaModel>
    in?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel>
    not?: NestedEnumContentDomainWithAggregatesFilter<$PrismaModel> | $Enums.ContentDomain
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentDomainFilter<$PrismaModel>
    _max?: NestedEnumContentDomainFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type NestedEnumComplexityLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplexityLevel | EnumComplexityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumComplexityLevelFilter<$PrismaModel> | $Enums.ComplexityLevel
  }

  export type NestedEnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type NestedEnumActionDensityFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionDensity | EnumActionDensityFieldRefInput<$PrismaModel>
    in?: $Enums.ActionDensity[] | ListEnumActionDensityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionDensity[] | ListEnumActionDensityFieldRefInput<$PrismaModel>
    not?: NestedEnumActionDensityFilter<$PrismaModel> | $Enums.ActionDensity
  }

  export type NestedEnumPracticalApplicabilityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PracticalApplicability | EnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.PracticalApplicability[] | ListEnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PracticalApplicability[] | ListEnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPracticalApplicabilityNullableFilter<$PrismaModel> | $Enums.PracticalApplicability | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumComplexityLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplexityLevel | EnumComplexityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumComplexityLevelWithAggregatesFilter<$PrismaModel> | $Enums.ComplexityLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplexityLevelFilter<$PrismaModel>
    _max?: NestedEnumComplexityLevelFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }

  export type NestedEnumActionDensityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionDensity | EnumActionDensityFieldRefInput<$PrismaModel>
    in?: $Enums.ActionDensity[] | ListEnumActionDensityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionDensity[] | ListEnumActionDensityFieldRefInput<$PrismaModel>
    not?: NestedEnumActionDensityWithAggregatesFilter<$PrismaModel> | $Enums.ActionDensity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionDensityFilter<$PrismaModel>
    _max?: NestedEnumActionDensityFilter<$PrismaModel>
  }

  export type NestedEnumPracticalApplicabilityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PracticalApplicability | EnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    in?: $Enums.PracticalApplicability[] | ListEnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PracticalApplicability[] | ListEnumPracticalApplicabilityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPracticalApplicabilityNullableWithAggregatesFilter<$PrismaModel> | $Enums.PracticalApplicability | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPracticalApplicabilityNullableFilter<$PrismaModel>
    _max?: NestedEnumPracticalApplicabilityNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumChunkTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChunkType | EnumChunkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChunkType[] | ListEnumChunkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChunkType[] | ListEnumChunkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChunkTypeFilter<$PrismaModel> | $Enums.ChunkType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumChunkTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChunkType | EnumChunkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChunkType[] | ListEnumChunkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChunkType[] | ListEnumChunkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChunkTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChunkType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChunkTypeFilter<$PrismaModel>
    _max?: NestedEnumChunkTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumRelationshipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipType | EnumRelationshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipTypeFilter<$PrismaModel> | $Enums.RelationshipType
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumRelationshipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipType | EnumRelationshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationshipTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationshipTypeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumContentDomainNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentDomain | EnumContentDomainFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentDomainNullableFilter<$PrismaModel> | $Enums.ContentDomain | null
  }

  export type NestedEnumContentDomainNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentDomain | EnumContentDomainFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentDomain[] | ListEnumContentDomainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentDomainNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContentDomain | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContentDomainNullableFilter<$PrismaModel>
    _max?: NestedEnumContentDomainNullableFilter<$PrismaModel>
  }

  export type NestedEnumComplexityLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplexityLevel | EnumComplexityLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumComplexityLevelNullableFilter<$PrismaModel> | $Enums.ComplexityLevel | null
  }

  export type NestedEnumComplexityLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplexityLevel | EnumComplexityLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ComplexityLevel[] | ListEnumComplexityLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumComplexityLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.ComplexityLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumComplexityLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumComplexityLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumImplementationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ImplementationStatus | EnumImplementationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ImplementationStatus[] | ListEnumImplementationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ImplementationStatus[] | ListEnumImplementationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumImplementationStatusNullableFilter<$PrismaModel> | $Enums.ImplementationStatus | null
  }

  export type NestedEnumImplementationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImplementationStatus | EnumImplementationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ImplementationStatus[] | ListEnumImplementationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ImplementationStatus[] | ListEnumImplementationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumImplementationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ImplementationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumImplementationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumImplementationStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumBatchJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchJobStatus | EnumBatchJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchJobStatus[] | ListEnumBatchJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchJobStatus[] | ListEnumBatchJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchJobStatusFilter<$PrismaModel> | $Enums.BatchJobStatus
  }

  export type NestedEnumBatchJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchJobStatus | EnumBatchJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchJobStatus[] | ListEnumBatchJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchJobStatus[] | ListEnumBatchJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchJobStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumPromptLogTierFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptLogTier | EnumPromptLogTierFieldRefInput<$PrismaModel>
    in?: $Enums.PromptLogTier[] | ListEnumPromptLogTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptLogTier[] | ListEnumPromptLogTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptLogTierFilter<$PrismaModel> | $Enums.PromptLogTier
  }

  export type NestedEnumPromptLogTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptLogTier | EnumPromptLogTierFieldRefInput<$PrismaModel>
    in?: $Enums.PromptLogTier[] | ListEnumPromptLogTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptLogTier[] | ListEnumPromptLogTierFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptLogTierWithAggregatesFilter<$PrismaModel> | $Enums.PromptLogTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromptLogTierFilter<$PrismaModel>
    _max?: NestedEnumPromptLogTierFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserProfileCreateWithoutUserInput = {
    email: string
    fullName?: string | null
    avatarUrl?: string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: number
    totalEmbeddings?: number
    monthlyQuotaUsed?: number
    lastActiveDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    email: string
    fullName?: string | null
    avatarUrl?: string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: number
    totalEmbeddings?: number
    monthlyQuotaUsed?: number
    lastActiveDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type SpaceCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    domain: $Enums.ContentDomain
    isDefault?: boolean
    contentCount?: number
    lastAccessed?: Date | string
    pineconeNamespace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resources?: ResourceCreateNestedManyWithoutSpaceInput
  }

  export type SpaceUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    domain: $Enums.ContentDomain
    isDefault?: boolean
    contentCount?: number
    lastAccessed?: Date | string
    pineconeNamespace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resources?: ResourceUncheckedCreateNestedManyWithoutSpaceInput
  }

  export type SpaceCreateOrConnectWithoutUserInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutUserInput, SpaceUncheckedCreateWithoutUserInput>
  }

  export type SpaceCreateManyUserInputEnvelope = {
    data: SpaceCreateManyUserInput | SpaceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    space?: SpaceCreateNestedOneWithoutResourcesInput
    classification?: ClassificationCreateNestedOneWithoutResourcesInput
    contentSummaries?: ContentSummaryCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    spaceId?: string | null
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contentSummaries?: ContentSummaryUncheckedCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticUncheckedCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutUserInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput>
  }

  export type ResourceCreateManyUserInputEnvelope = {
    data: ResourceCreateManyUserInput | ResourceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SearchQueryCreateWithoutUserInput = {
    id?: string
    query: string
    queryType?: string
    resultsCount?: number
    avgRelevanceScore?: Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryCreateclickedResultsInput | string[]
    extractedIntent?: string | null
    domainClassification?: $Enums.ContentDomain | null
    complexityDetected?: $Enums.ComplexityLevel | null
    responseTimeMs?: number | null
    userSatisfaction?: number | null
    createdAt?: Date | string
  }

  export type SearchQueryUncheckedCreateWithoutUserInput = {
    id?: string
    query: string
    queryType?: string
    resultsCount?: number
    avgRelevanceScore?: Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryCreateclickedResultsInput | string[]
    extractedIntent?: string | null
    domainClassification?: $Enums.ContentDomain | null
    complexityDetected?: $Enums.ComplexityLevel | null
    responseTimeMs?: number | null
    userSatisfaction?: number | null
    createdAt?: Date | string
  }

  export type SearchQueryCreateOrConnectWithoutUserInput = {
    where: SearchQueryWhereUniqueInput
    create: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput>
  }

  export type SearchQueryCreateManyUserInputEnvelope = {
    data: SearchQueryCreateManyUserInput | SearchQueryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LearningAnalyticCreateWithoutUserInput = {
    id?: string
    eventType: string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: string | null
    comprehensionLevel?: number | null
    implementationStatus?: $Enums.ImplementationStatus | null
    deviceType?: string | null
    timeSpentSeconds?: number | null
    referralSource?: string | null
    createdAt?: Date | string
    resource?: ResourceCreateNestedOneWithoutLearningAnalyticsInput
  }

  export type LearningAnalyticUncheckedCreateWithoutUserInput = {
    id?: string
    eventType: string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: string | null
    comprehensionLevel?: number | null
    implementationStatus?: $Enums.ImplementationStatus | null
    deviceType?: string | null
    timeSpentSeconds?: number | null
    referralSource?: string | null
    resourceId?: string | null
    createdAt?: Date | string
  }

  export type LearningAnalyticCreateOrConnectWithoutUserInput = {
    where: LearningAnalyticWhereUniqueInput
    create: XOR<LearningAnalyticCreateWithoutUserInput, LearningAnalyticUncheckedCreateWithoutUserInput>
  }

  export type LearningAnalyticCreateManyUserInputEnvelope = {
    data: LearningAnalyticCreateManyUserInput | LearningAnalyticCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContentRelationshipCreateWithoutCreatorInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sourceResource: ResourceCreateNestedOneWithoutSourceOfRelationshipsInput
    targetResource: ResourceCreateNestedOneWithoutTargetOfRelationshipsInput
  }

  export type ContentRelationshipUncheckedCreateWithoutCreatorInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    sourceResourceId: string
    targetResourceId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContentRelationshipCreateOrConnectWithoutCreatorInput = {
    where: ContentRelationshipWhereUniqueInput
    create: XOR<ContentRelationshipCreateWithoutCreatorInput, ContentRelationshipUncheckedCreateWithoutCreatorInput>
  }

  export type ContentRelationshipCreateManyCreatorInputEnvelope = {
    data: ContentRelationshipCreateManyCreatorInput | ContentRelationshipCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeEdgeCreateWithoutCreatorInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sourceNode: KnowledgeNodeCreateNestedOneWithoutSourceKnowledgeEdgesInput
    targetNode: KnowledgeNodeCreateNestedOneWithoutTargetKnowledgeEdgesInput
  }

  export type KnowledgeEdgeUncheckedCreateWithoutCreatorInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    sourceNodeId: string
    targetNodeId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KnowledgeEdgeCreateOrConnectWithoutCreatorInput = {
    where: KnowledgeEdgeWhereUniqueInput
    create: XOR<KnowledgeEdgeCreateWithoutCreatorInput, KnowledgeEdgeUncheckedCreateWithoutCreatorInput>
  }

  export type KnowledgeEdgeCreateManyCreatorInputEnvelope = {
    data: KnowledgeEdgeCreateManyCreatorInput | KnowledgeEdgeCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type BatchJobCreateWithoutUserInput = {
    id?: string
    status: $Enums.BatchJobStatus
    progress?: number
    totalItems: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchJobUncheckedCreateWithoutUserInput = {
    id?: string
    status: $Enums.BatchJobStatus
    progress?: number
    totalItems: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchJobCreateOrConnectWithoutUserInput = {
    where: BatchJobWhereUniqueInput
    create: XOR<BatchJobCreateWithoutUserInput, BatchJobUncheckedCreateWithoutUserInput>
  }

  export type BatchJobCreateManyUserInputEnvelope = {
    data: BatchJobCreateManyUserInput | BatchJobCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PromptLogCreateWithoutUserInput = {
    id?: string
    queryText: string
    tier: $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type PromptLogUncheckedCreateWithoutUserInput = {
    id?: string
    queryText: string
    tier: $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type PromptLogCreateOrConnectWithoutUserInput = {
    where: PromptLogWhereUniqueInput
    create: XOR<PromptLogCreateWithoutUserInput, PromptLogUncheckedCreateWithoutUserInput>
  }

  export type PromptLogCreateManyUserInputEnvelope = {
    data: PromptLogCreateManyUserInput | PromptLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChangeLogCreateWithoutUserInput = {
    id?: string
    changeType: string
    changeDetails?: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
  }

  export type ChangeLogUncheckedCreateWithoutUserInput = {
    id?: string
    changeType: string
    changeDetails?: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
  }

  export type ChangeLogCreateOrConnectWithoutUserInput = {
    where: ChangeLogWhereUniqueInput
    create: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput>
  }

  export type ChangeLogCreateManyUserInputEnvelope = {
    data: ChangeLogCreateManyUserInput | ChangeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResourceVersionCreateWithoutCreatorInput = {
    id?: string
    versionNumber: number
    title: string
    content?: string | null
    tags?: ResourceVersionCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resource: ResourceCreateNestedOneWithoutVersionsInput
  }

  export type ResourceVersionUncheckedCreateWithoutCreatorInput = {
    id?: string
    versionNumber: number
    title: string
    content?: string | null
    tags?: ResourceVersionCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    resourceId: string
    createdAt?: Date | string
  }

  export type ResourceVersionCreateOrConnectWithoutCreatorInput = {
    where: ResourceVersionWhereUniqueInput
    create: XOR<ResourceVersionCreateWithoutCreatorInput, ResourceVersionUncheckedCreateWithoutCreatorInput>
  }

  export type ResourceVersionCreateManyCreatorInputEnvelope = {
    data: ResourceVersionCreateManyCreatorInput | ResourceVersionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: IntFieldUpdateOperationsInput | number
    totalEmbeddings?: IntFieldUpdateOperationsInput | number
    monthlyQuotaUsed?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: JsonNullValueInput | InputJsonValue
    totalProcessedContent?: IntFieldUpdateOperationsInput | number
    totalEmbeddings?: IntFieldUpdateOperationsInput | number
    monthlyQuotaUsed?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceUpsertWithWhereUniqueWithoutUserInput = {
    where: SpaceWhereUniqueInput
    update: XOR<SpaceUpdateWithoutUserInput, SpaceUncheckedUpdateWithoutUserInput>
    create: XOR<SpaceCreateWithoutUserInput, SpaceUncheckedCreateWithoutUserInput>
  }

  export type SpaceUpdateWithWhereUniqueWithoutUserInput = {
    where: SpaceWhereUniqueInput
    data: XOR<SpaceUpdateWithoutUserInput, SpaceUncheckedUpdateWithoutUserInput>
  }

  export type SpaceUpdateManyWithWhereWithoutUserInput = {
    where: SpaceScalarWhereInput
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyWithoutUserInput>
  }

  export type SpaceScalarWhereInput = {
    AND?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
    OR?: SpaceScalarWhereInput[]
    NOT?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
    id?: UuidFilter<"Space"> | string
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    color?: StringFilter<"Space"> | string
    domain?: EnumContentDomainFilter<"Space"> | $Enums.ContentDomain
    isDefault?: BoolFilter<"Space"> | boolean
    contentCount?: IntFilter<"Space"> | number
    lastAccessed?: DateTimeFilter<"Space"> | Date | string
    pineconeNamespace?: StringNullableFilter<"Space"> | string | null
    userId?: UuidFilter<"Space"> | string
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Space"> | Date | string | null
  }

  export type ResourceUpsertWithWhereUniqueWithoutUserInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutUserInput, ResourceUncheckedUpdateWithoutUserInput>
    create: XOR<ResourceCreateWithoutUserInput, ResourceUncheckedCreateWithoutUserInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutUserInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutUserInput, ResourceUncheckedUpdateWithoutUserInput>
  }

  export type ResourceUpdateManyWithWhereWithoutUserInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutUserInput>
  }

  export type ResourceScalarWhereInput = {
    AND?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    OR?: ResourceScalarWhereInput[]
    NOT?: ResourceScalarWhereInput | ResourceScalarWhereInput[]
    id?: UuidFilter<"Resource"> | string
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    url?: StringNullableFilter<"Resource"> | string | null
    type?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    content?: StringNullableFilter<"Resource"> | string | null
    tags?: StringNullableListFilter<"Resource">
    domain?: EnumContentDomainFilter<"Resource"> | $Enums.ContentDomain
    language?: StringFilter<"Resource"> | string
    metadata?: JsonFilter<"Resource">
    complexityLevel?: EnumComplexityLevelFilter<"Resource"> | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: IntNullableFilter<"Resource"> | number | null
    wordCount?: IntNullableFilter<"Resource"> | number | null
    processingStatus?: EnumProcessingStatusFilter<"Resource"> | $Enums.ProcessingStatus
    processedAt?: DateTimeNullableFilter<"Resource"> | Date | string | null
    actionDensity?: EnumActionDensityFilter<"Resource"> | $Enums.ActionDensity
    noveltyScore?: IntNullableFilter<"Resource"> | number | null
    practicalApplicability?: EnumPracticalApplicabilityNullableFilter<"Resource"> | $Enums.PracticalApplicability | null
    userId?: UuidFilter<"Resource"> | string
    spaceId?: UuidNullableFilter<"Resource"> | string | null
    classificationId?: UuidNullableFilter<"Resource"> | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Resource"> | Date | string | null
  }

  export type SearchQueryUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchQueryWhereUniqueInput
    update: XOR<SearchQueryUpdateWithoutUserInput, SearchQueryUncheckedUpdateWithoutUserInput>
    create: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput>
  }

  export type SearchQueryUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchQueryWhereUniqueInput
    data: XOR<SearchQueryUpdateWithoutUserInput, SearchQueryUncheckedUpdateWithoutUserInput>
  }

  export type SearchQueryUpdateManyWithWhereWithoutUserInput = {
    where: SearchQueryScalarWhereInput
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyWithoutUserInput>
  }

  export type SearchQueryScalarWhereInput = {
    AND?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
    OR?: SearchQueryScalarWhereInput[]
    NOT?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
    id?: UuidFilter<"SearchQuery"> | string
    query?: StringFilter<"SearchQuery"> | string
    queryType?: StringFilter<"SearchQuery"> | string
    resultsCount?: IntFilter<"SearchQuery"> | number
    avgRelevanceScore?: DecimalNullableFilter<"SearchQuery"> | Decimal | DecimalJsLike | number | string | null
    clickedResults?: StringNullableListFilter<"SearchQuery">
    extractedIntent?: StringNullableFilter<"SearchQuery"> | string | null
    domainClassification?: EnumContentDomainNullableFilter<"SearchQuery"> | $Enums.ContentDomain | null
    complexityDetected?: EnumComplexityLevelNullableFilter<"SearchQuery"> | $Enums.ComplexityLevel | null
    responseTimeMs?: IntNullableFilter<"SearchQuery"> | number | null
    userSatisfaction?: IntNullableFilter<"SearchQuery"> | number | null
    userId?: UuidFilter<"SearchQuery"> | string
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
  }

  export type LearningAnalyticUpsertWithWhereUniqueWithoutUserInput = {
    where: LearningAnalyticWhereUniqueInput
    update: XOR<LearningAnalyticUpdateWithoutUserInput, LearningAnalyticUncheckedUpdateWithoutUserInput>
    create: XOR<LearningAnalyticCreateWithoutUserInput, LearningAnalyticUncheckedCreateWithoutUserInput>
  }

  export type LearningAnalyticUpdateWithWhereUniqueWithoutUserInput = {
    where: LearningAnalyticWhereUniqueInput
    data: XOR<LearningAnalyticUpdateWithoutUserInput, LearningAnalyticUncheckedUpdateWithoutUserInput>
  }

  export type LearningAnalyticUpdateManyWithWhereWithoutUserInput = {
    where: LearningAnalyticScalarWhereInput
    data: XOR<LearningAnalyticUpdateManyMutationInput, LearningAnalyticUncheckedUpdateManyWithoutUserInput>
  }

  export type LearningAnalyticScalarWhereInput = {
    AND?: LearningAnalyticScalarWhereInput | LearningAnalyticScalarWhereInput[]
    OR?: LearningAnalyticScalarWhereInput[]
    NOT?: LearningAnalyticScalarWhereInput | LearningAnalyticScalarWhereInput[]
    id?: UuidFilter<"LearningAnalytic"> | string
    eventType?: StringFilter<"LearningAnalytic"> | string
    eventDetails?: JsonFilter<"LearningAnalytic">
    sessionId?: StringNullableFilter<"LearningAnalytic"> | string | null
    comprehensionLevel?: IntNullableFilter<"LearningAnalytic"> | number | null
    implementationStatus?: EnumImplementationStatusNullableFilter<"LearningAnalytic"> | $Enums.ImplementationStatus | null
    deviceType?: StringNullableFilter<"LearningAnalytic"> | string | null
    timeSpentSeconds?: IntNullableFilter<"LearningAnalytic"> | number | null
    referralSource?: StringNullableFilter<"LearningAnalytic"> | string | null
    userId?: UuidFilter<"LearningAnalytic"> | string
    resourceId?: UuidNullableFilter<"LearningAnalytic"> | string | null
    createdAt?: DateTimeFilter<"LearningAnalytic"> | Date | string
  }

  export type ContentRelationshipUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ContentRelationshipWhereUniqueInput
    update: XOR<ContentRelationshipUpdateWithoutCreatorInput, ContentRelationshipUncheckedUpdateWithoutCreatorInput>
    create: XOR<ContentRelationshipCreateWithoutCreatorInput, ContentRelationshipUncheckedCreateWithoutCreatorInput>
  }

  export type ContentRelationshipUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ContentRelationshipWhereUniqueInput
    data: XOR<ContentRelationshipUpdateWithoutCreatorInput, ContentRelationshipUncheckedUpdateWithoutCreatorInput>
  }

  export type ContentRelationshipUpdateManyWithWhereWithoutCreatorInput = {
    where: ContentRelationshipScalarWhereInput
    data: XOR<ContentRelationshipUpdateManyMutationInput, ContentRelationshipUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ContentRelationshipScalarWhereInput = {
    AND?: ContentRelationshipScalarWhereInput | ContentRelationshipScalarWhereInput[]
    OR?: ContentRelationshipScalarWhereInput[]
    NOT?: ContentRelationshipScalarWhereInput | ContentRelationshipScalarWhereInput[]
    id?: UuidFilter<"ContentRelationship"> | string
    relationshipType?: EnumRelationshipTypeFilter<"ContentRelationship"> | $Enums.RelationshipType
    confidenceScore?: DecimalFilter<"ContentRelationship"> | Decimal | DecimalJsLike | number | string
    relationshipReason?: StringNullableFilter<"ContentRelationship"> | string | null
    isAutoGenerated?: BoolFilter<"ContentRelationship"> | boolean
    sourceResourceId?: UuidFilter<"ContentRelationship"> | string
    targetResourceId?: UuidFilter<"ContentRelationship"> | string
    createdBy?: UuidNullableFilter<"ContentRelationship"> | string | null
    createdAt?: DateTimeFilter<"ContentRelationship"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ContentRelationship"> | Date | string | null
  }

  export type KnowledgeEdgeUpsertWithWhereUniqueWithoutCreatorInput = {
    where: KnowledgeEdgeWhereUniqueInput
    update: XOR<KnowledgeEdgeUpdateWithoutCreatorInput, KnowledgeEdgeUncheckedUpdateWithoutCreatorInput>
    create: XOR<KnowledgeEdgeCreateWithoutCreatorInput, KnowledgeEdgeUncheckedCreateWithoutCreatorInput>
  }

  export type KnowledgeEdgeUpdateWithWhereUniqueWithoutCreatorInput = {
    where: KnowledgeEdgeWhereUniqueInput
    data: XOR<KnowledgeEdgeUpdateWithoutCreatorInput, KnowledgeEdgeUncheckedUpdateWithoutCreatorInput>
  }

  export type KnowledgeEdgeUpdateManyWithWhereWithoutCreatorInput = {
    where: KnowledgeEdgeScalarWhereInput
    data: XOR<KnowledgeEdgeUpdateManyMutationInput, KnowledgeEdgeUncheckedUpdateManyWithoutCreatorInput>
  }

  export type KnowledgeEdgeScalarWhereInput = {
    AND?: KnowledgeEdgeScalarWhereInput | KnowledgeEdgeScalarWhereInput[]
    OR?: KnowledgeEdgeScalarWhereInput[]
    NOT?: KnowledgeEdgeScalarWhereInput | KnowledgeEdgeScalarWhereInput[]
    id?: UuidFilter<"KnowledgeEdge"> | string
    relationshipType?: EnumRelationshipTypeFilter<"KnowledgeEdge"> | $Enums.RelationshipType
    strength?: DecimalFilter<"KnowledgeEdge"> | Decimal | DecimalJsLike | number | string
    evidenceResources?: StringNullableListFilter<"KnowledgeEdge">
    isAutoGenerated?: BoolFilter<"KnowledgeEdge"> | boolean
    sourceNodeId?: UuidFilter<"KnowledgeEdge"> | string
    targetNodeId?: UuidFilter<"KnowledgeEdge"> | string
    createdBy?: UuidNullableFilter<"KnowledgeEdge"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeEdge"> | Date | string
    deletedAt?: DateTimeNullableFilter<"KnowledgeEdge"> | Date | string | null
  }

  export type BatchJobUpsertWithWhereUniqueWithoutUserInput = {
    where: BatchJobWhereUniqueInput
    update: XOR<BatchJobUpdateWithoutUserInput, BatchJobUncheckedUpdateWithoutUserInput>
    create: XOR<BatchJobCreateWithoutUserInput, BatchJobUncheckedCreateWithoutUserInput>
  }

  export type BatchJobUpdateWithWhereUniqueWithoutUserInput = {
    where: BatchJobWhereUniqueInput
    data: XOR<BatchJobUpdateWithoutUserInput, BatchJobUncheckedUpdateWithoutUserInput>
  }

  export type BatchJobUpdateManyWithWhereWithoutUserInput = {
    where: BatchJobScalarWhereInput
    data: XOR<BatchJobUpdateManyMutationInput, BatchJobUncheckedUpdateManyWithoutUserInput>
  }

  export type BatchJobScalarWhereInput = {
    AND?: BatchJobScalarWhereInput | BatchJobScalarWhereInput[]
    OR?: BatchJobScalarWhereInput[]
    NOT?: BatchJobScalarWhereInput | BatchJobScalarWhereInput[]
    id?: UuidFilter<"BatchJob"> | string
    status?: EnumBatchJobStatusFilter<"BatchJob"> | $Enums.BatchJobStatus
    progress?: IntFilter<"BatchJob"> | number
    totalItems?: IntFilter<"BatchJob"> | number
    userId?: UuidFilter<"BatchJob"> | string
    createdAt?: DateTimeFilter<"BatchJob"> | Date | string
    updatedAt?: DateTimeFilter<"BatchJob"> | Date | string
  }

  export type PromptLogUpsertWithWhereUniqueWithoutUserInput = {
    where: PromptLogWhereUniqueInput
    update: XOR<PromptLogUpdateWithoutUserInput, PromptLogUncheckedUpdateWithoutUserInput>
    create: XOR<PromptLogCreateWithoutUserInput, PromptLogUncheckedCreateWithoutUserInput>
  }

  export type PromptLogUpdateWithWhereUniqueWithoutUserInput = {
    where: PromptLogWhereUniqueInput
    data: XOR<PromptLogUpdateWithoutUserInput, PromptLogUncheckedUpdateWithoutUserInput>
  }

  export type PromptLogUpdateManyWithWhereWithoutUserInput = {
    where: PromptLogScalarWhereInput
    data: XOR<PromptLogUpdateManyMutationInput, PromptLogUncheckedUpdateManyWithoutUserInput>
  }

  export type PromptLogScalarWhereInput = {
    AND?: PromptLogScalarWhereInput | PromptLogScalarWhereInput[]
    OR?: PromptLogScalarWhereInput[]
    NOT?: PromptLogScalarWhereInput | PromptLogScalarWhereInput[]
    id?: UuidFilter<"PromptLog"> | string
    queryText?: StringFilter<"PromptLog"> | string
    tier?: EnumPromptLogTierFilter<"PromptLog"> | $Enums.PromptLogTier
    response?: JsonNullableFilter<"PromptLog">
    error?: StringNullableFilter<"PromptLog"> | string | null
    latencyMs?: IntNullableFilter<"PromptLog"> | number | null
    userId?: UuidNullableFilter<"PromptLog"> | string | null
    createdAt?: DateTimeFilter<"PromptLog"> | Date | string
  }

  export type ChangeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ChangeLogWhereUniqueInput
    update: XOR<ChangeLogUpdateWithoutUserInput, ChangeLogUncheckedUpdateWithoutUserInput>
    create: XOR<ChangeLogCreateWithoutUserInput, ChangeLogUncheckedCreateWithoutUserInput>
  }

  export type ChangeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ChangeLogWhereUniqueInput
    data: XOR<ChangeLogUpdateWithoutUserInput, ChangeLogUncheckedUpdateWithoutUserInput>
  }

  export type ChangeLogUpdateManyWithWhereWithoutUserInput = {
    where: ChangeLogScalarWhereInput
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ChangeLogScalarWhereInput = {
    AND?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
    OR?: ChangeLogScalarWhereInput[]
    NOT?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
    id?: UuidFilter<"ChangeLog"> | string
    changeType?: StringFilter<"ChangeLog"> | string
    changeDetails?: JsonFilter<"ChangeLog">
    userId?: UuidNullableFilter<"ChangeLog"> | string | null
    changedAt?: DateTimeFilter<"ChangeLog"> | Date | string
  }

  export type ResourceVersionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ResourceVersionWhereUniqueInput
    update: XOR<ResourceVersionUpdateWithoutCreatorInput, ResourceVersionUncheckedUpdateWithoutCreatorInput>
    create: XOR<ResourceVersionCreateWithoutCreatorInput, ResourceVersionUncheckedCreateWithoutCreatorInput>
  }

  export type ResourceVersionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ResourceVersionWhereUniqueInput
    data: XOR<ResourceVersionUpdateWithoutCreatorInput, ResourceVersionUncheckedUpdateWithoutCreatorInput>
  }

  export type ResourceVersionUpdateManyWithWhereWithoutCreatorInput = {
    where: ResourceVersionScalarWhereInput
    data: XOR<ResourceVersionUpdateManyMutationInput, ResourceVersionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ResourceVersionScalarWhereInput = {
    AND?: ResourceVersionScalarWhereInput | ResourceVersionScalarWhereInput[]
    OR?: ResourceVersionScalarWhereInput[]
    NOT?: ResourceVersionScalarWhereInput | ResourceVersionScalarWhereInput[]
    id?: UuidFilter<"ResourceVersion"> | string
    versionNumber?: IntFilter<"ResourceVersion"> | number
    title?: StringFilter<"ResourceVersion"> | string
    content?: StringNullableFilter<"ResourceVersion"> | string | null
    tags?: StringNullableListFilter<"ResourceVersion">
    metadata?: JsonFilter<"ResourceVersion">
    resourceId?: UuidFilter<"ResourceVersion"> | string
    createdBy?: UuidNullableFilter<"ResourceVersion"> | string | null
    createdAt?: DateTimeFilter<"ResourceVersion"> | Date | string
  }

  export type UserCreateWithoutUser_profileInput = {
    id: string
    spaces?: SpaceCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutUser_profileInput = {
    id: string
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutUser_profileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_profileInput, UserUncheckedCreateWithoutUser_profileInput>
  }

  export type UserUpsertWithoutUser_profileInput = {
    update: XOR<UserUpdateWithoutUser_profileInput, UserUncheckedUpdateWithoutUser_profileInput>
    create: XOR<UserCreateWithoutUser_profileInput, UserUncheckedCreateWithoutUser_profileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_profileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_profileInput, UserUncheckedUpdateWithoutUser_profileInput>
  }

  export type UserUpdateWithoutUser_profileInput = {
    id?: StringFieldUpdateOperationsInput | string
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_profileInput = {
    id?: StringFieldUpdateOperationsInput | string
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutSpacesInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSpacesInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSpacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpacesInput, UserUncheckedCreateWithoutSpacesInput>
  }

  export type ResourceCreateWithoutSpaceInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutResourcesInput
    classification?: ClassificationCreateNestedOneWithoutResourcesInput
    contentSummaries?: ContentSummaryCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutSpaceInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contentSummaries?: ContentSummaryUncheckedCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticUncheckedCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutSpaceInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutSpaceInput, ResourceUncheckedCreateWithoutSpaceInput>
  }

  export type ResourceCreateManySpaceInputEnvelope = {
    data: ResourceCreateManySpaceInput | ResourceCreateManySpaceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSpacesInput = {
    update: XOR<UserUpdateWithoutSpacesInput, UserUncheckedUpdateWithoutSpacesInput>
    create: XOR<UserCreateWithoutSpacesInput, UserUncheckedCreateWithoutSpacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSpacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSpacesInput, UserUncheckedUpdateWithoutSpacesInput>
  }

  export type UserUpdateWithoutSpacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSpacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ResourceUpsertWithWhereUniqueWithoutSpaceInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutSpaceInput, ResourceUncheckedUpdateWithoutSpaceInput>
    create: XOR<ResourceCreateWithoutSpaceInput, ResourceUncheckedCreateWithoutSpaceInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutSpaceInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutSpaceInput, ResourceUncheckedUpdateWithoutSpaceInput>
  }

  export type ResourceUpdateManyWithWhereWithoutSpaceInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutSpaceInput>
  }

  export type UserCreateWithoutResourcesInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    spaces?: SpaceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutResourcesInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutResourcesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
  }

  export type SpaceCreateWithoutResourcesInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    domain: $Enums.ContentDomain
    isDefault?: boolean
    contentCount?: number
    lastAccessed?: Date | string
    pineconeNamespace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSpacesInput
  }

  export type SpaceUncheckedCreateWithoutResourcesInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    domain: $Enums.ContentDomain
    isDefault?: boolean
    contentCount?: number
    lastAccessed?: Date | string
    pineconeNamespace?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SpaceCreateOrConnectWithoutResourcesInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutResourcesInput, SpaceUncheckedCreateWithoutResourcesInput>
  }

  export type ClassificationCreateWithoutResourcesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    domain: $Enums.ContentDomain
    usageCount?: number
    isSystemDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    parent?: ClassificationCreateNestedOneWithoutChildrenInput
    children?: ClassificationCreateNestedManyWithoutParentInput
  }

  export type ClassificationUncheckedCreateWithoutResourcesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    domain: $Enums.ContentDomain
    usageCount?: number
    isSystemDefault?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: ClassificationUncheckedCreateNestedManyWithoutParentInput
  }

  export type ClassificationCreateOrConnectWithoutResourcesInput = {
    where: ClassificationWhereUniqueInput
    create: XOR<ClassificationCreateWithoutResourcesInput, ClassificationUncheckedCreateWithoutResourcesInput>
  }

  export type ContentSummaryCreateWithoutResourceInput = {
    id?: string
    executiveSummary: string
    keyInsights?: string | null
    immediateActions?: string | null
    criticalWarnings?: string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryCreatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryCreateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryCreatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryCreatequestionBasedTagsInput | string[]
    totalChunks?: number
    embeddingModel?: string
    avgChunkTokens?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vectorChunks?: VectorChunkCreateNestedManyWithoutSummaryInput
  }

  export type ContentSummaryUncheckedCreateWithoutResourceInput = {
    id?: string
    executiveSummary: string
    keyInsights?: string | null
    immediateActions?: string | null
    criticalWarnings?: string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryCreatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryCreateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryCreatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryCreatequestionBasedTagsInput | string[]
    totalChunks?: number
    embeddingModel?: string
    avgChunkTokens?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutSummaryInput
  }

  export type ContentSummaryCreateOrConnectWithoutResourceInput = {
    where: ContentSummaryWhereUniqueInput
    create: XOR<ContentSummaryCreateWithoutResourceInput, ContentSummaryUncheckedCreateWithoutResourceInput>
  }

  export type ContentSummaryCreateManyResourceInputEnvelope = {
    data: ContentSummaryCreateManyResourceInput | ContentSummaryCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type VectorChunkCreateWithoutResourceInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    summary: ContentSummaryCreateNestedOneWithoutVectorChunksInput
    parentChunk?: VectorChunkCreateNestedOneWithoutChildChunksInput
    childChunks?: VectorChunkCreateNestedManyWithoutParentChunkInput
  }

  export type VectorChunkUncheckedCreateWithoutResourceInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    summaryId: string
    parentChunkId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    childChunks?: VectorChunkUncheckedCreateNestedManyWithoutParentChunkInput
  }

  export type VectorChunkCreateOrConnectWithoutResourceInput = {
    where: VectorChunkWhereUniqueInput
    create: XOR<VectorChunkCreateWithoutResourceInput, VectorChunkUncheckedCreateWithoutResourceInput>
  }

  export type VectorChunkCreateManyResourceInputEnvelope = {
    data: VectorChunkCreateManyResourceInput | VectorChunkCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type ContentRelationshipCreateWithoutSourceResourceInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    targetResource: ResourceCreateNestedOneWithoutTargetOfRelationshipsInput
    creator?: UserCreateNestedOneWithoutContent_relationshipsInput
  }

  export type ContentRelationshipUncheckedCreateWithoutSourceResourceInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    targetResourceId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContentRelationshipCreateOrConnectWithoutSourceResourceInput = {
    where: ContentRelationshipWhereUniqueInput
    create: XOR<ContentRelationshipCreateWithoutSourceResourceInput, ContentRelationshipUncheckedCreateWithoutSourceResourceInput>
  }

  export type ContentRelationshipCreateManySourceResourceInputEnvelope = {
    data: ContentRelationshipCreateManySourceResourceInput | ContentRelationshipCreateManySourceResourceInput[]
    skipDuplicates?: boolean
  }

  export type ContentRelationshipCreateWithoutTargetResourceInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sourceResource: ResourceCreateNestedOneWithoutSourceOfRelationshipsInput
    creator?: UserCreateNestedOneWithoutContent_relationshipsInput
  }

  export type ContentRelationshipUncheckedCreateWithoutTargetResourceInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    sourceResourceId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContentRelationshipCreateOrConnectWithoutTargetResourceInput = {
    where: ContentRelationshipWhereUniqueInput
    create: XOR<ContentRelationshipCreateWithoutTargetResourceInput, ContentRelationshipUncheckedCreateWithoutTargetResourceInput>
  }

  export type ContentRelationshipCreateManyTargetResourceInputEnvelope = {
    data: ContentRelationshipCreateManyTargetResourceInput | ContentRelationshipCreateManyTargetResourceInput[]
    skipDuplicates?: boolean
  }

  export type LearningAnalyticCreateWithoutResourceInput = {
    id?: string
    eventType: string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: string | null
    comprehensionLevel?: number | null
    implementationStatus?: $Enums.ImplementationStatus | null
    deviceType?: string | null
    timeSpentSeconds?: number | null
    referralSource?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLearning_analyticsInput
  }

  export type LearningAnalyticUncheckedCreateWithoutResourceInput = {
    id?: string
    eventType: string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: string | null
    comprehensionLevel?: number | null
    implementationStatus?: $Enums.ImplementationStatus | null
    deviceType?: string | null
    timeSpentSeconds?: number | null
    referralSource?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type LearningAnalyticCreateOrConnectWithoutResourceInput = {
    where: LearningAnalyticWhereUniqueInput
    create: XOR<LearningAnalyticCreateWithoutResourceInput, LearningAnalyticUncheckedCreateWithoutResourceInput>
  }

  export type LearningAnalyticCreateManyResourceInputEnvelope = {
    data: LearningAnalyticCreateManyResourceInput | LearningAnalyticCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type ResourceVersionCreateWithoutResourceInput = {
    id?: string
    versionNumber: number
    title: string
    content?: string | null
    tags?: ResourceVersionCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    creator?: UserCreateNestedOneWithoutResource_versionsInput
  }

  export type ResourceVersionUncheckedCreateWithoutResourceInput = {
    id?: string
    versionNumber: number
    title: string
    content?: string | null
    tags?: ResourceVersionCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type ResourceVersionCreateOrConnectWithoutResourceInput = {
    where: ResourceVersionWhereUniqueInput
    create: XOR<ResourceVersionCreateWithoutResourceInput, ResourceVersionUncheckedCreateWithoutResourceInput>
  }

  export type ResourceVersionCreateManyResourceInputEnvelope = {
    data: ResourceVersionCreateManyResourceInput | ResourceVersionCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutResourcesInput = {
    update: XOR<UserUpdateWithoutResourcesInput, UserUncheckedUpdateWithoutResourcesInput>
    create: XOR<UserCreateWithoutResourcesInput, UserUncheckedCreateWithoutResourcesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResourcesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResourcesInput, UserUncheckedUpdateWithoutResourcesInput>
  }

  export type UserUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SpaceUpsertWithoutResourcesInput = {
    update: XOR<SpaceUpdateWithoutResourcesInput, SpaceUncheckedUpdateWithoutResourcesInput>
    create: XOR<SpaceCreateWithoutResourcesInput, SpaceUncheckedCreateWithoutResourcesInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutResourcesInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutResourcesInput, SpaceUncheckedUpdateWithoutResourcesInput>
  }

  export type SpaceUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    contentCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSpacesNestedInput
  }

  export type SpaceUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    contentCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassificationUpsertWithoutResourcesInput = {
    update: XOR<ClassificationUpdateWithoutResourcesInput, ClassificationUncheckedUpdateWithoutResourcesInput>
    create: XOR<ClassificationCreateWithoutResourcesInput, ClassificationUncheckedCreateWithoutResourcesInput>
    where?: ClassificationWhereInput
  }

  export type ClassificationUpdateToOneWithWhereWithoutResourcesInput = {
    where?: ClassificationWhereInput
    data: XOR<ClassificationUpdateWithoutResourcesInput, ClassificationUncheckedUpdateWithoutResourcesInput>
  }

  export type ClassificationUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ClassificationUpdateOneWithoutChildrenNestedInput
    children?: ClassificationUpdateManyWithoutParentNestedInput
  }

  export type ClassificationUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ClassificationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ContentSummaryUpsertWithWhereUniqueWithoutResourceInput = {
    where: ContentSummaryWhereUniqueInput
    update: XOR<ContentSummaryUpdateWithoutResourceInput, ContentSummaryUncheckedUpdateWithoutResourceInput>
    create: XOR<ContentSummaryCreateWithoutResourceInput, ContentSummaryUncheckedCreateWithoutResourceInput>
  }

  export type ContentSummaryUpdateWithWhereUniqueWithoutResourceInput = {
    where: ContentSummaryWhereUniqueInput
    data: XOR<ContentSummaryUpdateWithoutResourceInput, ContentSummaryUncheckedUpdateWithoutResourceInput>
  }

  export type ContentSummaryUpdateManyWithWhereWithoutResourceInput = {
    where: ContentSummaryScalarWhereInput
    data: XOR<ContentSummaryUpdateManyMutationInput, ContentSummaryUncheckedUpdateManyWithoutResourceInput>
  }

  export type ContentSummaryScalarWhereInput = {
    AND?: ContentSummaryScalarWhereInput | ContentSummaryScalarWhereInput[]
    OR?: ContentSummaryScalarWhereInput[]
    NOT?: ContentSummaryScalarWhereInput | ContentSummaryScalarWhereInput[]
    id?: UuidFilter<"ContentSummary"> | string
    executiveSummary?: StringFilter<"ContentSummary"> | string
    keyInsights?: StringNullableFilter<"ContentSummary"> | string | null
    immediateActions?: StringNullableFilter<"ContentSummary"> | string | null
    criticalWarnings?: StringNullableFilter<"ContentSummary"> | string | null
    keyMetrics?: JsonFilter<"ContentSummary">
    toolsResources?: JsonFilter<"ContentSummary">
    peopleCompanies?: StringNullableListFilter<"ContentSummary">
    primaryKeywords?: StringNullableListFilter<"ContentSummary">
    semanticTags?: StringNullableListFilter<"ContentSummary">
    questionBasedTags?: StringNullableListFilter<"ContentSummary">
    totalChunks?: IntFilter<"ContentSummary"> | number
    embeddingModel?: StringFilter<"ContentSummary"> | string
    avgChunkTokens?: IntNullableFilter<"ContentSummary"> | number | null
    resourceId?: UuidFilter<"ContentSummary"> | string
    createdAt?: DateTimeFilter<"ContentSummary"> | Date | string
    updatedAt?: DateTimeFilter<"ContentSummary"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ContentSummary"> | Date | string | null
  }

  export type VectorChunkUpsertWithWhereUniqueWithoutResourceInput = {
    where: VectorChunkWhereUniqueInput
    update: XOR<VectorChunkUpdateWithoutResourceInput, VectorChunkUncheckedUpdateWithoutResourceInput>
    create: XOR<VectorChunkCreateWithoutResourceInput, VectorChunkUncheckedCreateWithoutResourceInput>
  }

  export type VectorChunkUpdateWithWhereUniqueWithoutResourceInput = {
    where: VectorChunkWhereUniqueInput
    data: XOR<VectorChunkUpdateWithoutResourceInput, VectorChunkUncheckedUpdateWithoutResourceInput>
  }

  export type VectorChunkUpdateManyWithWhereWithoutResourceInput = {
    where: VectorChunkScalarWhereInput
    data: XOR<VectorChunkUpdateManyMutationInput, VectorChunkUncheckedUpdateManyWithoutResourceInput>
  }

  export type VectorChunkScalarWhereInput = {
    AND?: VectorChunkScalarWhereInput | VectorChunkScalarWhereInput[]
    OR?: VectorChunkScalarWhereInput[]
    NOT?: VectorChunkScalarWhereInput | VectorChunkScalarWhereInput[]
    id?: UuidFilter<"VectorChunk"> | string
    chunkIndex?: IntFilter<"VectorChunk"> | number
    chunkType?: EnumChunkTypeFilter<"VectorChunk"> | $Enums.ChunkType
    content?: StringFilter<"VectorChunk"> | string
    tokenCount?: IntFilter<"VectorChunk"> | number
    pineconeId?: StringNullableFilter<"VectorChunk"> | string | null
    pineconeNamespace?: StringNullableFilter<"VectorChunk"> | string | null
    embeddingModel?: StringFilter<"VectorChunk"> | string
    vectorDimension?: IntFilter<"VectorChunk"> | number
    overlappingChunks?: StringNullableListFilter<"VectorChunk">
    semanticDensity?: DecimalNullableFilter<"VectorChunk"> | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFilter<"VectorChunk"> | number
    lastRetrieved?: DateTimeNullableFilter<"VectorChunk"> | Date | string | null
    resourceId?: UuidFilter<"VectorChunk"> | string
    summaryId?: UuidFilter<"VectorChunk"> | string
    parentChunkId?: UuidNullableFilter<"VectorChunk"> | string | null
    createdAt?: DateTimeFilter<"VectorChunk"> | Date | string
    updatedAt?: DateTimeFilter<"VectorChunk"> | Date | string
    deletedAt?: DateTimeNullableFilter<"VectorChunk"> | Date | string | null
  }

  export type ContentRelationshipUpsertWithWhereUniqueWithoutSourceResourceInput = {
    where: ContentRelationshipWhereUniqueInput
    update: XOR<ContentRelationshipUpdateWithoutSourceResourceInput, ContentRelationshipUncheckedUpdateWithoutSourceResourceInput>
    create: XOR<ContentRelationshipCreateWithoutSourceResourceInput, ContentRelationshipUncheckedCreateWithoutSourceResourceInput>
  }

  export type ContentRelationshipUpdateWithWhereUniqueWithoutSourceResourceInput = {
    where: ContentRelationshipWhereUniqueInput
    data: XOR<ContentRelationshipUpdateWithoutSourceResourceInput, ContentRelationshipUncheckedUpdateWithoutSourceResourceInput>
  }

  export type ContentRelationshipUpdateManyWithWhereWithoutSourceResourceInput = {
    where: ContentRelationshipScalarWhereInput
    data: XOR<ContentRelationshipUpdateManyMutationInput, ContentRelationshipUncheckedUpdateManyWithoutSourceResourceInput>
  }

  export type ContentRelationshipUpsertWithWhereUniqueWithoutTargetResourceInput = {
    where: ContentRelationshipWhereUniqueInput
    update: XOR<ContentRelationshipUpdateWithoutTargetResourceInput, ContentRelationshipUncheckedUpdateWithoutTargetResourceInput>
    create: XOR<ContentRelationshipCreateWithoutTargetResourceInput, ContentRelationshipUncheckedCreateWithoutTargetResourceInput>
  }

  export type ContentRelationshipUpdateWithWhereUniqueWithoutTargetResourceInput = {
    where: ContentRelationshipWhereUniqueInput
    data: XOR<ContentRelationshipUpdateWithoutTargetResourceInput, ContentRelationshipUncheckedUpdateWithoutTargetResourceInput>
  }

  export type ContentRelationshipUpdateManyWithWhereWithoutTargetResourceInput = {
    where: ContentRelationshipScalarWhereInput
    data: XOR<ContentRelationshipUpdateManyMutationInput, ContentRelationshipUncheckedUpdateManyWithoutTargetResourceInput>
  }

  export type LearningAnalyticUpsertWithWhereUniqueWithoutResourceInput = {
    where: LearningAnalyticWhereUniqueInput
    update: XOR<LearningAnalyticUpdateWithoutResourceInput, LearningAnalyticUncheckedUpdateWithoutResourceInput>
    create: XOR<LearningAnalyticCreateWithoutResourceInput, LearningAnalyticUncheckedCreateWithoutResourceInput>
  }

  export type LearningAnalyticUpdateWithWhereUniqueWithoutResourceInput = {
    where: LearningAnalyticWhereUniqueInput
    data: XOR<LearningAnalyticUpdateWithoutResourceInput, LearningAnalyticUncheckedUpdateWithoutResourceInput>
  }

  export type LearningAnalyticUpdateManyWithWhereWithoutResourceInput = {
    where: LearningAnalyticScalarWhereInput
    data: XOR<LearningAnalyticUpdateManyMutationInput, LearningAnalyticUncheckedUpdateManyWithoutResourceInput>
  }

  export type ResourceVersionUpsertWithWhereUniqueWithoutResourceInput = {
    where: ResourceVersionWhereUniqueInput
    update: XOR<ResourceVersionUpdateWithoutResourceInput, ResourceVersionUncheckedUpdateWithoutResourceInput>
    create: XOR<ResourceVersionCreateWithoutResourceInput, ResourceVersionUncheckedCreateWithoutResourceInput>
  }

  export type ResourceVersionUpdateWithWhereUniqueWithoutResourceInput = {
    where: ResourceVersionWhereUniqueInput
    data: XOR<ResourceVersionUpdateWithoutResourceInput, ResourceVersionUncheckedUpdateWithoutResourceInput>
  }

  export type ResourceVersionUpdateManyWithWhereWithoutResourceInput = {
    where: ResourceVersionScalarWhereInput
    data: XOR<ResourceVersionUpdateManyMutationInput, ResourceVersionUncheckedUpdateManyWithoutResourceInput>
  }

  export type ResourceCreateWithoutVersionsInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutResourcesInput
    space?: SpaceCreateNestedOneWithoutResourcesInput
    classification?: ClassificationCreateNestedOneWithoutResourcesInput
    contentSummaries?: ContentSummaryCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutVersionsInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    spaceId?: string | null
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contentSummaries?: ContentSummaryUncheckedCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutVersionsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutVersionsInput, ResourceUncheckedCreateWithoutVersionsInput>
  }

  export type UserCreateWithoutResource_versionsInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    spaces?: SpaceCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResource_versionsInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResource_versionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResource_versionsInput, UserUncheckedCreateWithoutResource_versionsInput>
  }

  export type ResourceUpsertWithoutVersionsInput = {
    update: XOR<ResourceUpdateWithoutVersionsInput, ResourceUncheckedUpdateWithoutVersionsInput>
    create: XOR<ResourceCreateWithoutVersionsInput, ResourceUncheckedCreateWithoutVersionsInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutVersionsInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutVersionsInput, ResourceUncheckedUpdateWithoutVersionsInput>
  }

  export type ResourceUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutResourcesNestedInput
    space?: SpaceUpdateOneWithoutResourcesNestedInput
    classification?: ClassificationUpdateOneWithoutResourcesNestedInput
    contentSummaries?: ContentSummaryUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentSummaries?: ContentSummaryUncheckedUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type UserUpsertWithoutResource_versionsInput = {
    update: XOR<UserUpdateWithoutResource_versionsInput, UserUncheckedUpdateWithoutResource_versionsInput>
    create: XOR<UserCreateWithoutResource_versionsInput, UserUncheckedCreateWithoutResource_versionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResource_versionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResource_versionsInput, UserUncheckedUpdateWithoutResource_versionsInput>
  }

  export type UserUpdateWithoutResource_versionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResource_versionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassificationCreateWithoutChildrenInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    domain: $Enums.ContentDomain
    usageCount?: number
    isSystemDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    parent?: ClassificationCreateNestedOneWithoutChildrenInput
    resources?: ResourceCreateNestedManyWithoutClassificationInput
  }

  export type ClassificationUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    domain: $Enums.ContentDomain
    usageCount?: number
    isSystemDefault?: boolean
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resources?: ResourceUncheckedCreateNestedManyWithoutClassificationInput
  }

  export type ClassificationCreateOrConnectWithoutChildrenInput = {
    where: ClassificationWhereUniqueInput
    create: XOR<ClassificationCreateWithoutChildrenInput, ClassificationUncheckedCreateWithoutChildrenInput>
  }

  export type ClassificationCreateWithoutParentInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    domain: $Enums.ContentDomain
    usageCount?: number
    isSystemDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: ClassificationCreateNestedManyWithoutParentInput
    resources?: ResourceCreateNestedManyWithoutClassificationInput
  }

  export type ClassificationUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    domain: $Enums.ContentDomain
    usageCount?: number
    isSystemDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: ClassificationUncheckedCreateNestedManyWithoutParentInput
    resources?: ResourceUncheckedCreateNestedManyWithoutClassificationInput
  }

  export type ClassificationCreateOrConnectWithoutParentInput = {
    where: ClassificationWhereUniqueInput
    create: XOR<ClassificationCreateWithoutParentInput, ClassificationUncheckedCreateWithoutParentInput>
  }

  export type ClassificationCreateManyParentInputEnvelope = {
    data: ClassificationCreateManyParentInput | ClassificationCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ResourceCreateWithoutClassificationInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutResourcesInput
    space?: SpaceCreateNestedOneWithoutResourcesInput
    contentSummaries?: ContentSummaryCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutClassificationInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    spaceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contentSummaries?: ContentSummaryUncheckedCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticUncheckedCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutClassificationInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutClassificationInput, ResourceUncheckedCreateWithoutClassificationInput>
  }

  export type ResourceCreateManyClassificationInputEnvelope = {
    data: ResourceCreateManyClassificationInput | ResourceCreateManyClassificationInput[]
    skipDuplicates?: boolean
  }

  export type ClassificationUpsertWithoutChildrenInput = {
    update: XOR<ClassificationUpdateWithoutChildrenInput, ClassificationUncheckedUpdateWithoutChildrenInput>
    create: XOR<ClassificationCreateWithoutChildrenInput, ClassificationUncheckedCreateWithoutChildrenInput>
    where?: ClassificationWhereInput
  }

  export type ClassificationUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ClassificationWhereInput
    data: XOR<ClassificationUpdateWithoutChildrenInput, ClassificationUncheckedUpdateWithoutChildrenInput>
  }

  export type ClassificationUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: ClassificationUpdateOneWithoutChildrenNestedInput
    resources?: ResourceUpdateManyWithoutClassificationNestedInput
  }

  export type ClassificationUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resources?: ResourceUncheckedUpdateManyWithoutClassificationNestedInput
  }

  export type ClassificationUpsertWithWhereUniqueWithoutParentInput = {
    where: ClassificationWhereUniqueInput
    update: XOR<ClassificationUpdateWithoutParentInput, ClassificationUncheckedUpdateWithoutParentInput>
    create: XOR<ClassificationCreateWithoutParentInput, ClassificationUncheckedCreateWithoutParentInput>
  }

  export type ClassificationUpdateWithWhereUniqueWithoutParentInput = {
    where: ClassificationWhereUniqueInput
    data: XOR<ClassificationUpdateWithoutParentInput, ClassificationUncheckedUpdateWithoutParentInput>
  }

  export type ClassificationUpdateManyWithWhereWithoutParentInput = {
    where: ClassificationScalarWhereInput
    data: XOR<ClassificationUpdateManyMutationInput, ClassificationUncheckedUpdateManyWithoutParentInput>
  }

  export type ClassificationScalarWhereInput = {
    AND?: ClassificationScalarWhereInput | ClassificationScalarWhereInput[]
    OR?: ClassificationScalarWhereInput[]
    NOT?: ClassificationScalarWhereInput | ClassificationScalarWhereInput[]
    id?: UuidFilter<"Classification"> | string
    name?: StringFilter<"Classification"> | string
    code?: StringFilter<"Classification"> | string
    description?: StringNullableFilter<"Classification"> | string | null
    domain?: EnumContentDomainFilter<"Classification"> | $Enums.ContentDomain
    usageCount?: IntFilter<"Classification"> | number
    isSystemDefault?: BoolFilter<"Classification"> | boolean
    parentId?: UuidNullableFilter<"Classification"> | string | null
    createdAt?: DateTimeFilter<"Classification"> | Date | string
    updatedAt?: DateTimeFilter<"Classification"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Classification"> | Date | string | null
  }

  export type ResourceUpsertWithWhereUniqueWithoutClassificationInput = {
    where: ResourceWhereUniqueInput
    update: XOR<ResourceUpdateWithoutClassificationInput, ResourceUncheckedUpdateWithoutClassificationInput>
    create: XOR<ResourceCreateWithoutClassificationInput, ResourceUncheckedCreateWithoutClassificationInput>
  }

  export type ResourceUpdateWithWhereUniqueWithoutClassificationInput = {
    where: ResourceWhereUniqueInput
    data: XOR<ResourceUpdateWithoutClassificationInput, ResourceUncheckedUpdateWithoutClassificationInput>
  }

  export type ResourceUpdateManyWithWhereWithoutClassificationInput = {
    where: ResourceScalarWhereInput
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyWithoutClassificationInput>
  }

  export type ResourceCreateWithoutContentSummariesInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutResourcesInput
    space?: SpaceCreateNestedOneWithoutResourcesInput
    classification?: ClassificationCreateNestedOneWithoutResourcesInput
    vectorChunks?: VectorChunkCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutContentSummariesInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    spaceId?: string | null
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticUncheckedCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutContentSummariesInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutContentSummariesInput, ResourceUncheckedCreateWithoutContentSummariesInput>
  }

  export type VectorChunkCreateWithoutSummaryInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resource: ResourceCreateNestedOneWithoutVectorChunksInput
    parentChunk?: VectorChunkCreateNestedOneWithoutChildChunksInput
    childChunks?: VectorChunkCreateNestedManyWithoutParentChunkInput
  }

  export type VectorChunkUncheckedCreateWithoutSummaryInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    resourceId: string
    parentChunkId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    childChunks?: VectorChunkUncheckedCreateNestedManyWithoutParentChunkInput
  }

  export type VectorChunkCreateOrConnectWithoutSummaryInput = {
    where: VectorChunkWhereUniqueInput
    create: XOR<VectorChunkCreateWithoutSummaryInput, VectorChunkUncheckedCreateWithoutSummaryInput>
  }

  export type VectorChunkCreateManySummaryInputEnvelope = {
    data: VectorChunkCreateManySummaryInput | VectorChunkCreateManySummaryInput[]
    skipDuplicates?: boolean
  }

  export type ResourceUpsertWithoutContentSummariesInput = {
    update: XOR<ResourceUpdateWithoutContentSummariesInput, ResourceUncheckedUpdateWithoutContentSummariesInput>
    create: XOR<ResourceCreateWithoutContentSummariesInput, ResourceUncheckedCreateWithoutContentSummariesInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutContentSummariesInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutContentSummariesInput, ResourceUncheckedUpdateWithoutContentSummariesInput>
  }

  export type ResourceUpdateWithoutContentSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutResourcesNestedInput
    space?: SpaceUpdateOneWithoutResourcesNestedInput
    classification?: ClassificationUpdateOneWithoutResourcesNestedInput
    vectorChunks?: VectorChunkUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutContentSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUncheckedUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type VectorChunkUpsertWithWhereUniqueWithoutSummaryInput = {
    where: VectorChunkWhereUniqueInput
    update: XOR<VectorChunkUpdateWithoutSummaryInput, VectorChunkUncheckedUpdateWithoutSummaryInput>
    create: XOR<VectorChunkCreateWithoutSummaryInput, VectorChunkUncheckedCreateWithoutSummaryInput>
  }

  export type VectorChunkUpdateWithWhereUniqueWithoutSummaryInput = {
    where: VectorChunkWhereUniqueInput
    data: XOR<VectorChunkUpdateWithoutSummaryInput, VectorChunkUncheckedUpdateWithoutSummaryInput>
  }

  export type VectorChunkUpdateManyWithWhereWithoutSummaryInput = {
    where: VectorChunkScalarWhereInput
    data: XOR<VectorChunkUpdateManyMutationInput, VectorChunkUncheckedUpdateManyWithoutSummaryInput>
  }

  export type ResourceCreateWithoutVectorChunksInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutResourcesInput
    space?: SpaceCreateNestedOneWithoutResourcesInput
    classification?: ClassificationCreateNestedOneWithoutResourcesInput
    contentSummaries?: ContentSummaryCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutVectorChunksInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    spaceId?: string | null
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contentSummaries?: ContentSummaryUncheckedCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticUncheckedCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutVectorChunksInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutVectorChunksInput, ResourceUncheckedCreateWithoutVectorChunksInput>
  }

  export type ContentSummaryCreateWithoutVectorChunksInput = {
    id?: string
    executiveSummary: string
    keyInsights?: string | null
    immediateActions?: string | null
    criticalWarnings?: string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryCreatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryCreateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryCreatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryCreatequestionBasedTagsInput | string[]
    totalChunks?: number
    embeddingModel?: string
    avgChunkTokens?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resource: ResourceCreateNestedOneWithoutContentSummariesInput
  }

  export type ContentSummaryUncheckedCreateWithoutVectorChunksInput = {
    id?: string
    executiveSummary: string
    keyInsights?: string | null
    immediateActions?: string | null
    criticalWarnings?: string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryCreatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryCreateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryCreatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryCreatequestionBasedTagsInput | string[]
    totalChunks?: number
    embeddingModel?: string
    avgChunkTokens?: number | null
    resourceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContentSummaryCreateOrConnectWithoutVectorChunksInput = {
    where: ContentSummaryWhereUniqueInput
    create: XOR<ContentSummaryCreateWithoutVectorChunksInput, ContentSummaryUncheckedCreateWithoutVectorChunksInput>
  }

  export type VectorChunkCreateWithoutChildChunksInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resource: ResourceCreateNestedOneWithoutVectorChunksInput
    summary: ContentSummaryCreateNestedOneWithoutVectorChunksInput
    parentChunk?: VectorChunkCreateNestedOneWithoutChildChunksInput
  }

  export type VectorChunkUncheckedCreateWithoutChildChunksInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    resourceId: string
    summaryId: string
    parentChunkId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VectorChunkCreateOrConnectWithoutChildChunksInput = {
    where: VectorChunkWhereUniqueInput
    create: XOR<VectorChunkCreateWithoutChildChunksInput, VectorChunkUncheckedCreateWithoutChildChunksInput>
  }

  export type VectorChunkCreateWithoutParentChunkInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resource: ResourceCreateNestedOneWithoutVectorChunksInput
    summary: ContentSummaryCreateNestedOneWithoutVectorChunksInput
    childChunks?: VectorChunkCreateNestedManyWithoutParentChunkInput
  }

  export type VectorChunkUncheckedCreateWithoutParentChunkInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    resourceId: string
    summaryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    childChunks?: VectorChunkUncheckedCreateNestedManyWithoutParentChunkInput
  }

  export type VectorChunkCreateOrConnectWithoutParentChunkInput = {
    where: VectorChunkWhereUniqueInput
    create: XOR<VectorChunkCreateWithoutParentChunkInput, VectorChunkUncheckedCreateWithoutParentChunkInput>
  }

  export type VectorChunkCreateManyParentChunkInputEnvelope = {
    data: VectorChunkCreateManyParentChunkInput | VectorChunkCreateManyParentChunkInput[]
    skipDuplicates?: boolean
  }

  export type ResourceUpsertWithoutVectorChunksInput = {
    update: XOR<ResourceUpdateWithoutVectorChunksInput, ResourceUncheckedUpdateWithoutVectorChunksInput>
    create: XOR<ResourceCreateWithoutVectorChunksInput, ResourceUncheckedCreateWithoutVectorChunksInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutVectorChunksInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutVectorChunksInput, ResourceUncheckedUpdateWithoutVectorChunksInput>
  }

  export type ResourceUpdateWithoutVectorChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutResourcesNestedInput
    space?: SpaceUpdateOneWithoutResourcesNestedInput
    classification?: ClassificationUpdateOneWithoutResourcesNestedInput
    contentSummaries?: ContentSummaryUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutVectorChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentSummaries?: ContentSummaryUncheckedUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUncheckedUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ContentSummaryUpsertWithoutVectorChunksInput = {
    update: XOR<ContentSummaryUpdateWithoutVectorChunksInput, ContentSummaryUncheckedUpdateWithoutVectorChunksInput>
    create: XOR<ContentSummaryCreateWithoutVectorChunksInput, ContentSummaryUncheckedCreateWithoutVectorChunksInput>
    where?: ContentSummaryWhereInput
  }

  export type ContentSummaryUpdateToOneWithWhereWithoutVectorChunksInput = {
    where?: ContentSummaryWhereInput
    data: XOR<ContentSummaryUpdateWithoutVectorChunksInput, ContentSummaryUncheckedUpdateWithoutVectorChunksInput>
  }

  export type ContentSummaryUpdateWithoutVectorChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    keyInsights?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryUpdatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryUpdateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryUpdatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryUpdatequestionBasedTagsInput | string[]
    totalChunks?: IntFieldUpdateOperationsInput | number
    embeddingModel?: StringFieldUpdateOperationsInput | string
    avgChunkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resource?: ResourceUpdateOneRequiredWithoutContentSummariesNestedInput
  }

  export type ContentSummaryUncheckedUpdateWithoutVectorChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    keyInsights?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryUpdatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryUpdateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryUpdatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryUpdatequestionBasedTagsInput | string[]
    totalChunks?: IntFieldUpdateOperationsInput | number
    embeddingModel?: StringFieldUpdateOperationsInput | string
    avgChunkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VectorChunkUpsertWithoutChildChunksInput = {
    update: XOR<VectorChunkUpdateWithoutChildChunksInput, VectorChunkUncheckedUpdateWithoutChildChunksInput>
    create: XOR<VectorChunkCreateWithoutChildChunksInput, VectorChunkUncheckedCreateWithoutChildChunksInput>
    where?: VectorChunkWhereInput
  }

  export type VectorChunkUpdateToOneWithWhereWithoutChildChunksInput = {
    where?: VectorChunkWhereInput
    data: XOR<VectorChunkUpdateWithoutChildChunksInput, VectorChunkUncheckedUpdateWithoutChildChunksInput>
  }

  export type VectorChunkUpdateWithoutChildChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resource?: ResourceUpdateOneRequiredWithoutVectorChunksNestedInput
    summary?: ContentSummaryUpdateOneRequiredWithoutVectorChunksNestedInput
    parentChunk?: VectorChunkUpdateOneWithoutChildChunksNestedInput
  }

  export type VectorChunkUncheckedUpdateWithoutChildChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resourceId?: StringFieldUpdateOperationsInput | string
    summaryId?: StringFieldUpdateOperationsInput | string
    parentChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VectorChunkUpsertWithWhereUniqueWithoutParentChunkInput = {
    where: VectorChunkWhereUniqueInput
    update: XOR<VectorChunkUpdateWithoutParentChunkInput, VectorChunkUncheckedUpdateWithoutParentChunkInput>
    create: XOR<VectorChunkCreateWithoutParentChunkInput, VectorChunkUncheckedCreateWithoutParentChunkInput>
  }

  export type VectorChunkUpdateWithWhereUniqueWithoutParentChunkInput = {
    where: VectorChunkWhereUniqueInput
    data: XOR<VectorChunkUpdateWithoutParentChunkInput, VectorChunkUncheckedUpdateWithoutParentChunkInput>
  }

  export type VectorChunkUpdateManyWithWhereWithoutParentChunkInput = {
    where: VectorChunkScalarWhereInput
    data: XOR<VectorChunkUpdateManyMutationInput, VectorChunkUncheckedUpdateManyWithoutParentChunkInput>
  }

  export type ResourceCreateWithoutSourceOfRelationshipsInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutResourcesInput
    space?: SpaceCreateNestedOneWithoutResourcesInput
    classification?: ClassificationCreateNestedOneWithoutResourcesInput
    contentSummaries?: ContentSummaryCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkCreateNestedManyWithoutResourceInput
    targetOfRelationships?: ContentRelationshipCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutSourceOfRelationshipsInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    spaceId?: string | null
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contentSummaries?: ContentSummaryUncheckedCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutResourceInput
    targetOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutTargetResourceInput
    learningAnalytics?: LearningAnalyticUncheckedCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutSourceOfRelationshipsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutSourceOfRelationshipsInput, ResourceUncheckedCreateWithoutSourceOfRelationshipsInput>
  }

  export type ResourceCreateWithoutTargetOfRelationshipsInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutResourcesInput
    space?: SpaceCreateNestedOneWithoutResourcesInput
    classification?: ClassificationCreateNestedOneWithoutResourcesInput
    contentSummaries?: ContentSummaryCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipCreateNestedManyWithoutSourceResourceInput
    learningAnalytics?: LearningAnalyticCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutTargetOfRelationshipsInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    spaceId?: string | null
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contentSummaries?: ContentSummaryUncheckedCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutSourceResourceInput
    learningAnalytics?: LearningAnalyticUncheckedCreateNestedManyWithoutResourceInput
    versions?: ResourceVersionUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutTargetOfRelationshipsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutTargetOfRelationshipsInput, ResourceUncheckedCreateWithoutTargetOfRelationshipsInput>
  }

  export type UserCreateWithoutContent_relationshipsInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    spaces?: SpaceCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutContent_relationshipsInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutContent_relationshipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContent_relationshipsInput, UserUncheckedCreateWithoutContent_relationshipsInput>
  }

  export type ResourceUpsertWithoutSourceOfRelationshipsInput = {
    update: XOR<ResourceUpdateWithoutSourceOfRelationshipsInput, ResourceUncheckedUpdateWithoutSourceOfRelationshipsInput>
    create: XOR<ResourceCreateWithoutSourceOfRelationshipsInput, ResourceUncheckedCreateWithoutSourceOfRelationshipsInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutSourceOfRelationshipsInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutSourceOfRelationshipsInput, ResourceUncheckedUpdateWithoutSourceOfRelationshipsInput>
  }

  export type ResourceUpdateWithoutSourceOfRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutResourcesNestedInput
    space?: SpaceUpdateOneWithoutResourcesNestedInput
    classification?: ClassificationUpdateOneWithoutResourcesNestedInput
    contentSummaries?: ContentSummaryUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUpdateManyWithoutResourceNestedInput
    targetOfRelationships?: ContentRelationshipUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutSourceOfRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentSummaries?: ContentSummaryUncheckedUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutResourceNestedInput
    targetOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUncheckedUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUpsertWithoutTargetOfRelationshipsInput = {
    update: XOR<ResourceUpdateWithoutTargetOfRelationshipsInput, ResourceUncheckedUpdateWithoutTargetOfRelationshipsInput>
    create: XOR<ResourceCreateWithoutTargetOfRelationshipsInput, ResourceUncheckedCreateWithoutTargetOfRelationshipsInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutTargetOfRelationshipsInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutTargetOfRelationshipsInput, ResourceUncheckedUpdateWithoutTargetOfRelationshipsInput>
  }

  export type ResourceUpdateWithoutTargetOfRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutResourcesNestedInput
    space?: SpaceUpdateOneWithoutResourcesNestedInput
    classification?: ClassificationUpdateOneWithoutResourcesNestedInput
    contentSummaries?: ContentSummaryUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUpdateManyWithoutSourceResourceNestedInput
    learningAnalytics?: LearningAnalyticUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutTargetOfRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentSummaries?: ContentSummaryUncheckedUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutSourceResourceNestedInput
    learningAnalytics?: LearningAnalyticUncheckedUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type UserUpsertWithoutContent_relationshipsInput = {
    update: XOR<UserUpdateWithoutContent_relationshipsInput, UserUncheckedUpdateWithoutContent_relationshipsInput>
    create: XOR<UserCreateWithoutContent_relationshipsInput, UserUncheckedCreateWithoutContent_relationshipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContent_relationshipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContent_relationshipsInput, UserUncheckedUpdateWithoutContent_relationshipsInput>
  }

  export type UserUpdateWithoutContent_relationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutContent_relationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type KnowledgeEdgeCreateWithoutSourceNodeInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    targetNode: KnowledgeNodeCreateNestedOneWithoutTargetKnowledgeEdgesInput
    creator?: UserCreateNestedOneWithoutKnowledge_edges_createdInput
  }

  export type KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    targetNodeId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KnowledgeEdgeCreateOrConnectWithoutSourceNodeInput = {
    where: KnowledgeEdgeWhereUniqueInput
    create: XOR<KnowledgeEdgeCreateWithoutSourceNodeInput, KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput>
  }

  export type KnowledgeEdgeCreateManySourceNodeInputEnvelope = {
    data: KnowledgeEdgeCreateManySourceNodeInput | KnowledgeEdgeCreateManySourceNodeInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeEdgeCreateWithoutTargetNodeInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sourceNode: KnowledgeNodeCreateNestedOneWithoutSourceKnowledgeEdgesInput
    creator?: UserCreateNestedOneWithoutKnowledge_edges_createdInput
  }

  export type KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    sourceNodeId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KnowledgeEdgeCreateOrConnectWithoutTargetNodeInput = {
    where: KnowledgeEdgeWhereUniqueInput
    create: XOR<KnowledgeEdgeCreateWithoutTargetNodeInput, KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput>
  }

  export type KnowledgeEdgeCreateManyTargetNodeInputEnvelope = {
    data: KnowledgeEdgeCreateManyTargetNodeInput | KnowledgeEdgeCreateManyTargetNodeInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeEdgeUpsertWithWhereUniqueWithoutSourceNodeInput = {
    where: KnowledgeEdgeWhereUniqueInput
    update: XOR<KnowledgeEdgeUpdateWithoutSourceNodeInput, KnowledgeEdgeUncheckedUpdateWithoutSourceNodeInput>
    create: XOR<KnowledgeEdgeCreateWithoutSourceNodeInput, KnowledgeEdgeUncheckedCreateWithoutSourceNodeInput>
  }

  export type KnowledgeEdgeUpdateWithWhereUniqueWithoutSourceNodeInput = {
    where: KnowledgeEdgeWhereUniqueInput
    data: XOR<KnowledgeEdgeUpdateWithoutSourceNodeInput, KnowledgeEdgeUncheckedUpdateWithoutSourceNodeInput>
  }

  export type KnowledgeEdgeUpdateManyWithWhereWithoutSourceNodeInput = {
    where: KnowledgeEdgeScalarWhereInput
    data: XOR<KnowledgeEdgeUpdateManyMutationInput, KnowledgeEdgeUncheckedUpdateManyWithoutSourceNodeInput>
  }

  export type KnowledgeEdgeUpsertWithWhereUniqueWithoutTargetNodeInput = {
    where: KnowledgeEdgeWhereUniqueInput
    update: XOR<KnowledgeEdgeUpdateWithoutTargetNodeInput, KnowledgeEdgeUncheckedUpdateWithoutTargetNodeInput>
    create: XOR<KnowledgeEdgeCreateWithoutTargetNodeInput, KnowledgeEdgeUncheckedCreateWithoutTargetNodeInput>
  }

  export type KnowledgeEdgeUpdateWithWhereUniqueWithoutTargetNodeInput = {
    where: KnowledgeEdgeWhereUniqueInput
    data: XOR<KnowledgeEdgeUpdateWithoutTargetNodeInput, KnowledgeEdgeUncheckedUpdateWithoutTargetNodeInput>
  }

  export type KnowledgeEdgeUpdateManyWithWhereWithoutTargetNodeInput = {
    where: KnowledgeEdgeScalarWhereInput
    data: XOR<KnowledgeEdgeUpdateManyMutationInput, KnowledgeEdgeUncheckedUpdateManyWithoutTargetNodeInput>
  }

  export type KnowledgeNodeCreateWithoutSourceKnowledgeEdgesInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    domain?: $Enums.ContentDomain | null
    importanceScore?: number
    mentionFrequency?: number
    mentionedInResources?: KnowledgeNodeCreatementionedInResourcesInput | string[]
    firstMentionedDate?: Date | string
    lastMentionedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    targetKnowledgeEdges?: KnowledgeEdgeCreateNestedManyWithoutTargetNodeInput
  }

  export type KnowledgeNodeUncheckedCreateWithoutSourceKnowledgeEdgesInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    domain?: $Enums.ContentDomain | null
    importanceScore?: number
    mentionFrequency?: number
    mentionedInResources?: KnowledgeNodeCreatementionedInResourcesInput | string[]
    firstMentionedDate?: Date | string
    lastMentionedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    targetKnowledgeEdges?: KnowledgeEdgeUncheckedCreateNestedManyWithoutTargetNodeInput
  }

  export type KnowledgeNodeCreateOrConnectWithoutSourceKnowledgeEdgesInput = {
    where: KnowledgeNodeWhereUniqueInput
    create: XOR<KnowledgeNodeCreateWithoutSourceKnowledgeEdgesInput, KnowledgeNodeUncheckedCreateWithoutSourceKnowledgeEdgesInput>
  }

  export type KnowledgeNodeCreateWithoutTargetKnowledgeEdgesInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    domain?: $Enums.ContentDomain | null
    importanceScore?: number
    mentionFrequency?: number
    mentionedInResources?: KnowledgeNodeCreatementionedInResourcesInput | string[]
    firstMentionedDate?: Date | string
    lastMentionedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sourceKnowledgeEdges?: KnowledgeEdgeCreateNestedManyWithoutSourceNodeInput
  }

  export type KnowledgeNodeUncheckedCreateWithoutTargetKnowledgeEdgesInput = {
    id?: string
    name: string
    type: string
    description?: string | null
    domain?: $Enums.ContentDomain | null
    importanceScore?: number
    mentionFrequency?: number
    mentionedInResources?: KnowledgeNodeCreatementionedInResourcesInput | string[]
    firstMentionedDate?: Date | string
    lastMentionedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sourceKnowledgeEdges?: KnowledgeEdgeUncheckedCreateNestedManyWithoutSourceNodeInput
  }

  export type KnowledgeNodeCreateOrConnectWithoutTargetKnowledgeEdgesInput = {
    where: KnowledgeNodeWhereUniqueInput
    create: XOR<KnowledgeNodeCreateWithoutTargetKnowledgeEdgesInput, KnowledgeNodeUncheckedCreateWithoutTargetKnowledgeEdgesInput>
  }

  export type UserCreateWithoutKnowledge_edges_createdInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    spaces?: SpaceCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutKnowledge_edges_createdInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutKnowledge_edges_createdInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKnowledge_edges_createdInput, UserUncheckedCreateWithoutKnowledge_edges_createdInput>
  }

  export type KnowledgeNodeUpsertWithoutSourceKnowledgeEdgesInput = {
    update: XOR<KnowledgeNodeUpdateWithoutSourceKnowledgeEdgesInput, KnowledgeNodeUncheckedUpdateWithoutSourceKnowledgeEdgesInput>
    create: XOR<KnowledgeNodeCreateWithoutSourceKnowledgeEdgesInput, KnowledgeNodeUncheckedCreateWithoutSourceKnowledgeEdgesInput>
    where?: KnowledgeNodeWhereInput
  }

  export type KnowledgeNodeUpdateToOneWithWhereWithoutSourceKnowledgeEdgesInput = {
    where?: KnowledgeNodeWhereInput
    data: XOR<KnowledgeNodeUpdateWithoutSourceKnowledgeEdgesInput, KnowledgeNodeUncheckedUpdateWithoutSourceKnowledgeEdgesInput>
  }

  export type KnowledgeNodeUpdateWithoutSourceKnowledgeEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    importanceScore?: IntFieldUpdateOperationsInput | number
    mentionFrequency?: IntFieldUpdateOperationsInput | number
    mentionedInResources?: KnowledgeNodeUpdatementionedInResourcesInput | string[]
    firstMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetKnowledgeEdges?: KnowledgeEdgeUpdateManyWithoutTargetNodeNestedInput
  }

  export type KnowledgeNodeUncheckedUpdateWithoutSourceKnowledgeEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    importanceScore?: IntFieldUpdateOperationsInput | number
    mentionFrequency?: IntFieldUpdateOperationsInput | number
    mentionedInResources?: KnowledgeNodeUpdatementionedInResourcesInput | string[]
    firstMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetKnowledgeEdges?: KnowledgeEdgeUncheckedUpdateManyWithoutTargetNodeNestedInput
  }

  export type KnowledgeNodeUpsertWithoutTargetKnowledgeEdgesInput = {
    update: XOR<KnowledgeNodeUpdateWithoutTargetKnowledgeEdgesInput, KnowledgeNodeUncheckedUpdateWithoutTargetKnowledgeEdgesInput>
    create: XOR<KnowledgeNodeCreateWithoutTargetKnowledgeEdgesInput, KnowledgeNodeUncheckedCreateWithoutTargetKnowledgeEdgesInput>
    where?: KnowledgeNodeWhereInput
  }

  export type KnowledgeNodeUpdateToOneWithWhereWithoutTargetKnowledgeEdgesInput = {
    where?: KnowledgeNodeWhereInput
    data: XOR<KnowledgeNodeUpdateWithoutTargetKnowledgeEdgesInput, KnowledgeNodeUncheckedUpdateWithoutTargetKnowledgeEdgesInput>
  }

  export type KnowledgeNodeUpdateWithoutTargetKnowledgeEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    importanceScore?: IntFieldUpdateOperationsInput | number
    mentionFrequency?: IntFieldUpdateOperationsInput | number
    mentionedInResources?: KnowledgeNodeUpdatementionedInResourcesInput | string[]
    firstMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceKnowledgeEdges?: KnowledgeEdgeUpdateManyWithoutSourceNodeNestedInput
  }

  export type KnowledgeNodeUncheckedUpdateWithoutTargetKnowledgeEdgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    importanceScore?: IntFieldUpdateOperationsInput | number
    mentionFrequency?: IntFieldUpdateOperationsInput | number
    mentionedInResources?: KnowledgeNodeUpdatementionedInResourcesInput | string[]
    firstMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMentionedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceKnowledgeEdges?: KnowledgeEdgeUncheckedUpdateManyWithoutSourceNodeNestedInput
  }

  export type UserUpsertWithoutKnowledge_edges_createdInput = {
    update: XOR<UserUpdateWithoutKnowledge_edges_createdInput, UserUncheckedUpdateWithoutKnowledge_edges_createdInput>
    create: XOR<UserCreateWithoutKnowledge_edges_createdInput, UserUncheckedCreateWithoutKnowledge_edges_createdInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKnowledge_edges_createdInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKnowledge_edges_createdInput, UserUncheckedUpdateWithoutKnowledge_edges_createdInput>
  }

  export type UserUpdateWithoutKnowledge_edges_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutKnowledge_edges_createdInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutSearch_queriesInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    spaces?: SpaceCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSearch_queriesInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSearch_queriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSearch_queriesInput, UserUncheckedCreateWithoutSearch_queriesInput>
  }

  export type UserUpsertWithoutSearch_queriesInput = {
    update: XOR<UserUpdateWithoutSearch_queriesInput, UserUncheckedUpdateWithoutSearch_queriesInput>
    create: XOR<UserCreateWithoutSearch_queriesInput, UserUncheckedCreateWithoutSearch_queriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSearch_queriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSearch_queriesInput, UserUncheckedUpdateWithoutSearch_queriesInput>
  }

  export type UserUpdateWithoutSearch_queriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSearch_queriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutLearning_analyticsInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    spaces?: SpaceCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutLearning_analyticsInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutLearning_analyticsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLearning_analyticsInput, UserUncheckedCreateWithoutLearning_analyticsInput>
  }

  export type ResourceCreateWithoutLearningAnalyticsInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutResourcesInput
    space?: SpaceCreateNestedOneWithoutResourcesInput
    classification?: ClassificationCreateNestedOneWithoutResourcesInput
    contentSummaries?: ContentSummaryCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipCreateNestedManyWithoutTargetResourceInput
    versions?: ResourceVersionCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutLearningAnalyticsInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    spaceId?: string | null
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    contentSummaries?: ContentSummaryUncheckedCreateNestedManyWithoutResourceInput
    vectorChunks?: VectorChunkUncheckedCreateNestedManyWithoutResourceInput
    sourceOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutSourceResourceInput
    targetOfRelationships?: ContentRelationshipUncheckedCreateNestedManyWithoutTargetResourceInput
    versions?: ResourceVersionUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutLearningAnalyticsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutLearningAnalyticsInput, ResourceUncheckedCreateWithoutLearningAnalyticsInput>
  }

  export type UserUpsertWithoutLearning_analyticsInput = {
    update: XOR<UserUpdateWithoutLearning_analyticsInput, UserUncheckedUpdateWithoutLearning_analyticsInput>
    create: XOR<UserCreateWithoutLearning_analyticsInput, UserUncheckedCreateWithoutLearning_analyticsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLearning_analyticsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLearning_analyticsInput, UserUncheckedUpdateWithoutLearning_analyticsInput>
  }

  export type UserUpdateWithoutLearning_analyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutLearning_analyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ResourceUpsertWithoutLearningAnalyticsInput = {
    update: XOR<ResourceUpdateWithoutLearningAnalyticsInput, ResourceUncheckedUpdateWithoutLearningAnalyticsInput>
    create: XOR<ResourceCreateWithoutLearningAnalyticsInput, ResourceUncheckedCreateWithoutLearningAnalyticsInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutLearningAnalyticsInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutLearningAnalyticsInput, ResourceUncheckedUpdateWithoutLearningAnalyticsInput>
  }

  export type ResourceUpdateWithoutLearningAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutResourcesNestedInput
    space?: SpaceUpdateOneWithoutResourcesNestedInput
    classification?: ClassificationUpdateOneWithoutResourcesNestedInput
    contentSummaries?: ContentSummaryUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUpdateManyWithoutTargetResourceNestedInput
    versions?: ResourceVersionUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutLearningAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentSummaries?: ContentSummaryUncheckedUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutTargetResourceNestedInput
    versions?: ResourceVersionUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type UserCreateWithoutBatch_jobsInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    spaces?: SpaceCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutBatch_jobsInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutBatch_jobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBatch_jobsInput, UserUncheckedCreateWithoutBatch_jobsInput>
  }

  export type UserUpsertWithoutBatch_jobsInput = {
    update: XOR<UserUpdateWithoutBatch_jobsInput, UserUncheckedUpdateWithoutBatch_jobsInput>
    create: XOR<UserCreateWithoutBatch_jobsInput, UserUncheckedCreateWithoutBatch_jobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBatch_jobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBatch_jobsInput, UserUncheckedUpdateWithoutBatch_jobsInput>
  }

  export type UserUpdateWithoutBatch_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutBatch_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutPrompt_logsInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    spaces?: SpaceCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPrompt_logsInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    change_logs?: ChangeLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPrompt_logsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrompt_logsInput, UserUncheckedCreateWithoutPrompt_logsInput>
  }

  export type UserUpsertWithoutPrompt_logsInput = {
    update: XOR<UserUpdateWithoutPrompt_logsInput, UserUncheckedUpdateWithoutPrompt_logsInput>
    create: XOR<UserCreateWithoutPrompt_logsInput, UserUncheckedCreateWithoutPrompt_logsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrompt_logsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrompt_logsInput, UserUncheckedUpdateWithoutPrompt_logsInput>
  }

  export type UserUpdateWithoutPrompt_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPrompt_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    change_logs?: ChangeLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutChange_logsInput = {
    id: string
    user_profile?: UserProfileCreateNestedOneWithoutUserInput
    spaces?: SpaceCreateNestedManyWithoutUserInput
    resources?: ResourceCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutChange_logsInput = {
    id: string
    user_profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutUserInput
    resources?: ResourceUncheckedCreateNestedManyWithoutUserInput
    search_queries?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    learning_analytics?: LearningAnalyticUncheckedCreateNestedManyWithoutUserInput
    content_relationships?: ContentRelationshipUncheckedCreateNestedManyWithoutCreatorInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedCreateNestedManyWithoutCreatorInput
    batch_jobs?: BatchJobUncheckedCreateNestedManyWithoutUserInput
    prompt_logs?: PromptLogUncheckedCreateNestedManyWithoutUserInput
    resource_versions?: ResourceVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutChange_logsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChange_logsInput, UserUncheckedCreateWithoutChange_logsInput>
  }

  export type UserUpsertWithoutChange_logsInput = {
    update: XOR<UserUpdateWithoutChange_logsInput, UserUncheckedUpdateWithoutChange_logsInput>
    create: XOR<UserCreateWithoutChange_logsInput, UserUncheckedCreateWithoutChange_logsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChange_logsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChange_logsInput, UserUncheckedUpdateWithoutChange_logsInput>
  }

  export type UserUpdateWithoutChange_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUpdateOneWithoutUserNestedInput
    spaces?: SpaceUpdateManyWithoutUserNestedInput
    resources?: ResourceUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutChange_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutUserNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutUserNestedInput
    search_queries?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    learning_analytics?: LearningAnalyticUncheckedUpdateManyWithoutUserNestedInput
    content_relationships?: ContentRelationshipUncheckedUpdateManyWithoutCreatorNestedInput
    knowledge_edges_created?: KnowledgeEdgeUncheckedUpdateManyWithoutCreatorNestedInput
    batch_jobs?: BatchJobUncheckedUpdateManyWithoutUserNestedInput
    prompt_logs?: PromptLogUncheckedUpdateManyWithoutUserNestedInput
    resource_versions?: ResourceVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SpaceCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    domain: $Enums.ContentDomain
    isDefault?: boolean
    contentCount?: number
    lastAccessed?: Date | string
    pineconeNamespace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ResourceCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    spaceId?: string | null
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SearchQueryCreateManyUserInput = {
    id?: string
    query: string
    queryType?: string
    resultsCount?: number
    avgRelevanceScore?: Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryCreateclickedResultsInput | string[]
    extractedIntent?: string | null
    domainClassification?: $Enums.ContentDomain | null
    complexityDetected?: $Enums.ComplexityLevel | null
    responseTimeMs?: number | null
    userSatisfaction?: number | null
    createdAt?: Date | string
  }

  export type LearningAnalyticCreateManyUserInput = {
    id?: string
    eventType: string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: string | null
    comprehensionLevel?: number | null
    implementationStatus?: $Enums.ImplementationStatus | null
    deviceType?: string | null
    timeSpentSeconds?: number | null
    referralSource?: string | null
    resourceId?: string | null
    createdAt?: Date | string
  }

  export type ContentRelationshipCreateManyCreatorInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    sourceResourceId: string
    targetResourceId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KnowledgeEdgeCreateManyCreatorInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    sourceNodeId: string
    targetNodeId: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BatchJobCreateManyUserInput = {
    id?: string
    status: $Enums.BatchJobStatus
    progress?: number
    totalItems: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptLogCreateManyUserInput = {
    id?: string
    queryText: string
    tier: $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    latencyMs?: number | null
    createdAt?: Date | string
  }

  export type ChangeLogCreateManyUserInput = {
    id?: string
    changeType: string
    changeDetails?: JsonNullValueInput | InputJsonValue
    changedAt?: Date | string
  }

  export type ResourceVersionCreateManyCreatorInput = {
    id?: string
    versionNumber: number
    title: string
    content?: string | null
    tags?: ResourceVersionCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    resourceId: string
    createdAt?: Date | string
  }

  export type SpaceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    contentCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resources?: ResourceUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    contentCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resources?: ResourceUncheckedUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    contentCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResourceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    space?: SpaceUpdateOneWithoutResourcesNestedInput
    classification?: ClassificationUpdateOneWithoutResourcesNestedInput
    contentSummaries?: ContentSummaryUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentSummaries?: ContentSummaryUncheckedUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUncheckedUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchQueryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    queryType?: StringFieldUpdateOperationsInput | string
    resultsCount?: IntFieldUpdateOperationsInput | number
    avgRelevanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryUpdateclickedResultsInput | string[]
    extractedIntent?: NullableStringFieldUpdateOperationsInput | string | null
    domainClassification?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    complexityDetected?: NullableEnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    queryType?: StringFieldUpdateOperationsInput | string
    resultsCount?: IntFieldUpdateOperationsInput | number
    avgRelevanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryUpdateclickedResultsInput | string[]
    extractedIntent?: NullableStringFieldUpdateOperationsInput | string | null
    domainClassification?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    complexityDetected?: NullableEnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    queryType?: StringFieldUpdateOperationsInput | string
    resultsCount?: IntFieldUpdateOperationsInput | number
    avgRelevanceScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    clickedResults?: SearchQueryUpdateclickedResultsInput | string[]
    extractedIntent?: NullableStringFieldUpdateOperationsInput | string | null
    domainClassification?: NullableEnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain | null
    complexityDetected?: NullableEnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningAnalyticUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    comprehensionLevel?: NullableIntFieldUpdateOperationsInput | number | null
    implementationStatus?: NullableEnumImplementationStatusFieldUpdateOperationsInput | $Enums.ImplementationStatus | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resource?: ResourceUpdateOneWithoutLearningAnalyticsNestedInput
  }

  export type LearningAnalyticUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    comprehensionLevel?: NullableIntFieldUpdateOperationsInput | number | null
    implementationStatus?: NullableEnumImplementationStatusFieldUpdateOperationsInput | $Enums.ImplementationStatus | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningAnalyticUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    comprehensionLevel?: NullableIntFieldUpdateOperationsInput | number | null
    implementationStatus?: NullableEnumImplementationStatusFieldUpdateOperationsInput | $Enums.ImplementationStatus | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentRelationshipUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceResource?: ResourceUpdateOneRequiredWithoutSourceOfRelationshipsNestedInput
    targetResource?: ResourceUpdateOneRequiredWithoutTargetOfRelationshipsNestedInput
  }

  export type ContentRelationshipUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceResourceId?: StringFieldUpdateOperationsInput | string
    targetResourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentRelationshipUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceResourceId?: StringFieldUpdateOperationsInput | string
    targetResourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeEdgeUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNode?: KnowledgeNodeUpdateOneRequiredWithoutSourceKnowledgeEdgesNestedInput
    targetNode?: KnowledgeNodeUpdateOneRequiredWithoutTargetKnowledgeEdgesNestedInput
  }

  export type KnowledgeEdgeUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeEdgeUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    targetNodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BatchJobUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchJobStatusFieldUpdateOperationsInput | $Enums.BatchJobStatus
    progress?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchJobUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchJobStatusFieldUpdateOperationsInput | $Enums.BatchJobStatus
    progress?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchJobUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchJobStatusFieldUpdateOperationsInput | $Enums.BatchJobStatus
    progress?: IntFieldUpdateOperationsInput | number
    totalItems?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    tier?: EnumPromptLogTierFieldUpdateOperationsInput | $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    tier?: EnumPromptLogTierFieldUpdateOperationsInput | $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    tier?: EnumPromptLogTierFieldUpdateOperationsInput | $Enums.PromptLogTier
    response?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    latencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDetails?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDetails?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDetails?: JsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceVersionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceVersionUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resource?: ResourceUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type ResourceVersionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceVersionUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    resourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceVersionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceVersionUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    resourceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateManySpaceInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    classificationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ResourceUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutResourcesNestedInput
    classification?: ClassificationUpdateOneWithoutResourcesNestedInput
    contentSummaries?: ContentSummaryUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentSummaries?: ContentSummaryUncheckedUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUncheckedUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateManyWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    classificationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentSummaryCreateManyResourceInput = {
    id?: string
    executiveSummary: string
    keyInsights?: string | null
    immediateActions?: string | null
    criticalWarnings?: string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryCreatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryCreateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryCreatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryCreatequestionBasedTagsInput | string[]
    totalChunks?: number
    embeddingModel?: string
    avgChunkTokens?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VectorChunkCreateManyResourceInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    summaryId: string
    parentChunkId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContentRelationshipCreateManySourceResourceInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    targetResourceId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ContentRelationshipCreateManyTargetResourceInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    relationshipReason?: string | null
    isAutoGenerated?: boolean
    sourceResourceId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LearningAnalyticCreateManyResourceInput = {
    id?: string
    eventType: string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: string | null
    comprehensionLevel?: number | null
    implementationStatus?: $Enums.ImplementationStatus | null
    deviceType?: string | null
    timeSpentSeconds?: number | null
    referralSource?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type ResourceVersionCreateManyResourceInput = {
    id?: string
    versionNumber: number
    title: string
    content?: string | null
    tags?: ResourceVersionCreatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type ContentSummaryUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    keyInsights?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryUpdatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryUpdateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryUpdatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryUpdatequestionBasedTagsInput | string[]
    totalChunks?: IntFieldUpdateOperationsInput | number
    embeddingModel?: StringFieldUpdateOperationsInput | string
    avgChunkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vectorChunks?: VectorChunkUpdateManyWithoutSummaryNestedInput
  }

  export type ContentSummaryUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    keyInsights?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryUpdatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryUpdateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryUpdatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryUpdatequestionBasedTagsInput | string[]
    totalChunks?: IntFieldUpdateOperationsInput | number
    embeddingModel?: StringFieldUpdateOperationsInput | string
    avgChunkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutSummaryNestedInput
  }

  export type ContentSummaryUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    executiveSummary?: StringFieldUpdateOperationsInput | string
    keyInsights?: NullableStringFieldUpdateOperationsInput | string | null
    immediateActions?: NullableStringFieldUpdateOperationsInput | string | null
    criticalWarnings?: NullableStringFieldUpdateOperationsInput | string | null
    keyMetrics?: JsonNullValueInput | InputJsonValue
    toolsResources?: JsonNullValueInput | InputJsonValue
    peopleCompanies?: ContentSummaryUpdatepeopleCompaniesInput | string[]
    primaryKeywords?: ContentSummaryUpdateprimaryKeywordsInput | string[]
    semanticTags?: ContentSummaryUpdatesemanticTagsInput | string[]
    questionBasedTags?: ContentSummaryUpdatequestionBasedTagsInput | string[]
    totalChunks?: IntFieldUpdateOperationsInput | number
    embeddingModel?: StringFieldUpdateOperationsInput | string
    avgChunkTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VectorChunkUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: ContentSummaryUpdateOneRequiredWithoutVectorChunksNestedInput
    parentChunk?: VectorChunkUpdateOneWithoutChildChunksNestedInput
    childChunks?: VectorChunkUpdateManyWithoutParentChunkNestedInput
  }

  export type VectorChunkUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summaryId?: StringFieldUpdateOperationsInput | string
    parentChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childChunks?: VectorChunkUncheckedUpdateManyWithoutParentChunkNestedInput
  }

  export type VectorChunkUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summaryId?: StringFieldUpdateOperationsInput | string
    parentChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentRelationshipUpdateWithoutSourceResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetResource?: ResourceUpdateOneRequiredWithoutTargetOfRelationshipsNestedInput
    creator?: UserUpdateOneWithoutContent_relationshipsNestedInput
  }

  export type ContentRelationshipUncheckedUpdateWithoutSourceResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    targetResourceId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentRelationshipUncheckedUpdateManyWithoutSourceResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    targetResourceId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentRelationshipUpdateWithoutTargetResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceResource?: ResourceUpdateOneRequiredWithoutSourceOfRelationshipsNestedInput
    creator?: UserUpdateOneWithoutContent_relationshipsNestedInput
  }

  export type ContentRelationshipUncheckedUpdateWithoutTargetResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceResourceId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContentRelationshipUncheckedUpdateManyWithoutTargetResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    relationshipReason?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceResourceId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LearningAnalyticUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    comprehensionLevel?: NullableIntFieldUpdateOperationsInput | number | null
    implementationStatus?: NullableEnumImplementationStatusFieldUpdateOperationsInput | $Enums.ImplementationStatus | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLearning_analyticsNestedInput
  }

  export type LearningAnalyticUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    comprehensionLevel?: NullableIntFieldUpdateOperationsInput | number | null
    implementationStatus?: NullableEnumImplementationStatusFieldUpdateOperationsInput | $Enums.ImplementationStatus | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningAnalyticUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDetails?: JsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    comprehensionLevel?: NullableIntFieldUpdateOperationsInput | number | null
    implementationStatus?: NullableEnumImplementationStatusFieldUpdateOperationsInput | $Enums.ImplementationStatus | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceVersionUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceVersionUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutResource_versionsNestedInput
  }

  export type ResourceVersionUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceVersionUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceVersionUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceVersionUpdatetagsInput | string[]
    metadata?: JsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassificationCreateManyParentInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    domain: $Enums.ContentDomain
    usageCount?: number
    isSystemDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ResourceCreateManyClassificationInput = {
    id?: string
    title: string
    description?: string | null
    url?: string | null
    type: $Enums.ResourceType
    content?: string | null
    tags?: ResourceCreatetagsInput | string[]
    domain: $Enums.ContentDomain
    language?: string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel: $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: number | null
    wordCount?: number | null
    processingStatus: $Enums.ProcessingStatus
    processedAt?: Date | string | null
    actionDensity: $Enums.ActionDensity
    noveltyScore?: number | null
    practicalApplicability?: $Enums.PracticalApplicability | null
    userId: string
    spaceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ClassificationUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ClassificationUpdateManyWithoutParentNestedInput
    resources?: ResourceUpdateManyWithoutClassificationNestedInput
  }

  export type ClassificationUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ClassificationUncheckedUpdateManyWithoutParentNestedInput
    resources?: ResourceUncheckedUpdateManyWithoutClassificationNestedInput
  }

  export type ClassificationUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    usageCount?: IntFieldUpdateOperationsInput | number
    isSystemDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResourceUpdateWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutResourcesNestedInput
    space?: SpaceUpdateOneWithoutResourcesNestedInput
    contentSummaries?: ContentSummaryUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contentSummaries?: ContentSummaryUncheckedUpdateManyWithoutResourceNestedInput
    vectorChunks?: VectorChunkUncheckedUpdateManyWithoutResourceNestedInput
    sourceOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutSourceResourceNestedInput
    targetOfRelationships?: ContentRelationshipUncheckedUpdateManyWithoutTargetResourceNestedInput
    learningAnalytics?: LearningAnalyticUncheckedUpdateManyWithoutResourceNestedInput
    versions?: ResourceVersionUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateManyWithoutClassificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ResourceUpdatetagsInput | string[]
    domain?: EnumContentDomainFieldUpdateOperationsInput | $Enums.ContentDomain
    language?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    complexityLevel?: EnumComplexityLevelFieldUpdateOperationsInput | $Enums.ComplexityLevel
    estimatedReadTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actionDensity?: EnumActionDensityFieldUpdateOperationsInput | $Enums.ActionDensity
    noveltyScore?: NullableIntFieldUpdateOperationsInput | number | null
    practicalApplicability?: NullableEnumPracticalApplicabilityFieldUpdateOperationsInput | $Enums.PracticalApplicability | null
    userId?: StringFieldUpdateOperationsInput | string
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VectorChunkCreateManySummaryInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    resourceId: string
    parentChunkId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VectorChunkUpdateWithoutSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resource?: ResourceUpdateOneRequiredWithoutVectorChunksNestedInput
    parentChunk?: VectorChunkUpdateOneWithoutChildChunksNestedInput
    childChunks?: VectorChunkUpdateManyWithoutParentChunkNestedInput
  }

  export type VectorChunkUncheckedUpdateWithoutSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resourceId?: StringFieldUpdateOperationsInput | string
    parentChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childChunks?: VectorChunkUncheckedUpdateManyWithoutParentChunkNestedInput
  }

  export type VectorChunkUncheckedUpdateManyWithoutSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resourceId?: StringFieldUpdateOperationsInput | string
    parentChunkId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VectorChunkCreateManyParentChunkInput = {
    id?: string
    chunkIndex: number
    chunkType: $Enums.ChunkType
    content: string
    tokenCount: number
    pineconeId?: string | null
    pineconeNamespace?: string | null
    embeddingModel?: string
    vectorDimension?: number
    overlappingChunks?: VectorChunkCreateoverlappingChunksInput | string[]
    semanticDensity?: Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: number
    lastRetrieved?: Date | string | null
    resourceId: string
    summaryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type VectorChunkUpdateWithoutParentChunkInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resource?: ResourceUpdateOneRequiredWithoutVectorChunksNestedInput
    summary?: ContentSummaryUpdateOneRequiredWithoutVectorChunksNestedInput
    childChunks?: VectorChunkUpdateManyWithoutParentChunkNestedInput
  }

  export type VectorChunkUncheckedUpdateWithoutParentChunkInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resourceId?: StringFieldUpdateOperationsInput | string
    summaryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    childChunks?: VectorChunkUncheckedUpdateManyWithoutParentChunkNestedInput
  }

  export type VectorChunkUncheckedUpdateManyWithoutParentChunkInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    chunkType?: EnumChunkTypeFieldUpdateOperationsInput | $Enums.ChunkType
    content?: StringFieldUpdateOperationsInput | string
    tokenCount?: IntFieldUpdateOperationsInput | number
    pineconeId?: NullableStringFieldUpdateOperationsInput | string | null
    pineconeNamespace?: NullableStringFieldUpdateOperationsInput | string | null
    embeddingModel?: StringFieldUpdateOperationsInput | string
    vectorDimension?: IntFieldUpdateOperationsInput | number
    overlappingChunks?: VectorChunkUpdateoverlappingChunksInput | string[]
    semanticDensity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    retrievalFrequency?: IntFieldUpdateOperationsInput | number
    lastRetrieved?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resourceId?: StringFieldUpdateOperationsInput | string
    summaryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeEdgeCreateManySourceNodeInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    targetNodeId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KnowledgeEdgeCreateManyTargetNodeInput = {
    id?: string
    relationshipType: $Enums.RelationshipType
    strength?: Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeCreateevidenceResourcesInput | string[]
    isAutoGenerated?: boolean
    sourceNodeId: string
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KnowledgeEdgeUpdateWithoutSourceNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetNode?: KnowledgeNodeUpdateOneRequiredWithoutTargetKnowledgeEdgesNestedInput
    creator?: UserUpdateOneWithoutKnowledge_edges_createdNestedInput
  }

  export type KnowledgeEdgeUncheckedUpdateWithoutSourceNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    targetNodeId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeEdgeUncheckedUpdateManyWithoutSourceNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    targetNodeId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeEdgeUpdateWithoutTargetNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceNode?: KnowledgeNodeUpdateOneRequiredWithoutSourceKnowledgeEdgesNestedInput
    creator?: UserUpdateOneWithoutKnowledge_edges_createdNestedInput
  }

  export type KnowledgeEdgeUncheckedUpdateWithoutTargetNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeEdgeUncheckedUpdateManyWithoutTargetNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipType?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    evidenceResources?: KnowledgeEdgeUpdateevidenceResourcesInput | string[]
    isAutoGenerated?: BoolFieldUpdateOperationsInput | boolean
    sourceNodeId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}